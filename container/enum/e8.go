// Code generated by nago/internal/gen.go; DO NOT EDIT.

package enum

import (
	"encoding/json"
	"fmt"
	"reflect"
)

type E8[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any] struct {
	ordinal int
	v       any
}

func (e E8[T1, T2, T3, T4, T5, T6, T7, T8]) With1(t1 T1) E8[T1, T2, T3, T4, T5, T6, T7, T8] {
	return E8[T1, T2, T3, T4, T5, T6, T7, T8]{
		ordinal: 1,
		v:       t1,
	}
}

func (e E8[T1, T2, T3, T4, T5, T6, T7, T8]) With2(t2 T2) E8[T1, T2, T3, T4, T5, T6, T7, T8] {
	return E8[T1, T2, T3, T4, T5, T6, T7, T8]{
		ordinal: 2,
		v:       t2,
	}
}

func (e E8[T1, T2, T3, T4, T5, T6, T7, T8]) With3(t3 T3) E8[T1, T2, T3, T4, T5, T6, T7, T8] {
	return E8[T1, T2, T3, T4, T5, T6, T7, T8]{
		ordinal: 3,
		v:       t3,
	}
}

func (e E8[T1, T2, T3, T4, T5, T6, T7, T8]) With4(t4 T4) E8[T1, T2, T3, T4, T5, T6, T7, T8] {
	return E8[T1, T2, T3, T4, T5, T6, T7, T8]{
		ordinal: 4,
		v:       t4,
	}
}

func (e E8[T1, T2, T3, T4, T5, T6, T7, T8]) With5(t5 T5) E8[T1, T2, T3, T4, T5, T6, T7, T8] {
	return E8[T1, T2, T3, T4, T5, T6, T7, T8]{
		ordinal: 5,
		v:       t5,
	}
}

func (e E8[T1, T2, T3, T4, T5, T6, T7, T8]) With6(t6 T6) E8[T1, T2, T3, T4, T5, T6, T7, T8] {
	return E8[T1, T2, T3, T4, T5, T6, T7, T8]{
		ordinal: 6,
		v:       t6,
	}
}

func (e E8[T1, T2, T3, T4, T5, T6, T7, T8]) With7(t7 T7) E8[T1, T2, T3, T4, T5, T6, T7, T8] {
	return E8[T1, T2, T3, T4, T5, T6, T7, T8]{
		ordinal: 7,
		v:       t7,
	}
}

func (e E8[T1, T2, T3, T4, T5, T6, T7, T8]) With8(t8 T8) E8[T1, T2, T3, T4, T5, T6, T7, T8] {
	return E8[T1, T2, T3, T4, T5, T6, T7, T8]{
		ordinal: 8,
		v:       t8,
	}
}

func (e E8[T1, T2, T3, T4, T5, T6, T7, T8]) String() string {
	return toString(e)
}

func (e E8[T1, T2, T3, T4, T5, T6, T7, T8]) Nil() bool {
	return e.ordinal == 0
}

func (e E8[T1, T2, T3, T4, T5, T6, T7, T8]) Ordinal() int {
	return e.ordinal
}

func (e E8[T1, T2, T3, T4, T5, T6, T7, T8]) Unwrap() any {
	return e.v
}

func (e E8[T1, T2, T3, T4, T5, T6, T7, T8]) MarshalJSON() ([]byte, error) {
	switch e.ordinal {
	case 0:
		return json.Marshal(adjacentlyTagged[any]{})

	case 1:
		var zero T1
		return json.Marshal(adjacentlyTagged[T1]{
			Type:  reflect.TypeOf(zero).Name(),
			Value: e.v.(T1),
		})

	case 2:
		var zero T2
		return json.Marshal(adjacentlyTagged[T2]{
			Type:  reflect.TypeOf(zero).Name(),
			Value: e.v.(T2),
		})

	case 3:
		var zero T3
		return json.Marshal(adjacentlyTagged[T3]{
			Type:  reflect.TypeOf(zero).Name(),
			Value: e.v.(T3),
		})

	case 4:
		var zero T4
		return json.Marshal(adjacentlyTagged[T4]{
			Type:  reflect.TypeOf(zero).Name(),
			Value: e.v.(T4),
		})

	case 5:
		var zero T5
		return json.Marshal(adjacentlyTagged[T5]{
			Type:  reflect.TypeOf(zero).Name(),
			Value: e.v.(T5),
		})

	case 6:
		var zero T6
		return json.Marshal(adjacentlyTagged[T6]{
			Type:  reflect.TypeOf(zero).Name(),
			Value: e.v.(T6),
		})

	case 7:
		var zero T7
		return json.Marshal(adjacentlyTagged[T7]{
			Type:  reflect.TypeOf(zero).Name(),
			Value: e.v.(T7),
		})

	case 8:
		var zero T8
		return json.Marshal(adjacentlyTagged[T8]{
			Type:  reflect.TypeOf(zero).Name(),
			Value: e.v.(T8),
		})

	default:
		panic("unreachable")
	}
}

func (e *E8[T1, T2, T3, T4, T5, T6, T7, T8]) UnmarshalJSON(bytes []byte) error {
	var preflight adjacentlyTaggedPreflight
	if err := json.Unmarshal(bytes, &preflight); err != nil {
		return err
	}

	if preflight.Type == "" {
		e.v = nil
		e.ordinal = 0
		return nil
	}

	var t1 adjacentlyTagged[T1]

	var t2 adjacentlyTagged[T2]

	var t3 adjacentlyTagged[T3]

	var t4 adjacentlyTagged[T4]

	var t5 adjacentlyTagged[T5]

	var t6 adjacentlyTagged[T6]

	var t7 adjacentlyTagged[T7]

	var t8 adjacentlyTagged[T8]

	switch preflight.Type {

	case reflect.TypeOf(t1.Value).Name():
		if err := json.Unmarshal(bytes, &t1); err != nil {
			return nil
		}
		e.v = t1.Value
		e.ordinal = 1
		return nil

	case reflect.TypeOf(t2.Value).Name():
		if err := json.Unmarshal(bytes, &t2); err != nil {
			return nil
		}
		e.v = t2.Value
		e.ordinal = 2
		return nil

	case reflect.TypeOf(t3.Value).Name():
		if err := json.Unmarshal(bytes, &t3); err != nil {
			return nil
		}
		e.v = t3.Value
		e.ordinal = 3
		return nil

	case reflect.TypeOf(t4.Value).Name():
		if err := json.Unmarshal(bytes, &t4); err != nil {
			return nil
		}
		e.v = t4.Value
		e.ordinal = 4
		return nil

	case reflect.TypeOf(t5.Value).Name():
		if err := json.Unmarshal(bytes, &t5); err != nil {
			return nil
		}
		e.v = t5.Value
		e.ordinal = 5
		return nil

	case reflect.TypeOf(t6.Value).Name():
		if err := json.Unmarshal(bytes, &t6); err != nil {
			return nil
		}
		e.v = t6.Value
		e.ordinal = 6
		return nil

	case reflect.TypeOf(t7.Value).Name():
		if err := json.Unmarshal(bytes, &t7); err != nil {
			return nil
		}
		e.v = t7.Value
		e.ordinal = 7
		return nil

	case reflect.TypeOf(t8.Value).Name():
		if err := json.Unmarshal(bytes, &t8); err != nil {
			return nil
		}
		e.v = t8.Value
		e.ordinal = 8
		return nil

	default:
		return fmt.Errorf("invalid enum type: %s", preflight.Type)
	}
}

func Match8[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, R any](e E8[T1, T2, T3, T4, T5, T6, T7, T8], f1 func(T1) R, f2 func(T2) R, f3 func(T3) R, f4 func(T4) R, f5 func(T5) R, f6 func(T6) R, f7 func(T7) R, f8 func(T8) R) R {
	switch e.ordinal {

	case 1:
		return f1(e.v.(T1))

	case 2:
		return f2(e.v.(T2))

	case 3:
		return f3(e.v.(T3))

	case 4:
		return f4(e.v.(T4))

	case 5:
		return f5(e.v.(T5))

	case 6:
		return f6(e.v.(T6))

	case 7:
		return f7(e.v.(T7))

	case 8:
		return f8(e.v.(T8))

	}

	panic("enum is invalid")
}
