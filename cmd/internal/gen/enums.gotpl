// Code generated by nago/internal/gen.go; DO NOT EDIT.

package enum

import (
	"encoding/json"
	"fmt"
	"reflect"
)


type E{{.Cardinality}}[{{range .TypeParams }}T{{.Ordinal}} any,{{end}}] struct {
	ordinal int
	v       any
}

{{range .TypeParams}}
func (e E{{$.Cardinality}}[{{range $.TypeParams }}T{{.Ordinal}},{{end}}]) With{{.Ordinal}}(t{{.Ordinal}} T{{.Ordinal}}) E{{$.Cardinality}}[{{range $.TypeParams }}T{{.Ordinal}},{{end}}] {
	return E{{$.Cardinality}}[{{range $.TypeParams }}T{{.Ordinal}},{{end}}]{
		ordinal: {{.Ordinal}},
		v:       t{{.Ordinal}},
	}
}
{{end}}


func (e E{{$.Cardinality}}[{{range .TypeParams }}T{{.Ordinal}},{{end}}]) Nil() bool {
	return e.ordinal != 0
}

func (e E{{$.Cardinality}}[{{range .TypeParams }}T{{.Ordinal}},{{end}}]) Ordinal() int {
	return e.ordinal
}

func (e E{{$.Cardinality}}[{{range .TypeParams }}T{{.Ordinal}},{{end}}]) Unwrap() any {
	return e.v
}

func (e E{{.Cardinality}}[{{range .TypeParams }}T{{.Ordinal}},{{end}}]) MarshalJSON() ([]byte, error) {
	switch e.ordinal {
	case 0:
		return json.Marshal(adjacentlyTagged[any]{})
    {{range $.TypeParams }}
    case {{.Ordinal}}:
        var zero T{{.Ordinal}}
        return json.Marshal(adjacentlyTagged[T{{.Ordinal}}]{
            Type:  reflect.TypeOf(zero).Name(),
            Value: e.v.(T{{.Ordinal}}),
        })
    {{end}}

	default:
		panic("unreachable")
	}
}


func (e *E{{.Cardinality}}[{{range .TypeParams }}T{{.Ordinal}},{{end}}]) UnmarshalJSON(bytes []byte) error {
	var preflight adjacentlyTaggedPreflight
	if err := json.Unmarshal(bytes, &preflight); err != nil {
		return err
	}

	if preflight.Type == "" {
		e.v = nil
		e.ordinal = 0
		return nil
	}

    {{range $.TypeParams }}
	var t{{.Ordinal}} adjacentlyTagged[T{{.Ordinal}}]
    {{end}}

	switch preflight.Type {
	{{range $.TypeParams }}
	case reflect.TypeOf(t{{.Ordinal}}.Value).Name():
	    if err := json.Unmarshal(bytes, &t{{.Ordinal}}); err != nil {
            return nil
        }
        e.v = t{{.Ordinal}}.Value
        e.ordinal = {{.Ordinal}}
        return nil
	{{end}}


	default:
		return fmt.Errorf("invalid enum type: %s", preflight.Type)
	}
}

func Match{{.Cardinality}}[{{range .TypeParams }}T{{.Ordinal}} any,{{end}} R any](e E{{.Cardinality}}[{{range .TypeParams }}T{{.Ordinal}},{{end}}],{{range .TypeParams }}f{{.Ordinal}} func(T{{.Ordinal}}) R,{{end}}) R {
	switch e.ordinal {
	{{range $.TypeParams }}
	case {{.Ordinal}}:
	    return f{{.Ordinal}}(e.v.(T{{.Ordinal}}))
	{{end}}
    }

	panic("enum is invalid")
}
