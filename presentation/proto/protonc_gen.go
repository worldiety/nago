// Code generated by NAGO nprotoc DO NOT EDIT.

package proto

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"math"
	"unsafe"
)

type BinaryWriter struct {
	writer *bytes.Buffer
	tmp    [32]byte
}

func NewBinaryWriter(writer *bytes.Buffer) *BinaryWriter {
	return &BinaryWriter{
		writer: writer,
	}
}

func (w *BinaryWriter) write(p []byte) error {
	_, err := w.writer.Write(p)
	return err
}

func (w *BinaryWriter) writeBool(b bool) {

	if b {
		w.tmp[0] = 1
	} else {
		w.tmp[0] = 0
	}

	w.write(w.tmp[0:1])
}

func (w *BinaryWriter) writeVarint(i int64) {
	n := binary.PutVarint(w.tmp[:], i)
	w.write(w.tmp[0:n])
}

func (w *BinaryWriter) writeUvarint(i uint64) error {
	n := binary.PutUvarint(w.tmp[:], i)
	w.write(w.tmp[0:n])
	return nil
}

func (w *BinaryWriter) writeByte(b byte) error {
	return w.writer.WriteByte(b)
}

func (w *BinaryWriter) writeFieldHeader(shape shape, id fieldId) error {
	return w.writeByte(fieldHeader{
		shape:   shape,
		fieldId: id,
	}.asValue())
}

func (w *BinaryWriter) writeTypeHeader(shape shape, id typeId) error {
	if err := w.writeFieldHeader(shape, 0); err != nil {
		return err
	}

	return w.writeUvarint(uint64(id))
}

func (w *BinaryWriter) writeSlice(s []byte) error {
	n := len(s)
	if err := w.writeUvarint(uint64(n)); err != nil {
		return err
	}
	return w.write(s)
}

func (w *BinaryWriter) writeFloat64(v float64) error {
	binary.LittleEndian.PutUint64(w.tmp[:8], math.Float64bits(v))
	return w.write(w.tmp[:8])
}

type BinaryReader struct {
	reader *bytes.Buffer
	tmp    [32]byte
}

func NewBinaryReader(reader *bytes.Buffer) *BinaryReader {
	return &BinaryReader{
		reader: reader,
	}
}

func (r *BinaryReader) read(b []byte) error {
	n, err := r.reader.Read(b)
	if err != nil {
		return err
	}

	if n != len(b) {
		return fmt.Errorf("short read")
	}

	return nil
}

func (r *BinaryReader) readByte() (byte, error) {
	return r.reader.ReadByte()
}

func (r *BinaryReader) readFieldHeader() (fieldHeader, error) {
	b, err := r.reader.ReadByte()
	if err != nil {
		return fieldHeader{}, err
	}

	return parseFieldHeader(b), nil
}

func (r *BinaryReader) readTypeHeader() (shape, typeId, error) {
	h, err := r.readFieldHeader()
	if err != nil {
		return 0, 0, fmt.Errorf("failed to read type header: %w", err)
	}

	if h.isField() {
		return 0, 0, fmt.Errorf("nprotoc: expected a type header but got a field header")
	}

	tid, err := r.readUvarint()
	if err != nil {
		return 0, 0, fmt.Errorf("failed to read type id header: %w", err)
	}

	return h.shape, typeId(tid), nil
}

func (r *BinaryReader) readUvarint() (uint64, error) {
	return binary.ReadUvarint(r.reader)
}

func (r *BinaryReader) readFloat64() (float64, error) {
	if err := r.read(r.tmp[:8]); err != nil {
		return 0.0, err
	}

	value := binary.LittleEndian.Uint64(r.tmp[:8])

	return math.Float64frombits(value), nil
}

type shape uint8

func (s shape) String() string {
	switch s {
	case f32:
		return "f32"
	case f64:
		return "f64"
	case envelope:
		return "envelope"
	case uvarint:
		return "uvarint"
	case varint:
		return "varint"
	case byteSlice:
		return "byteSlice"
	case record:
		return "record"
	case array:
		return "array"
	case xobjectAsArray:
		return "xobjectAsArray"
	case xbool:
		return "xbool"
	case xmap:
		return "xmap"
	}

	panic(fmt.Sprintf("unknown shape: %d", s))
}

const (
	envelope = shape(iota)
	uvarint
	varint
	byteSlice
	record
	f32
	f64
	array
	xobjectAsArray
	xbool
	xmap
)

type fieldId uint

type fieldHeader struct {
	shape   shape
	fieldId fieldId
}

func (f fieldHeader) isField() bool {
	return f.fieldId != 0
}

func (f fieldHeader) asValue() uint8 {
	return uint8(((int(f.shape)) << 5) | ((int(f.fieldId)) & 0b00011111))
}

func parseFieldHeader(value uint8) fieldHeader {
	return fieldHeader{
		shape:   shape((value >> 5) & 0b00000111),
		fieldId: fieldId(value & 0b00011111),
	}
}

type typeId uint

type typeHeader struct {
	shape   shape
	fieldId fieldId
	typeId  typeId
}

func (f typeHeader) isType() bool {
	return f.fieldId == 0
}

func parseTypeHeader(value uint8) fieldHeader {
	return fieldHeader{
		shape:   shape((value >> 5) & 0b00000111),
		fieldId: fieldId(value & 0b00011111),
	}
}

// Component is the building primitive for any widget, behavior or ui element in NAGO.
type Component interface {
	// a marker method to indicate the enum / union type membership
	isComponent()
	IsZero() bool
	reset()
	Writeable
	Readable
}

func (Box) isComponent()           {}
func (DatePicker) isComponent()    {}
func (Checkbox) isComponent()      {}
func (Divider) isComponent()       {}
func (Grid) isComponent()          {}
func (HStack) isComponent()        {}
func (Img) isComponent()           {}
func (Modal) isComponent()         {}
func (WindowTitle) isComponent()   {}
func (PasswordField) isComponent() {}
func (Radiobutton) isComponent()   {}
func (ScrollView) isComponent()    {}
func (Scaffold) isComponent()      {}
func (Spacer) isComponent()        {}
func (TextView) isComponent()      {}
func (TextField) isComponent()     {}
func (TextLayout) isComponent()    {}
func (Table) isComponent()         {}
func (Toggle) isComponent()        {}
func (VStack) isComponent()        {}
func (WebView) isComponent()       {}
func (Menu) isComponent()          {}
func (Form) isComponent()          {}
func (CountDown) isComponent()     {}
func (CodeEditor) isComponent()    {}

// NagoEvent is the union type of all allowed NAGO protocol events. Everything which goes through a NAGO channel must be an Event at the root level.
type NagoEvent interface {
	// a marker method to indicate the enum / union type membership
	isNagoEvent()
	IsZero() bool
	reset()
	Writeable
	Readable
}

func (UpdateStateValueRequested) isNagoEvent()         {}
func (UpdateStateValues2Requested) isNagoEvent()       {}
func (FunctionCallRequested) isNagoEvent()             {}
func (RootViewAllocationRequested) isNagoEvent()       {}
func (RootViewDestructionRequested) isNagoEvent()      {}
func (RootViewInvalidated) isNagoEvent()               {}
func (RootViewRenderingRequested) isNagoEvent()        {}
func (ErrorOccurred) isNagoEvent()                     {}
func (ErrorRootViewAllocationRequired) isNagoEvent()   {}
func (FileImportRequested) isNagoEvent()               {}
func (NavigationBackRequested) isNagoEvent()           {}
func (NavigationForwardToRequested) isNagoEvent()      {}
func (NavigationReloadRequested) isNagoEvent()         {}
func (NavigationResetRequested) isNagoEvent()          {}
func (ScopeConfigurationChangeRequested) isNagoEvent() {}
func (ScopeDestructionRequested) isNagoEvent()         {}
func (SessionAssigned) isNagoEvent()                   {}
func (Ping) isNagoEvent()                              {}
func (WindowInfoChanged) isNagoEvent()                 {}
func (ScopeConfigurationChanged) isNagoEvent()         {}
func (ThemeRequested) isNagoEvent()                    {}
func (SendMultipleRequested) isNagoEvent()             {}
func (OpenHttpFlow) isNagoEvent()                      {}
func (OpenHttpLink) isNagoEvent()                      {}
func (ClipboardWriteTextRequested) isNagoEvent()       {}

// A Box aligns children elements in absolute within its bounds.
//   - there is no intrinsic component dimension, so you have to set it by hand
//   - z-order is defined as defined children order, thus later children are put on top of others
//   - it is undefined behavior, to define multiple children with the same alignment. So this must not be rendered.
type Box struct {
	Children        AlignedComponents
	Frame           Frame
	BackgroundColor Color
	Padding         Padding
	Border          Border
}

func (v *Box) write(w *BinaryWriter) error {
	var fields [6]bool
	fields[1] = !v.Children.IsZero()
	fields[2] = !v.Frame.IsZero()
	fields[3] = !v.BackgroundColor.IsZero()
	fields[4] = !v.Padding.IsZero()
	fields[5] = !v.Border.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(array, 1); err != nil {
			return err
		}
		if err := v.Children.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(record, 2); err != nil {
			return err
		}
		if err := v.Frame.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(byteSlice, 3); err != nil {
			return err
		}
		if err := v.BackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(record, 4); err != nil {
			return err
		}
		if err := v.Padding.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(record, 5); err != nil {
			return err
		}
		if err := v.Border.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Box) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Children.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Frame.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.BackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Padding.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.Border.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// Ptr represents an allocated instance within the backend which is unique in the associated scope.
type Ptr uint64

const (
	// Null represents the zero value and a nil or null pointer address.
	Null Ptr = 0
)

func (v *Ptr) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *Ptr) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = Ptr(tmp)
	return nil
}

func (v *Ptr) reset() {
	*v = Ptr(0)
}
func (v *Ptr) IsZero() bool {
	return *v == 0
}

// UpdateStateValueRequested is raised from the frontend to update a state value hold by the backend. It can also immediately invoke a function callback in the same cycle.
type UpdateStateValueRequested struct {
	// The StatePointer must not be zero.
	StatePointer Ptr
	// A FunctionPointer is invoked, if not zero.
	FunctionPointer Ptr
	RID             RID
	Value           Str
}

func (v *UpdateStateValueRequested) write(w *BinaryWriter) error {
	var fields [5]bool
	fields[1] = !v.StatePointer.IsZero()
	fields[2] = !v.FunctionPointer.IsZero()
	fields[3] = !v.RID.IsZero()
	fields[4] = !v.Value.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(uvarint, 1); err != nil {
			return err
		}
		if err := v.StatePointer.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(uvarint, 2); err != nil {
			return err
		}
		if err := v.FunctionPointer.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(uvarint, 3); err != nil {
			return err
		}
		if err := v.RID.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(byteSlice, 4); err != nil {
			return err
		}
		if err := v.Value.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *UpdateStateValueRequested) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.StatePointer.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.FunctionPointer.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.RID.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Value.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// FunctionCallRequested tells the backend that the given pointer in the associated scope shall be invoked for a side effect.
type FunctionCallRequested struct {
	// Ptr denotes the remote pointer of the function.
	Ptr Ptr
	// RID is used to trace a request-response cycle.
	RID RID
}

func (v *FunctionCallRequested) write(w *BinaryWriter) error {
	var fields [3]bool
	fields[1] = !v.Ptr.IsZero()
	fields[2] = !v.RID.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(uvarint, 1); err != nil {
			return err
		}
		if err := v.Ptr.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(uvarint, 2); err != nil {
			return err
		}
		if err := v.RID.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *FunctionCallRequested) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Ptr.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.RID.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// Alignment is specified as follows:
//
//	┌─TopLeading───────────Top─────────TopTrailing─┐
//	│                                              │
//	│                                              │
//	│                                              │
//	│                                              │
//	│                                              │
//	│                                              │
//	│                                              │
//	│ Leading            Center            Trailing│
//	│                                              │
//	│                                              │
//	│                                              │
//	│                                              │
//	│                                              │
//	│                                              │
//	│                                              │
//	└BottomLeading───────Bottom──────BottomTrailing┘
//
// An empty Alignment must be interpreted as Center (="c").
type Alignment uint64

const (
	Center         Alignment = 0
	Top            Alignment = 1
	Bottom         Alignment = 2
	Leading        Alignment = 3
	Trailing       Alignment = 4
	TopLeading     Alignment = 5
	TopTrailing    Alignment = 6
	BottomLeading  Alignment = 7
	BottomTrailing Alignment = 8
	Stretch        Alignment = 9
)

func (v *Alignment) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *Alignment) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = Alignment(tmp)
	return nil
}

func (v *Alignment) reset() {
	*v = Alignment(0)
}
func (v *Alignment) IsZero() bool {
	return *v == 0
}

// Shadow defines a shadow effect around the border of an element. The x and y coordinates are relative to the element.
type Shadow struct {
	// Color of the shadow.
	Color Color
	// Radius for spread and blur length of the shadow.
	Radius Length
	// X is the horizontal offset of the shadow relative to the element.
	X Length
	// Y is the vertical offset of the shadow relative to the element.
	Y Length
}

func (v *Shadow) write(w *BinaryWriter) error {
	var fields [5]bool
	fields[1] = !v.Color.IsZero()
	fields[2] = !v.Radius.IsZero()
	fields[3] = !v.X.IsZero()
	fields[4] = !v.Y.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.Color.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(byteSlice, 2); err != nil {
			return err
		}
		if err := v.Radius.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(byteSlice, 3); err != nil {
			return err
		}
		if err := v.X.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(byteSlice, 4); err != nil {
			return err
		}
		if err := v.Y.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Shadow) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Color.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Radius.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.X.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Y.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// Border adds the defined border and dimension to the component. Note, that a border will change the dimension.
type Border struct {
	TopLeftRadius     Length
	TopRightRadius    Length
	BottomLeftRadius  Length
	BottomRightRadius Length
	LeftWidth         Length
	TopWidth          Length
	RightWidth        Length
	BottomWidth       Length
	LeftColor         Color
	TopColor          Color
	RightColor        Color
	BottomColor       Color
	BoxShadow         Shadow
}

func (v *Border) write(w *BinaryWriter) error {
	var fields [14]bool
	fields[1] = !v.TopLeftRadius.IsZero()
	fields[2] = !v.TopRightRadius.IsZero()
	fields[3] = !v.BottomLeftRadius.IsZero()
	fields[4] = !v.BottomRightRadius.IsZero()
	fields[5] = !v.LeftWidth.IsZero()
	fields[6] = !v.TopWidth.IsZero()
	fields[7] = !v.RightWidth.IsZero()
	fields[8] = !v.BottomWidth.IsZero()
	fields[9] = !v.LeftColor.IsZero()
	fields[10] = !v.TopColor.IsZero()
	fields[11] = !v.RightColor.IsZero()
	fields[12] = !v.BottomColor.IsZero()
	fields[13] = !v.BoxShadow.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.TopLeftRadius.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(byteSlice, 2); err != nil {
			return err
		}
		if err := v.TopRightRadius.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(byteSlice, 3); err != nil {
			return err
		}
		if err := v.BottomLeftRadius.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(byteSlice, 4); err != nil {
			return err
		}
		if err := v.BottomRightRadius.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(byteSlice, 5); err != nil {
			return err
		}
		if err := v.LeftWidth.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(byteSlice, 6); err != nil {
			return err
		}
		if err := v.TopWidth.write(w); err != nil {
			return err
		}
	}
	if fields[7] {
		if err := w.writeFieldHeader(byteSlice, 7); err != nil {
			return err
		}
		if err := v.RightWidth.write(w); err != nil {
			return err
		}
	}
	if fields[8] {
		if err := w.writeFieldHeader(byteSlice, 8); err != nil {
			return err
		}
		if err := v.BottomWidth.write(w); err != nil {
			return err
		}
	}
	if fields[9] {
		if err := w.writeFieldHeader(byteSlice, 9); err != nil {
			return err
		}
		if err := v.LeftColor.write(w); err != nil {
			return err
		}
	}
	if fields[10] {
		if err := w.writeFieldHeader(byteSlice, 10); err != nil {
			return err
		}
		if err := v.TopColor.write(w); err != nil {
			return err
		}
	}
	if fields[11] {
		if err := w.writeFieldHeader(byteSlice, 11); err != nil {
			return err
		}
		if err := v.RightColor.write(w); err != nil {
			return err
		}
	}
	if fields[12] {
		if err := w.writeFieldHeader(byteSlice, 12); err != nil {
			return err
		}
		if err := v.BottomColor.write(w); err != nil {
			return err
		}
	}
	if fields[13] {
		if err := w.writeFieldHeader(record, 13); err != nil {
			return err
		}
		if err := v.BoxShadow.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Border) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.TopLeftRadius.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.TopRightRadius.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.BottomLeftRadius.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.BottomRightRadius.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.LeftWidth.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.TopWidth.read(r)
			if err != nil {
				return err
			}
		case 7:
			err := v.RightWidth.read(r)
			if err != nil {
				return err
			}
		case 8:
			err := v.BottomWidth.read(r)
			if err != nil {
				return err
			}
		case 9:
			err := v.LeftColor.read(r)
			if err != nil {
				return err
			}
		case 10:
			err := v.TopColor.read(r)
			if err != nil {
				return err
			}
		case 11:
			err := v.RightColor.read(r)
			if err != nil {
				return err
			}
		case 12:
			err := v.BottomColor.read(r)
			if err != nil {
				return err
			}
		case 13:
			err := v.BoxShadow.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// Frame defines the geometrics bounds of an element.
type Frame struct {
	MinWidth  Length
	MaxWidth  Length
	MinHeight Length
	MaxHeight Length
	Width     Length
	Height    Length
}

func (v *Frame) write(w *BinaryWriter) error {
	var fields [7]bool
	fields[1] = !v.MinWidth.IsZero()
	fields[2] = !v.MaxWidth.IsZero()
	fields[3] = !v.MinHeight.IsZero()
	fields[4] = !v.MaxHeight.IsZero()
	fields[5] = !v.Width.IsZero()
	fields[6] = !v.Height.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.MinWidth.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(byteSlice, 2); err != nil {
			return err
		}
		if err := v.MaxWidth.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(byteSlice, 3); err != nil {
			return err
		}
		if err := v.MinHeight.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(byteSlice, 4); err != nil {
			return err
		}
		if err := v.MaxHeight.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(byteSlice, 5); err != nil {
			return err
		}
		if err := v.Width.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(byteSlice, 6); err != nil {
			return err
		}
		if err := v.Height.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Frame) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.MinWidth.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.MaxWidth.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.MinHeight.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.MaxHeight.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.Width.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.Height.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// Padding defines additional room within an element.
type Padding struct {
	Top    Length
	Left   Length
	Right  Length
	Bottom Length
}

func (v *Padding) write(w *BinaryWriter) error {
	var fields [5]bool
	fields[1] = !v.Top.IsZero()
	fields[2] = !v.Left.IsZero()
	fields[3] = !v.Right.IsZero()
	fields[4] = !v.Bottom.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.Top.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(byteSlice, 2); err != nil {
			return err
		}
		if err := v.Left.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(byteSlice, 3); err != nil {
			return err
		}
		if err := v.Right.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(byteSlice, 4); err != nil {
			return err
		}
		if err := v.Bottom.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Padding) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Top.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Left.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.Right.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Bottom.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// AlignedComponent defines a tupel of a component and an associated alignment.
type AlignedComponent struct {
	Component Component
	Alignment Alignment
}

func (v *AlignedComponent) write(w *BinaryWriter) error {
	var fields [3]bool
	fields[1] = v.Component != nil && !v.Component.IsZero()
	fields[2] = !v.Alignment.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		// polymorphic field (enum) type encodes as polymorphic array
		if err := w.writeFieldHeader(array, 1); err != nil {
			return err
		}
		if err := w.writeUvarint(1); err != nil {
			return err
		}
		if err := v.Component.writeTypeHeader(w); err != nil {
			return err
		}
		if err := v.Component.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(uvarint, 2); err != nil {
			return err
		}
		if err := v.Alignment.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *AlignedComponent) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			// polymorphic field type (enum) decodes as polymorphic array
			count, err := r.readUvarint()
			if err != nil {
				return err
			}
			if count != 1 {
				return fmt.Errorf("expected exact 1 element in enum field")
			}
			obj, err := Unmarshal(r)
			if err != nil {
				return err
			}
			v.Component = obj.(Component)
		case 2:
			err := v.Alignment.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// Checkbox represents a user interface element which spans a visible area to click or tap from the user. Use it for controls, which do not cause an immediate effect. See also [Toggle].
type Checkbox struct {
	// InputValue is where updated value of the checked states are written.
	InputValue Ptr
	Value      Bool
	Disabled   Bool
	Invisible  Bool
	// Id represents an optional identifier to locate this component within the view tree. It must be either empty or unique within the entire tree instance.
	Id Str
}

func (v *Checkbox) write(w *BinaryWriter) error {
	var fields [6]bool
	fields[1] = !v.InputValue.IsZero()
	fields[2] = !v.Value.IsZero()
	fields[3] = !v.Disabled.IsZero()
	fields[4] = !v.Invisible.IsZero()
	fields[5] = !v.Id.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(uvarint, 1); err != nil {
			return err
		}
		if err := v.InputValue.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(uvarint, 2); err != nil {
			return err
		}
		if err := v.Value.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(uvarint, 3); err != nil {
			return err
		}
		if err := v.Disabled.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(uvarint, 4); err != nil {
			return err
		}
		if err := v.Invisible.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(byteSlice, 5); err != nil {
			return err
		}
		if err := v.Id.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Checkbox) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.InputValue.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Value.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.Disabled.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Invisible.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.Id.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// ErrorOccurred is used, if some unforeseen error occurred. Usually the frontend did something wrong, e.g. in a life-cycle.
type ErrorOccurred struct {
	// Message of some generic error.
	Message Str
	// RID is used to trace a request-response cycle.
	RID RID
}

func (v *ErrorOccurred) write(w *BinaryWriter) error {
	var fields [3]bool
	fields[1] = !v.Message.IsZero()
	fields[2] = !v.RID.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.Message.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(uvarint, 2); err != nil {
			return err
		}
		if err := v.RID.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *ErrorOccurred) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Message.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.RID.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// RID represents a request id and may be used by the frontend to distinguish different generations of answers.
type FontStyle uint64

const (
	// A 0 represents something which was issued without any user interaction, which means by own-initiative.
	Unsolicited FontStyle = 0
	Normal      FontStyle = 1
	Italic      FontStyle = 2
)

func (v *FontStyle) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *FontStyle) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = FontStyle(tmp)
	return nil
}

func (v *FontStyle) reset() {
	*v = FontStyle(0)
}
func (v *FontStyle) IsZero() bool {
	return *v == 0
}

// RootViewRenderingRequested is issued by the frontend to force a rendering at the backend.
type RootViewRenderingRequested struct {
	RID RID
}

func (v *RootViewRenderingRequested) write(w *BinaryWriter) error {
	var fields [2]bool
	fields[1] = !v.RID.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(uvarint, 1); err != nil {
			return err
		}
		if err := v.RID.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *RootViewRenderingRequested) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.RID.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// The RootViewDestructionRequested event destroys the currently allocated root view. If nothing is allocated, this is a no-op.
type RootViewDestructionRequested struct {
	// RID is used to generate a new component request and is returned in the according response.
	RID RID
}

func (v *RootViewDestructionRequested) write(w *BinaryWriter) error {
	var fields [2]bool
	fields[1] = !v.RID.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(uvarint, 1); err != nil {
			return err
		}
		if err := v.RID.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *RootViewDestructionRequested) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.RID.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// The RootViewInvalidated event is always generated at the backend side, if a new representation of an allocated root view shall be shown.
type RootViewInvalidated struct {
	// RID may be 0, if it is an proactive rendering.
	RID RID
	// The Root component to display.
	Root Component
}

func (v *RootViewInvalidated) write(w *BinaryWriter) error {
	var fields [3]bool
	fields[1] = !v.RID.IsZero()
	fields[2] = v.Root != nil && !v.Root.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(uvarint, 1); err != nil {
			return err
		}
		if err := v.RID.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		// polymorphic field (enum) type encodes as polymorphic array
		if err := w.writeFieldHeader(array, 2); err != nil {
			return err
		}
		if err := w.writeUvarint(1); err != nil {
			return err
		}
		if err := v.Root.writeTypeHeader(w); err != nil {
			return err
		}
		if err := v.Root.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *RootViewInvalidated) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.RID.read(r)
			if err != nil {
				return err
			}
		case 2:
			// polymorphic field type (enum) decodes as polymorphic array
			count, err := r.readUvarint()
			if err != nil {
				return err
			}
			if count != 1 {
				return fmt.Errorf("expected exact 1 element in enum field")
			}
			obj, err := Unmarshal(r)
			if err != nil {
				return err
			}
			v.Root = obj.(Component)
		}
	}
	return nil
}

// ErrorRootViewAllocationRequired indicates, that there is no root view and it must be allocated to continue. This may happen, e.g. if the server was restarted or redeployed or a timeout occurred and the scope or root view was collected.
type ErrorRootViewAllocationRequired struct {
	// RID is used to trace a request-response cycle.
	RID RID
}

func (v *ErrorRootViewAllocationRequired) write(w *BinaryWriter) error {
	var fields [2]bool
	fields[1] = !v.RID.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(uvarint, 1); err != nil {
			return err
		}
		if err := v.RID.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *ErrorRootViewAllocationRequired) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.RID.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// NewComponentRequested allocates an addressable component explicitely in the backend within its channel scope.
// Adressable components are like pages in a classic server side rendering or like routing targets in single page apps.
// We do not call them _page_ anymore, because that has wrong assocations in the web world.
// Adressable components exist independently from each other and share no lifecycle with each other.
// However, a frontend can create as many component instances it wants.
// It does not matter, if these components are of the same type, addresses or entirely different.
// The backend responds with a component invalidation event.
// Factories of addressable components are always stateless.
// However, often it does not make sense without additional parameters, e.g. because a detail view needs to know which entity has to be displayed.
type RootViewAllocationRequested struct {
	// Locale of the frontend which is assumed as the users language. This may be the webbrowser primary locale which may be derived from the operating system.
	Locale Locale
	// Factory denotes the registered root view identifier.
	Factory RootViewID
	// RID is used to generate a new component request and is returned in the according response.
	RID RID
	// Values contains string encoded parameters for a component. This is like query parameters in the web world.
	Values RootViewParameters
}

func (v *RootViewAllocationRequested) write(w *BinaryWriter) error {
	var fields [5]bool
	fields[1] = !v.Locale.IsZero()
	fields[2] = !v.Factory.IsZero()
	fields[3] = !v.RID.IsZero()
	fields[4] = !v.Values.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.Locale.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(byteSlice, 2); err != nil {
			return err
		}
		if err := v.Factory.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(uvarint, 3); err != nil {
			return err
		}
		if err := v.RID.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(array, 4); err != nil {
			return err
		}
		if err := v.Values.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *RootViewAllocationRequested) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Locale.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Factory.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.RID.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Values.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// ColorScheme represents which kind of theme shall be rendered.WindowSizeClass represents media break points of the screen which an ora application is shown.
// The definition of a size class is disjunct and for all possible sizes, exact one size class will match.
// See also https://developer.android.com/develop/ui/views/layout/window-size-classes and
// https://tailwindcss.com/docs/responsive-design.
type WindowSizeClass uint64

const (
	// SizeClassSmall are devices below 640 dp screen width.
	SizeClassSmall WindowSizeClass = 0
	// SizeClassMedium are devices below 768dp screen width.
	SizeClassMedium WindowSizeClass = 1
	// SizeClassLarge are devices below 1024dp screen width.
	SizeClassLarge WindowSizeClass = 2
	// SizeClassXL are devices below 1280dp screen width.
	SizeClassXL WindowSizeClass = 3
	// SizeClass2XL are devices below 1536dp screen width.
	SizeClass2XL WindowSizeClass = 4
)

func (v *WindowSizeClass) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *WindowSizeClass) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = WindowSizeClass(tmp)
	return nil
}

func (v *WindowSizeClass) reset() {
	*v = WindowSizeClass(0)
}
func (v *WindowSizeClass) IsZero() bool {
	return *v == 0
}

// A ScopeConfigurationRequested event can be issued at any time.ConfigurationRequested is issued by the frontend to get the applications general configuration.
// A backend developer has potentially defined a lot of configuration details about the application.
// For example, there may be a color theme, customized icons, image resources, an application name and the available set of navigations, launch intents or other meta information.
// It is expected, that this only happens once during initialization of the frontend process.
type ScopeConfigurationChangeRequested struct {
	// RID is used to generate a new component request and is returned in the according response.
	RID            RID
	AcceptLanguage Locale
	WindowInfo     WindowInfo
}

func (v *ScopeConfigurationChangeRequested) write(w *BinaryWriter) error {
	var fields [4]bool
	fields[1] = !v.RID.IsZero()
	fields[2] = !v.AcceptLanguage.IsZero()
	fields[3] = !v.WindowInfo.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(uvarint, 1); err != nil {
			return err
		}
		if err := v.RID.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(byteSlice, 2); err != nil {
			return err
		}
		if err := v.AcceptLanguage.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(record, 3); err != nil {
			return err
		}
		if err := v.WindowInfo.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *ScopeConfigurationChangeRequested) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.RID.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.AcceptLanguage.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.WindowInfo.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// ColorScheme represents which kind of theme shall be rendered.
type ColorScheme uint64

const (
	// Light represents the light theme color mode.
	Light ColorScheme = 0
	// Dark represents the dark theme color mode.
	Dark ColorScheme = 1
)

func (v *ColorScheme) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *ColorScheme) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = ColorScheme(tmp)
	return nil
}

func (v *ColorScheme) reset() {
	*v = ColorScheme(0)
}
func (v *ColorScheme) IsZero() bool {
	return *v == 0
}

// WindowInfo describes the area into which the frontend renders the ora view tree.
// A user can simply change the layout of the screen, e.g. by rotation the smartphone or
// changing the size of a browser window.
type WindowInfo struct {
	Width     DP
	Height    DP
	Density   Density
	SizeClass WindowSizeClass
	// ColorScheme which the frontend wants to pick. This may reduce graphical glitches, if the backend creates images or webview resources for the frontend.
	ColorScheme ColorScheme
}

func (v *WindowInfo) write(w *BinaryWriter) error {
	var fields [6]bool
	fields[1] = !v.Width.IsZero()
	fields[2] = !v.Height.IsZero()
	fields[3] = !v.Density.IsZero()
	fields[4] = !v.SizeClass.IsZero()
	fields[5] = !v.ColorScheme.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(f64, 1); err != nil {
			return err
		}
		if err := v.Width.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(f64, 2); err != nil {
			return err
		}
		if err := v.Height.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(f64, 3); err != nil {
			return err
		}
		if err := v.Density.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(uvarint, 4); err != nil {
			return err
		}
		if err := v.SizeClass.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(uvarint, 5); err != nil {
			return err
		}
		if err := v.ColorScheme.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *WindowInfo) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Width.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Height.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.Density.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.SizeClass.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.ColorScheme.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// A ConfigurationDefined event is the response to a [ScopeConfigurationChangeRequested] event.
// According to the locale request, string and svg resources can be localized by the backend.
// The returned locale is the actually picked locale from the requested locale query string.
type ScopeConfigurationChanged struct {
	ApplicationID      Str
	ApplicationName    Str
	ApplicationVersion Str
	AvailableLocales   Locales
	AppIcon            URI
	ActiveLocale       Locale
	Themes             Themes
	RID                RID
}

func (v *ScopeConfigurationChanged) write(w *BinaryWriter) error {
	var fields [9]bool
	fields[1] = !v.ApplicationID.IsZero()
	fields[2] = !v.ApplicationName.IsZero()
	fields[3] = !v.ApplicationVersion.IsZero()
	fields[4] = !v.AvailableLocales.IsZero()
	fields[5] = !v.AppIcon.IsZero()
	fields[6] = !v.ActiveLocale.IsZero()
	fields[7] = !v.Themes.IsZero()
	fields[8] = !v.RID.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.ApplicationID.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(byteSlice, 2); err != nil {
			return err
		}
		if err := v.ApplicationName.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(byteSlice, 3); err != nil {
			return err
		}
		if err := v.ApplicationVersion.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(array, 4); err != nil {
			return err
		}
		if err := v.AvailableLocales.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(byteSlice, 5); err != nil {
			return err
		}
		if err := v.AppIcon.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(byteSlice, 6); err != nil {
			return err
		}
		if err := v.ActiveLocale.write(w); err != nil {
			return err
		}
	}
	if fields[7] {
		if err := w.writeFieldHeader(record, 7); err != nil {
			return err
		}
		if err := v.Themes.write(w); err != nil {
			return err
		}
	}
	if fields[8] {
		if err := w.writeFieldHeader(uvarint, 8); err != nil {
			return err
		}
		if err := v.RID.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *ScopeConfigurationChanged) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.ApplicationID.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.ApplicationName.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.ApplicationVersion.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.AvailableLocales.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.AppIcon.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.ActiveLocale.read(r)
			if err != nil {
				return err
			}
		case 7:
			err := v.Themes.read(r)
			if err != nil {
				return err
			}
		case 8:
			err := v.RID.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// A Theme aggregates colors (for distinct) namespaces and lengths. Usually, this represents the light or dark mode.
type Theme struct {
	Colors  NamespacedColors
	Lengths NamedLengths
}

func (v *Theme) write(w *BinaryWriter) error {
	var fields [3]bool
	fields[1] = !v.Colors.IsZero()
	fields[2] = !v.Lengths.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(array, 1); err != nil {
			return err
		}
		if err := v.Colors.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(array, 2); err != nil {
			return err
		}
		if err := v.Lengths.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Theme) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Colors.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Lengths.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// Themes represents light or dark mode colors.
type Themes struct {
	Light Theme
	Dark  Theme
}

func (v *Themes) write(w *BinaryWriter) error {
	var fields [3]bool
	fields[1] = !v.Light.IsZero()
	fields[2] = !v.Dark.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(record, 1); err != nil {
			return err
		}
		if err := v.Light.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(record, 2); err != nil {
			return err
		}
		if err := v.Dark.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Themes) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Light.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Dark.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type DatePickerStyle uint64

const (
	DatePickerSingleDate DatePickerStyle = 0
	DatePickerDateRange  DatePickerStyle = 1
)

func (v *DatePickerStyle) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *DatePickerStyle) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = DatePickerStyle(tmp)
	return nil
}

func (v *DatePickerStyle) reset() {
	*v = DatePickerStyle(0)
}
func (v *DatePickerStyle) IsZero() bool {
	return *v == 0
}

// Day represents a day in month in the range 1-31.
type Day uint64

func (v *Day) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *Day) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = Day(tmp)
	return nil
}

func (v *Day) reset() {
	*v = Day(0)
}
func (v *Day) IsZero() bool {
	return *v == 0
}

// Date represents a location-free representation of a day/month/year tuple.
type DateData struct {
	Day   Day
	Month Month
	Year  Year
}

func (v *DateData) write(w *BinaryWriter) error {
	var fields [4]bool
	fields[1] = !v.Day.IsZero()
	fields[2] = !v.Month.IsZero()
	fields[3] = !v.Year.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(uvarint, 1); err != nil {
			return err
		}
		if err := v.Day.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(uvarint, 2); err != nil {
			return err
		}
		if err := v.Month.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(uvarint, 3); err != nil {
			return err
		}
		if err := v.Year.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *DateData) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Day.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Month.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.Year.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// Month represents a month in the range 1-12.
type Month uint64

func (v *Month) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *Month) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = Month(tmp)
	return nil
}

func (v *Month) reset() {
	*v = Month(0)
}
func (v *Month) IsZero() bool {
	return *v == 0
}

// Year represents a year in the gregorian calendar.
type Year uint64

func (v *Year) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *Year) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = Year(tmp)
	return nil
}

func (v *Year) reset() {
	*v = Year(0)
}
func (v *Year) IsZero() bool {
	return *v == 0
}

type DatePicker struct {
	Label          Str
	SupportingText Str
	// ErrorText is shown instead of SupportingText, even if they are (today) independent
	ErrorText Str
	// Style determines if the picker shall use the range or single mode. Default is single selection
	Style DatePickerStyle
	// Value is the initial single value or start value of the picker.
	Value DateData
	// InputValue is the picked single value or end value of the picker.
	InputValue Ptr
	// EndValue is the initial end value of the picker.
	EndValue DateData
	// EndInputValue is the picked end value of the picker.
	EndInputValue Ptr
	Frame         Frame
	Invisible     Bool
	Disabled      Bool
}

func (v *DatePicker) write(w *BinaryWriter) error {
	var fields [12]bool
	fields[1] = !v.Label.IsZero()
	fields[2] = !v.SupportingText.IsZero()
	fields[3] = !v.ErrorText.IsZero()
	fields[4] = !v.Style.IsZero()
	fields[5] = !v.Value.IsZero()
	fields[6] = !v.InputValue.IsZero()
	fields[7] = !v.EndValue.IsZero()
	fields[8] = !v.EndInputValue.IsZero()
	fields[9] = !v.Frame.IsZero()
	fields[10] = !v.Invisible.IsZero()
	fields[11] = !v.Disabled.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.Label.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(byteSlice, 2); err != nil {
			return err
		}
		if err := v.SupportingText.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(byteSlice, 3); err != nil {
			return err
		}
		if err := v.ErrorText.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(uvarint, 4); err != nil {
			return err
		}
		if err := v.Style.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(record, 5); err != nil {
			return err
		}
		if err := v.Value.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(uvarint, 6); err != nil {
			return err
		}
		if err := v.InputValue.write(w); err != nil {
			return err
		}
	}
	if fields[7] {
		if err := w.writeFieldHeader(record, 7); err != nil {
			return err
		}
		if err := v.EndValue.write(w); err != nil {
			return err
		}
	}
	if fields[8] {
		if err := w.writeFieldHeader(uvarint, 8); err != nil {
			return err
		}
		if err := v.EndInputValue.write(w); err != nil {
			return err
		}
	}
	if fields[9] {
		if err := w.writeFieldHeader(record, 9); err != nil {
			return err
		}
		if err := v.Frame.write(w); err != nil {
			return err
		}
	}
	if fields[10] {
		if err := w.writeFieldHeader(uvarint, 10); err != nil {
			return err
		}
		if err := v.Invisible.write(w); err != nil {
			return err
		}
	}
	if fields[11] {
		if err := w.writeFieldHeader(uvarint, 11); err != nil {
			return err
		}
		if err := v.Disabled.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *DatePicker) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Label.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.SupportingText.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.ErrorText.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Style.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.Value.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.InputValue.read(r)
			if err != nil {
				return err
			}
		case 7:
			err := v.EndValue.read(r)
			if err != nil {
				return err
			}
		case 8:
			err := v.EndInputValue.read(r)
			if err != nil {
				return err
			}
		case 9:
			err := v.Frame.read(r)
			if err != nil {
				return err
			}
		case 10:
			err := v.Invisible.read(r)
			if err != nil {
				return err
			}
		case 11:
			err := v.Disabled.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type Divider struct {
	Frame   Frame
	Border  Border
	Padding Padding
}

func (v *Divider) write(w *BinaryWriter) error {
	var fields [4]bool
	fields[1] = !v.Frame.IsZero()
	fields[2] = !v.Border.IsZero()
	fields[3] = !v.Padding.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(record, 1); err != nil {
			return err
		}
		if err := v.Frame.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(record, 2); err != nil {
			return err
		}
		if err := v.Border.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(record, 3); err != nil {
			return err
		}
		if err := v.Padding.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Divider) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Frame.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Border.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.Padding.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type RID uint64

const (
	NormalFontStyle RID = 0
	ItalicFontStyle RID = 1
)

func (v *RID) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *RID) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = RID(tmp)
	return nil
}

func (v *RID) reset() {
	*v = RID(0)
}
func (v *RID) IsZero() bool {
	return *v == 0
}

type FontWeight uint64

const (
	NormalFontWeight FontWeight = 400
	BoldFontWeight   FontWeight = 700
)

func (v *FontWeight) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *FontWeight) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = FontWeight(tmp)
	return nil
}

func (v *FontWeight) reset() {
	*v = FontWeight(0)
}
func (v *FontWeight) IsZero() bool {
	return *v == 0
}

type Font struct {
	// Name of the font or family name as fallback. Extra fallback declarations are unspecified and must be comma separated.
	Name   Str
	Size   Length
	Style  FontStyle
	Weight FontWeight
}

func (v *Font) write(w *BinaryWriter) error {
	var fields [5]bool
	fields[1] = !v.Name.IsZero()
	fields[2] = !v.Size.IsZero()
	fields[3] = !v.Style.IsZero()
	fields[4] = !v.Weight.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.Name.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(byteSlice, 2); err != nil {
			return err
		}
		if err := v.Size.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(uvarint, 3); err != nil {
			return err
		}
		if err := v.Style.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(uvarint, 4); err != nil {
			return err
		}
		if err := v.Weight.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Font) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Name.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Size.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.Style.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Weight.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// A Grid must support up to 12 Columns and a reasonable "unlimited" amount of rows.
type Grid struct {
	Cells              GridCells
	Rows               Uint
	Columns            Uint
	RowGap             Length
	ColGap             Length
	Frame              Frame
	BackgroundColor    Color
	Padding            Padding
	Border             Border
	AccessibilityLabel Str
	Font               Font
	ColWidths          Lengths
	Invisible          Bool
}

func (v *Grid) write(w *BinaryWriter) error {
	var fields [14]bool
	fields[1] = !v.Cells.IsZero()
	fields[2] = !v.Rows.IsZero()
	fields[3] = !v.Columns.IsZero()
	fields[4] = !v.RowGap.IsZero()
	fields[5] = !v.ColGap.IsZero()
	fields[6] = !v.Frame.IsZero()
	fields[7] = !v.BackgroundColor.IsZero()
	fields[8] = !v.Padding.IsZero()
	fields[9] = !v.Border.IsZero()
	fields[10] = !v.AccessibilityLabel.IsZero()
	fields[11] = !v.Font.IsZero()
	fields[12] = !v.ColWidths.IsZero()
	fields[13] = !v.Invisible.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(array, 1); err != nil {
			return err
		}
		if err := v.Cells.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(uvarint, 2); err != nil {
			return err
		}
		if err := v.Rows.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(uvarint, 3); err != nil {
			return err
		}
		if err := v.Columns.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(byteSlice, 4); err != nil {
			return err
		}
		if err := v.RowGap.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(byteSlice, 5); err != nil {
			return err
		}
		if err := v.ColGap.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(record, 6); err != nil {
			return err
		}
		if err := v.Frame.write(w); err != nil {
			return err
		}
	}
	if fields[7] {
		if err := w.writeFieldHeader(byteSlice, 7); err != nil {
			return err
		}
		if err := v.BackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[8] {
		if err := w.writeFieldHeader(record, 8); err != nil {
			return err
		}
		if err := v.Padding.write(w); err != nil {
			return err
		}
	}
	if fields[9] {
		if err := w.writeFieldHeader(record, 9); err != nil {
			return err
		}
		if err := v.Border.write(w); err != nil {
			return err
		}
	}
	if fields[10] {
		if err := w.writeFieldHeader(byteSlice, 10); err != nil {
			return err
		}
		if err := v.AccessibilityLabel.write(w); err != nil {
			return err
		}
	}
	if fields[11] {
		if err := w.writeFieldHeader(record, 11); err != nil {
			return err
		}
		if err := v.Font.write(w); err != nil {
			return err
		}
	}
	if fields[12] {
		if err := w.writeFieldHeader(array, 12); err != nil {
			return err
		}
		if err := v.ColWidths.write(w); err != nil {
			return err
		}
	}
	if fields[13] {
		if err := w.writeFieldHeader(uvarint, 13); err != nil {
			return err
		}
		if err := v.Invisible.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Grid) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Cells.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Rows.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.Columns.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.RowGap.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.ColGap.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.Frame.read(r)
			if err != nil {
				return err
			}
		case 7:
			err := v.BackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 8:
			err := v.Padding.read(r)
			if err != nil {
				return err
			}
		case 9:
			err := v.Border.read(r)
			if err != nil {
				return err
			}
		case 10:
			err := v.AccessibilityLabel.read(r)
			if err != nil {
				return err
			}
		case 11:
			err := v.Font.read(r)
			if err != nil {
				return err
			}
		case 12:
			err := v.ColWidths.read(r)
			if err != nil {
				return err
			}
		case 13:
			err := v.Invisible.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// Uint represents just a user defined unsigned integer value. This is how nprotoc works.
type Uint uint64

func (v *Uint) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *Uint) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = Uint(tmp)
	return nil
}

func (v *Uint) reset() {
	*v = Uint(0)
}
func (v *Uint) IsZero() bool {
	return *v == 0
}

// GridCell is undefined, if explicit row start/col start etc. is set and span values.
type GridCell struct {
	Body      Component
	ColStart  Uint
	ColEnd    Uint
	RowStart  Uint
	RowEnd    Uint
	ColSpan   Uint
	RowSpan   Uint
	Padding   Padding
	Alignment Alignment
}

func (v *GridCell) write(w *BinaryWriter) error {
	var fields [10]bool
	fields[1] = v.Body != nil && !v.Body.IsZero()
	fields[2] = !v.ColStart.IsZero()
	fields[3] = !v.ColEnd.IsZero()
	fields[4] = !v.RowStart.IsZero()
	fields[5] = !v.RowEnd.IsZero()
	fields[6] = !v.ColSpan.IsZero()
	fields[7] = !v.RowSpan.IsZero()
	fields[8] = !v.Padding.IsZero()
	fields[9] = !v.Alignment.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		// polymorphic field (enum) type encodes as polymorphic array
		if err := w.writeFieldHeader(array, 1); err != nil {
			return err
		}
		if err := w.writeUvarint(1); err != nil {
			return err
		}
		if err := v.Body.writeTypeHeader(w); err != nil {
			return err
		}
		if err := v.Body.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(uvarint, 2); err != nil {
			return err
		}
		if err := v.ColStart.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(uvarint, 3); err != nil {
			return err
		}
		if err := v.ColEnd.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(uvarint, 4); err != nil {
			return err
		}
		if err := v.RowStart.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(uvarint, 5); err != nil {
			return err
		}
		if err := v.RowEnd.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(uvarint, 6); err != nil {
			return err
		}
		if err := v.ColSpan.write(w); err != nil {
			return err
		}
	}
	if fields[7] {
		if err := w.writeFieldHeader(uvarint, 7); err != nil {
			return err
		}
		if err := v.RowSpan.write(w); err != nil {
			return err
		}
	}
	if fields[8] {
		if err := w.writeFieldHeader(record, 8); err != nil {
			return err
		}
		if err := v.Padding.write(w); err != nil {
			return err
		}
	}
	if fields[9] {
		if err := w.writeFieldHeader(uvarint, 9); err != nil {
			return err
		}
		if err := v.Alignment.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *GridCell) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			// polymorphic field type (enum) decodes as polymorphic array
			count, err := r.readUvarint()
			if err != nil {
				return err
			}
			if count != 1 {
				return fmt.Errorf("expected exact 1 element in enum field")
			}
			obj, err := Unmarshal(r)
			if err != nil {
				return err
			}
			v.Body = obj.(Component)
		case 2:
			err := v.ColStart.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.ColEnd.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.RowStart.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.RowEnd.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.ColSpan.read(r)
			if err != nil {
				return err
			}
		case 7:
			err := v.RowSpan.read(r)
			if err != nil {
				return err
			}
		case 8:
			err := v.Padding.read(r)
			if err != nil {
				return err
			}
		case 9:
			err := v.Alignment.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// An HStack aligns children elements in a horizontal row.
//   - the intrinsic component dimensions are the sum of all sizes of the contained children
//   - the parent can define a custom width and height
//   - if the container is larger than the contained views, it must center vertical or horizontal
//   - the inner gap between components should be around 2dp (this decides the backend)
type HStack struct {
	Children Components
	Gap      Length
	Frame    Frame
	// Zero value of Alignment is Center (=c) must be applied.
	Alignment       Alignment
	BackgroundColor Color
	Padding         Padding
	// see also https://www.w3.org/WAI/tutorials/images/decision-tree/
	AccessibilityLabel     Str
	Border                 Border
	Font                   Font
	Action                 Ptr
	HoveredBackgroundColor Color
	PressedBackgroundColor Color
	FocusedBackgroundColor Color
	HoveredBorder          Border
	PressedBorder          Border
	FocusedBorder          Border
	Wrap                   Bool
	StylePreset            StylePreset
	Position               Position
	Disabled               Bool
	Invisible              Bool
	// Id represents an optional identifier to locate this component within the view tree. It must be either empty or unique within the entire tree instance.
	Id Str
}

func (v *HStack) write(w *BinaryWriter) error {
	var fields [23]bool
	fields[1] = !v.Children.IsZero()
	fields[2] = !v.Gap.IsZero()
	fields[3] = !v.Frame.IsZero()
	fields[4] = !v.Alignment.IsZero()
	fields[5] = !v.BackgroundColor.IsZero()
	fields[6] = !v.Padding.IsZero()
	fields[7] = !v.AccessibilityLabel.IsZero()
	fields[8] = !v.Border.IsZero()
	fields[9] = !v.Font.IsZero()
	fields[10] = !v.Action.IsZero()
	fields[11] = !v.HoveredBackgroundColor.IsZero()
	fields[12] = !v.PressedBackgroundColor.IsZero()
	fields[13] = !v.FocusedBackgroundColor.IsZero()
	fields[14] = !v.HoveredBorder.IsZero()
	fields[15] = !v.PressedBorder.IsZero()
	fields[16] = !v.FocusedBorder.IsZero()
	fields[17] = !v.Wrap.IsZero()
	fields[18] = !v.StylePreset.IsZero()
	fields[19] = !v.Position.IsZero()
	fields[20] = !v.Disabled.IsZero()
	fields[21] = !v.Invisible.IsZero()
	fields[22] = !v.Id.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(array, 1); err != nil {
			return err
		}
		if err := v.Children.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(byteSlice, 2); err != nil {
			return err
		}
		if err := v.Gap.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(record, 3); err != nil {
			return err
		}
		if err := v.Frame.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(uvarint, 4); err != nil {
			return err
		}
		if err := v.Alignment.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(byteSlice, 5); err != nil {
			return err
		}
		if err := v.BackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(record, 6); err != nil {
			return err
		}
		if err := v.Padding.write(w); err != nil {
			return err
		}
	}
	if fields[7] {
		if err := w.writeFieldHeader(byteSlice, 7); err != nil {
			return err
		}
		if err := v.AccessibilityLabel.write(w); err != nil {
			return err
		}
	}
	if fields[8] {
		if err := w.writeFieldHeader(record, 8); err != nil {
			return err
		}
		if err := v.Border.write(w); err != nil {
			return err
		}
	}
	if fields[9] {
		if err := w.writeFieldHeader(record, 9); err != nil {
			return err
		}
		if err := v.Font.write(w); err != nil {
			return err
		}
	}
	if fields[10] {
		if err := w.writeFieldHeader(uvarint, 10); err != nil {
			return err
		}
		if err := v.Action.write(w); err != nil {
			return err
		}
	}
	if fields[11] {
		if err := w.writeFieldHeader(byteSlice, 11); err != nil {
			return err
		}
		if err := v.HoveredBackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[12] {
		if err := w.writeFieldHeader(byteSlice, 12); err != nil {
			return err
		}
		if err := v.PressedBackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[13] {
		if err := w.writeFieldHeader(byteSlice, 13); err != nil {
			return err
		}
		if err := v.FocusedBackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[14] {
		if err := w.writeFieldHeader(record, 14); err != nil {
			return err
		}
		if err := v.HoveredBorder.write(w); err != nil {
			return err
		}
	}
	if fields[15] {
		if err := w.writeFieldHeader(record, 15); err != nil {
			return err
		}
		if err := v.PressedBorder.write(w); err != nil {
			return err
		}
	}
	if fields[16] {
		if err := w.writeFieldHeader(record, 16); err != nil {
			return err
		}
		if err := v.FocusedBorder.write(w); err != nil {
			return err
		}
	}
	if fields[17] {
		if err := w.writeFieldHeader(uvarint, 17); err != nil {
			return err
		}
		if err := v.Wrap.write(w); err != nil {
			return err
		}
	}
	if fields[18] {
		if err := w.writeFieldHeader(uvarint, 18); err != nil {
			return err
		}
		if err := v.StylePreset.write(w); err != nil {
			return err
		}
	}
	if fields[19] {
		if err := w.writeFieldHeader(record, 19); err != nil {
			return err
		}
		if err := v.Position.write(w); err != nil {
			return err
		}
	}
	if fields[20] {
		if err := w.writeFieldHeader(uvarint, 20); err != nil {
			return err
		}
		if err := v.Disabled.write(w); err != nil {
			return err
		}
	}
	if fields[21] {
		if err := w.writeFieldHeader(uvarint, 21); err != nil {
			return err
		}
		if err := v.Invisible.write(w); err != nil {
			return err
		}
	}
	if fields[22] {
		if err := w.writeFieldHeader(byteSlice, 22); err != nil {
			return err
		}
		if err := v.Id.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *HStack) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Children.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Gap.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.Frame.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Alignment.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.BackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.Padding.read(r)
			if err != nil {
				return err
			}
		case 7:
			err := v.AccessibilityLabel.read(r)
			if err != nil {
				return err
			}
		case 8:
			err := v.Border.read(r)
			if err != nil {
				return err
			}
		case 9:
			err := v.Font.read(r)
			if err != nil {
				return err
			}
		case 10:
			err := v.Action.read(r)
			if err != nil {
				return err
			}
		case 11:
			err := v.HoveredBackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 12:
			err := v.PressedBackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 13:
			err := v.FocusedBackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 14:
			err := v.HoveredBorder.read(r)
			if err != nil {
				return err
			}
		case 15:
			err := v.PressedBorder.read(r)
			if err != nil {
				return err
			}
		case 16:
			err := v.FocusedBorder.read(r)
			if err != nil {
				return err
			}
		case 17:
			err := v.Wrap.read(r)
			if err != nil {
				return err
			}
		case 18:
			err := v.StylePreset.read(r)
			if err != nil {
				return err
			}
		case 19:
			err := v.Position.read(r)
			if err != nil {
				return err
			}
		case 20:
			err := v.Disabled.read(r)
			if err != nil {
				return err
			}
		case 21:
			err := v.Invisible.read(r)
			if err != nil {
				return err
			}
		case 22:
			err := v.Id.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// StylePreset allows to apply a build-in style to this component. This reduces over-the-wire boilerplate and
// also defines a stereotype, so that the applied component behavior may be indeed a bit different, because
// a native component may be used, e.g. for a native button. The order of appliance is first the preset and
// then customized properties on top.
type StylePreset uint64

const (
	// Default is that no style preset is applied.
	StyleNone            StylePreset = 0
	StyleButtonPrimary   StylePreset = 1
	StyleButtonSecondary StylePreset = 2
	StyleButtonTertiary  StylePreset = 3
)

func (v *StylePreset) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *StylePreset) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = StylePreset(tmp)
	return nil
}

func (v *StylePreset) reset() {
	*v = StylePreset(0)
}
func (v *StylePreset) IsZero() bool {
	return *v == 0
}

type Position struct {
	Kind   PositionType
	Left   Length
	Top    Length
	Right  Length
	Bottom Length
}

func (v *Position) write(w *BinaryWriter) error {
	var fields [6]bool
	fields[1] = !v.Kind.IsZero()
	fields[2] = !v.Left.IsZero()
	fields[3] = !v.Top.IsZero()
	fields[4] = !v.Right.IsZero()
	fields[5] = !v.Bottom.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(uvarint, 1); err != nil {
			return err
		}
		if err := v.Kind.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(byteSlice, 2); err != nil {
			return err
		}
		if err := v.Left.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(byteSlice, 3); err != nil {
			return err
		}
		if err := v.Top.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(byteSlice, 4); err != nil {
			return err
		}
		if err := v.Right.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(byteSlice, 5); err != nil {
			return err
		}
		if err := v.Bottom.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Position) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Kind.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Left.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.Top.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Right.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.Bottom.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type PositionType uint64

const (
	// PositionDefault is the default and any explicit position value have no effect.
	//  See also https://developer.mozilla.org/de/docs/Web/CSS/position#static.
	PositionDefault PositionType = 0
	// PositionOffset is like PositionDefault but moves the element by applying the given position values after
	//  layouting. See also https://developer.mozilla.org/de/docs/Web/CSS/position#relative.
	PositionOffset PositionType = 1
	// PositionAbsolute removes the element from the layout and places it using the given values in an absolute way
	//  within any of its parent layouted as PositionOffset. If no parent with PositionOffset is found, the viewport
	//  is used. See also https://developer.mozilla.org/de/docs/Web/CSS/position#absolute.
	PositionAbsolute PositionType = 2
	// PositionFixed removes the element from the layout and places it at a fixed position according to the viewport
	//  independent of the scroll position. See also https://developer.mozilla.org/de/docs/Web/CSS/position#absolute.
	PositionFixed PositionType = 3
	// PositionSticky is here for completion, and it is unclear which rules to follow on mobile clients.
	//  See also https://developer.mozilla.org/de/docs/Web/CSS/position#absolute.
	PositionSticky PositionType = 4
)

func (v *PositionType) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *PositionType) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = PositionType(tmp)
	return nil
}

func (v *PositionType) reset() {
	*v = PositionType(0)
}
func (v *PositionType) IsZero() bool {
	return *v == 0
}

type Img struct {
	Uri                URI
	AccessibilityLabel Str
	Border             Border
	Frame              Frame
	Padding            Padding
	SVG                SVG
	FillColor          Color
	StrokeColor        Color
	Invisible          Bool
}

func (v *Img) write(w *BinaryWriter) error {
	var fields [10]bool
	fields[1] = !v.Uri.IsZero()
	fields[2] = !v.AccessibilityLabel.IsZero()
	fields[3] = !v.Border.IsZero()
	fields[4] = !v.Frame.IsZero()
	fields[5] = !v.Padding.IsZero()
	fields[6] = !v.SVG.IsZero()
	fields[7] = !v.FillColor.IsZero()
	fields[8] = !v.StrokeColor.IsZero()
	fields[9] = !v.Invisible.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.Uri.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(byteSlice, 2); err != nil {
			return err
		}
		if err := v.AccessibilityLabel.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(record, 3); err != nil {
			return err
		}
		if err := v.Border.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(record, 4); err != nil {
			return err
		}
		if err := v.Frame.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(record, 5); err != nil {
			return err
		}
		if err := v.Padding.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(byteSlice, 6); err != nil {
			return err
		}
		if err := v.SVG.write(w); err != nil {
			return err
		}
	}
	if fields[7] {
		if err := w.writeFieldHeader(byteSlice, 7); err != nil {
			return err
		}
		if err := v.FillColor.write(w); err != nil {
			return err
		}
	}
	if fields[8] {
		if err := w.writeFieldHeader(byteSlice, 8); err != nil {
			return err
		}
		if err := v.StrokeColor.write(w); err != nil {
			return err
		}
	}
	if fields[9] {
		if err := w.writeFieldHeader(uvarint, 9); err != nil {
			return err
		}
		if err := v.Invisible.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Img) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Uri.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.AccessibilityLabel.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.Border.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Frame.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.Padding.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.SVG.read(r)
			if err != nil {
				return err
			}
		case 7:
			err := v.FillColor.read(r)
			if err != nil {
				return err
			}
		case 8:
			err := v.StrokeColor.read(r)
			if err != nil {
				return err
			}
		case 9:
			err := v.Invisible.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// FileImportRequested asks the frontend to let the user pick some files.
// Depending on the actual backend configuration, this may cause
// a regular http multipart upload or some FFI calls providing data streams
// or accessor URIs.
type FileImportRequested struct {
	ID               Str
	ScopeID          Str
	Multiple         Bool
	MaxBytes         Uint
	AllowedMimeTypes Strings
}

func (v *FileImportRequested) write(w *BinaryWriter) error {
	var fields [6]bool
	fields[1] = !v.ID.IsZero()
	fields[2] = !v.ScopeID.IsZero()
	fields[3] = !v.Multiple.IsZero()
	fields[4] = !v.MaxBytes.IsZero()
	fields[5] = !v.AllowedMimeTypes.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.ID.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(byteSlice, 2); err != nil {
			return err
		}
		if err := v.ScopeID.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(uvarint, 3); err != nil {
			return err
		}
		if err := v.Multiple.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(uvarint, 4); err != nil {
			return err
		}
		if err := v.MaxBytes.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(array, 5); err != nil {
			return err
		}
		if err := v.AllowedMimeTypes.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *FileImportRequested) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.ID.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.ScopeID.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.Multiple.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.MaxBytes.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.AllowedMimeTypes.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type KeyboardOptions struct {
	Capitalization     Bool
	AutoCorrectEnabled Bool
	KeyboardType       KeyboardType
}

func (v *KeyboardOptions) write(w *BinaryWriter) error {
	var fields [4]bool
	fields[1] = !v.Capitalization.IsZero()
	fields[2] = !v.AutoCorrectEnabled.IsZero()
	fields[3] = !v.KeyboardType.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(uvarint, 1); err != nil {
			return err
		}
		if err := v.Capitalization.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(uvarint, 2); err != nil {
			return err
		}
		if err := v.AutoCorrectEnabled.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(uvarint, 3); err != nil {
			return err
		}
		if err := v.KeyboardType.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *KeyboardOptions) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Capitalization.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.AutoCorrectEnabled.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.KeyboardType.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type KeyboardType uint64

const (
	KeyboardDefault KeyboardType = 0
	KeyboardAscii   KeyboardType = 1
	KeyboardInteger KeyboardType = 2
	KeyboardFloat   KeyboardType = 3
	KeyboardEMail   KeyboardType = 4
	KeyboardPhone   KeyboardType = 5
	KeyboardSearch  KeyboardType = 6
	KeyboardURL     KeyboardType = 7
)

func (v *KeyboardType) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *KeyboardType) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = KeyboardType(tmp)
	return nil
}

func (v *KeyboardType) reset() {
	*v = KeyboardType(0)
}
func (v *KeyboardType) IsZero() bool {
	return *v == 0
}

type ModalType uint64

const (
	ModalTypeDialog  ModalType = 0
	ModalTypeOverlay ModalType = 1
)

func (v *ModalType) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *ModalType) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = ModalType(tmp)
	return nil
}

func (v *ModalType) reset() {
	*v = ModalType(0)
}
func (v *ModalType) IsZero() bool {
	return *v == 0
}

// A Modal can be declared at any place in the composed view tree. However, these dialogs are teleported into
// the modal space in tree declaration order. A Modal is layouted above all other regular content and if ModalTypeDialog
// will catch focus and disable controls of the views behind. Its bounds are at most the maximum possible screen size.
type Modal struct {
	Content Component
	// OnDismissRequest is called, if the user wants to dismiss the dialog, e.g. by clicking outside or pressing escape. You can then decide to disable you dialog, or not.
	OnDismissRequest Ptr
	ModalType        ModalType
	Top              Length
	Left             Length
	Right            Length
	Bottom           Length
}

func (v *Modal) write(w *BinaryWriter) error {
	var fields [8]bool
	fields[1] = v.Content != nil && !v.Content.IsZero()
	fields[2] = !v.OnDismissRequest.IsZero()
	fields[3] = !v.ModalType.IsZero()
	fields[4] = !v.Top.IsZero()
	fields[5] = !v.Left.IsZero()
	fields[6] = !v.Right.IsZero()
	fields[7] = !v.Bottom.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		// polymorphic field (enum) type encodes as polymorphic array
		if err := w.writeFieldHeader(array, 1); err != nil {
			return err
		}
		if err := w.writeUvarint(1); err != nil {
			return err
		}
		if err := v.Content.writeTypeHeader(w); err != nil {
			return err
		}
		if err := v.Content.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(uvarint, 2); err != nil {
			return err
		}
		if err := v.OnDismissRequest.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(uvarint, 3); err != nil {
			return err
		}
		if err := v.ModalType.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(byteSlice, 4); err != nil {
			return err
		}
		if err := v.Top.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(byteSlice, 5); err != nil {
			return err
		}
		if err := v.Left.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(byteSlice, 6); err != nil {
			return err
		}
		if err := v.Right.write(w); err != nil {
			return err
		}
	}
	if fields[7] {
		if err := w.writeFieldHeader(byteSlice, 7); err != nil {
			return err
		}
		if err := v.Bottom.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Modal) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			// polymorphic field type (enum) decodes as polymorphic array
			count, err := r.readUvarint()
			if err != nil {
				return err
			}
			if count != 1 {
				return fmt.Errorf("expected exact 1 element in enum field")
			}
			obj, err := Unmarshal(r)
			if err != nil {
				return err
			}
			v.Content = obj.(Component)
		case 2:
			err := v.OnDismissRequest.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.ModalType.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Top.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.Left.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.Right.read(r)
			if err != nil {
				return err
			}
		case 7:
			err := v.Bottom.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// ThemeRequested is usually emitted by the backend, so that the frontend will switch (and remember) the required theme state.
type ThemeRequested struct {
	// Theme contains the name of the theme to apply. Usually light or dark, however we may want to provide more or go even arbitrary.
	Theme ThemeID
}

func (v *ThemeRequested) write(w *BinaryWriter) error {
	var fields [2]bool
	fields[1] = !v.Theme.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.Theme.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *ThemeRequested) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Theme.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// NavigationForwardToRequested is an Event triggered by the backend which requests a forward navigation action within the frontend.
// A frontend must put the new component to create by the factory on top of the current component within the scope.
// The frontend is free keep multiple components alive at the same time, however it must ensure that the UX is sane.
type NavigationForwardToRequested struct {
	RootView RootViewID
	Values   RootViewParameters
}

func (v *NavigationForwardToRequested) write(w *BinaryWriter) error {
	var fields [3]bool
	fields[1] = !v.RootView.IsZero()
	fields[2] = !v.Values.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.RootView.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(array, 2); err != nil {
			return err
		}
		if err := v.Values.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *NavigationForwardToRequested) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.RootView.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Values.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// NavigationResetRequested removes the entire history in the scope and pushes the target on top.
type NavigationResetRequested struct {
	RootView RootViewID
	Values   RootViewParameters
}

func (v *NavigationResetRequested) write(w *BinaryWriter) error {
	var fields [3]bool
	fields[1] = !v.RootView.IsZero()
	fields[2] = !v.Values.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.RootView.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(array, 2); err != nil {
			return err
		}
		if err := v.Values.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *NavigationResetRequested) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.RootView.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Values.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// NavigationBackRequested steps back causing a likely destruction of the most top component. The frontend may decide to ignore that, if the stack would be empty/undefined otherwise.
type NavigationBackRequested struct {
}

func (v *NavigationBackRequested) write(w *BinaryWriter) error {
	var fields [1]bool

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	return nil
}

func (v *NavigationBackRequested) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		}
	}
	return nil
}

type NavigationReloadRequested struct {
}

func (v *NavigationReloadRequested) write(w *BinaryWriter) error {
	var fields [1]bool

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	return nil
}

func (v *NavigationReloadRequested) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		}
	}
	return nil
}

// WindowTitle is an invisible component which teleports its Value into the current active window navigation title. The last evaluated title in the hierarchy wins.
type WindowTitle struct {
	Value Str
}

func (v *WindowTitle) write(w *BinaryWriter) error {
	var fields [2]bool
	fields[1] = !v.Value.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.Value.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *WindowTitle) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Value.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// Duration represents a duration in nanoseconds
type Duration uint64

func (v *Duration) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *Duration) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = Duration(tmp)
	return nil
}

func (v *Duration) reset() {
	*v = Duration(0)
}
func (v *Duration) IsZero() bool {
	return *v == 0
}

type PasswordField struct {
	Label          Str
	SupportingText Str
	// ErrorText is shown instead of SupportingText, even if they are (today) independent
	ErrorText Str
	// Value contains the text, which shall be shown.
	Value Str
	Frame Frame
	// InputValue is a binding to a state, into which the frontend will the user entered text. This is the pointer a State.
	InputValue Ptr
	// Style to apply. Use TextFieldReduced in forms where many textfields cause too much visual noise and you need to reduce it. By default, the TextFieldOutlined is applied.
	Style TextFieldStyle
	// DebounceTime is in nanoseconds. A zero or omitted value means to enable debounce default logic.
	DebounceTime Duration
	// Lines enforces a single line if <= 0, otherwise it shows the amount of text lines within a text area.
	Lines               Uint
	Disabled            Bool
	DisableAutocomplete Bool
	// DisableDebounce must be set to true, to disable the default debouncer logic. This will cause a render roundtrip for each keystroke, so be careful not to break the server or cause UX issues due to UI latencies.
	DisableDebounce Bool
	Invisible       Bool
	// If Revealed the password is shown
	Revealed Bool
	// Id represents an optional identifier to locate this component within the view tree. It must be either empty or unique within the entire tree instance.
	Id           Str
	KeydownEnter Ptr
}

func (v *PasswordField) write(w *BinaryWriter) error {
	var fields [17]bool
	fields[1] = !v.Label.IsZero()
	fields[2] = !v.SupportingText.IsZero()
	fields[3] = !v.ErrorText.IsZero()
	fields[4] = !v.Value.IsZero()
	fields[5] = !v.Frame.IsZero()
	fields[6] = !v.InputValue.IsZero()
	fields[7] = !v.Style.IsZero()
	fields[8] = !v.DebounceTime.IsZero()
	fields[9] = !v.Lines.IsZero()
	fields[10] = !v.Disabled.IsZero()
	fields[11] = !v.DisableAutocomplete.IsZero()
	fields[12] = !v.DisableDebounce.IsZero()
	fields[13] = !v.Invisible.IsZero()
	fields[14] = !v.Revealed.IsZero()
	fields[15] = !v.Id.IsZero()
	fields[16] = !v.KeydownEnter.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.Label.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(byteSlice, 2); err != nil {
			return err
		}
		if err := v.SupportingText.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(byteSlice, 3); err != nil {
			return err
		}
		if err := v.ErrorText.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(byteSlice, 4); err != nil {
			return err
		}
		if err := v.Value.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(record, 5); err != nil {
			return err
		}
		if err := v.Frame.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(uvarint, 6); err != nil {
			return err
		}
		if err := v.InputValue.write(w); err != nil {
			return err
		}
	}
	if fields[7] {
		if err := w.writeFieldHeader(uvarint, 7); err != nil {
			return err
		}
		if err := v.Style.write(w); err != nil {
			return err
		}
	}
	if fields[8] {
		if err := w.writeFieldHeader(uvarint, 8); err != nil {
			return err
		}
		if err := v.DebounceTime.write(w); err != nil {
			return err
		}
	}
	if fields[9] {
		if err := w.writeFieldHeader(uvarint, 9); err != nil {
			return err
		}
		if err := v.Lines.write(w); err != nil {
			return err
		}
	}
	if fields[10] {
		if err := w.writeFieldHeader(uvarint, 10); err != nil {
			return err
		}
		if err := v.Disabled.write(w); err != nil {
			return err
		}
	}
	if fields[11] {
		if err := w.writeFieldHeader(uvarint, 11); err != nil {
			return err
		}
		if err := v.DisableAutocomplete.write(w); err != nil {
			return err
		}
	}
	if fields[12] {
		if err := w.writeFieldHeader(uvarint, 12); err != nil {
			return err
		}
		if err := v.DisableDebounce.write(w); err != nil {
			return err
		}
	}
	if fields[13] {
		if err := w.writeFieldHeader(uvarint, 13); err != nil {
			return err
		}
		if err := v.Invisible.write(w); err != nil {
			return err
		}
	}
	if fields[14] {
		if err := w.writeFieldHeader(uvarint, 14); err != nil {
			return err
		}
		if err := v.Revealed.write(w); err != nil {
			return err
		}
	}
	if fields[15] {
		if err := w.writeFieldHeader(byteSlice, 15); err != nil {
			return err
		}
		if err := v.Id.write(w); err != nil {
			return err
		}
	}
	if fields[16] {
		if err := w.writeFieldHeader(uvarint, 16); err != nil {
			return err
		}
		if err := v.KeydownEnter.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *PasswordField) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Label.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.SupportingText.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.ErrorText.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Value.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.Frame.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.InputValue.read(r)
			if err != nil {
				return err
			}
		case 7:
			err := v.Style.read(r)
			if err != nil {
				return err
			}
		case 8:
			err := v.DebounceTime.read(r)
			if err != nil {
				return err
			}
		case 9:
			err := v.Lines.read(r)
			if err != nil {
				return err
			}
		case 10:
			err := v.Disabled.read(r)
			if err != nil {
				return err
			}
		case 11:
			err := v.DisableAutocomplete.read(r)
			if err != nil {
				return err
			}
		case 12:
			err := v.DisableDebounce.read(r)
			if err != nil {
				return err
			}
		case 13:
			err := v.Invisible.read(r)
			if err != nil {
				return err
			}
		case 14:
			err := v.Revealed.read(r)
			if err != nil {
				return err
			}
		case 15:
			err := v.Id.read(r)
			if err != nil {
				return err
			}
		case 16:
			err := v.KeydownEnter.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type TextFieldStyle uint64

const (
	// TextFieldOutlined is fine for smaller forms and helps to identify where to put text in the form.
	TextFieldOutlined TextFieldStyle = 0
	// TextFieldReduced has no outlines and thus less visual disruption in larger forms.
	TextFieldReduced TextFieldStyle = 1
	// TextFieldBasic removes as much as decorations as possible. There may be limitations based on the platform. Note, that an implementation is allowed to ignore leading, trailing, supporting and errorText for this mode. It may serve as a building-block for custom fields.
	TextFieldBasic TextFieldStyle = 2
)

func (v *TextFieldStyle) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *TextFieldStyle) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = TextFieldStyle(tmp)
	return nil
}

func (v *TextFieldStyle) reset() {
	*v = TextFieldStyle(0)
}
func (v *TextFieldStyle) IsZero() bool {
	return *v == 0
}

// Ping is usually send by the frontend to the backend to keep the websocket alive for all intermediate proxies or other underlying channel implementations.
type Ping struct {
}

func (v *Ping) write(w *BinaryWriter) error {
	var fields [1]bool

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	return nil
}

func (v *Ping) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		}
	}
	return nil
}

// Radiobutton represents a user interface element which spans a visible area to click or tap from the user. Usually a radiobutton belongs to a group, where only a single element can be picked. Thus, it is quite similar to a Spinner/Select/Combobox.
type Radiobutton struct {
	// InputValue is where updated value of the checked states are written.
	InputValue Ptr
	// Value is the initial checked value.
	Value     Bool
	Disabled  Bool
	Invisible Bool
}

func (v *Radiobutton) write(w *BinaryWriter) error {
	var fields [5]bool
	fields[1] = !v.InputValue.IsZero()
	fields[2] = !v.Value.IsZero()
	fields[3] = !v.Disabled.IsZero()
	fields[4] = !v.Invisible.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(uvarint, 1); err != nil {
			return err
		}
		if err := v.InputValue.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(uvarint, 2); err != nil {
			return err
		}
		if err := v.Value.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(uvarint, 3); err != nil {
			return err
		}
		if err := v.Disabled.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(uvarint, 4); err != nil {
			return err
		}
		if err := v.Invisible.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Radiobutton) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.InputValue.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Value.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.Disabled.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Invisible.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type ScaffoldAlignment uint64

const (
	ScaffoldAlignmentTop     ScaffoldAlignment = 0
	ScaffoldAlignmentLeading ScaffoldAlignment = 1
)

func (v *ScaffoldAlignment) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *ScaffoldAlignment) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = ScaffoldAlignment(tmp)
	return nil
}

func (v *ScaffoldAlignment) reset() {
	*v = ScaffoldAlignment(0)
}
func (v *ScaffoldAlignment) IsZero() bool {
	return *v == 0
}

type Scaffold struct {
	Body      Component
	Logo      Component
	Menu      ScaffoldMenuEntries
	Alignment ScaffoldAlignment
}

func (v *Scaffold) write(w *BinaryWriter) error {
	var fields [5]bool
	fields[1] = v.Body != nil && !v.Body.IsZero()
	fields[2] = v.Logo != nil && !v.Logo.IsZero()
	fields[3] = !v.Menu.IsZero()
	fields[4] = !v.Alignment.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		// polymorphic field (enum) type encodes as polymorphic array
		if err := w.writeFieldHeader(array, 1); err != nil {
			return err
		}
		if err := w.writeUvarint(1); err != nil {
			return err
		}
		if err := v.Body.writeTypeHeader(w); err != nil {
			return err
		}
		if err := v.Body.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		// polymorphic field (enum) type encodes as polymorphic array
		if err := w.writeFieldHeader(array, 2); err != nil {
			return err
		}
		if err := w.writeUvarint(1); err != nil {
			return err
		}
		if err := v.Logo.writeTypeHeader(w); err != nil {
			return err
		}
		if err := v.Logo.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(array, 3); err != nil {
			return err
		}
		if err := v.Menu.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(uvarint, 4); err != nil {
			return err
		}
		if err := v.Alignment.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Scaffold) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			// polymorphic field type (enum) decodes as polymorphic array
			count, err := r.readUvarint()
			if err != nil {
				return err
			}
			if count != 1 {
				return fmt.Errorf("expected exact 1 element in enum field")
			}
			obj, err := Unmarshal(r)
			if err != nil {
				return err
			}
			v.Body = obj.(Component)
		case 2:
			// polymorphic field type (enum) decodes as polymorphic array
			count, err := r.readUvarint()
			if err != nil {
				return err
			}
			if count != 1 {
				return fmt.Errorf("expected exact 1 element in enum field")
			}
			obj, err := Unmarshal(r)
			if err != nil {
				return err
			}
			v.Logo = obj.(Component)
		case 3:
			err := v.Menu.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Alignment.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type ScaffoldMenuEntry struct {
	Icon       Component
	IconActive Component
	Title      Str
	Action     Ptr
	RootView   RootViewID
	Menu       ScaffoldMenuEntries
	Badge      Str
	Expanded   Bool
}

func (v *ScaffoldMenuEntry) write(w *BinaryWriter) error {
	var fields [9]bool
	fields[1] = v.Icon != nil && !v.Icon.IsZero()
	fields[2] = v.IconActive != nil && !v.IconActive.IsZero()
	fields[3] = !v.Title.IsZero()
	fields[4] = !v.Action.IsZero()
	fields[5] = !v.RootView.IsZero()
	fields[6] = !v.Menu.IsZero()
	fields[7] = !v.Badge.IsZero()
	fields[8] = !v.Expanded.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		// polymorphic field (enum) type encodes as polymorphic array
		if err := w.writeFieldHeader(array, 1); err != nil {
			return err
		}
		if err := w.writeUvarint(1); err != nil {
			return err
		}
		if err := v.Icon.writeTypeHeader(w); err != nil {
			return err
		}
		if err := v.Icon.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		// polymorphic field (enum) type encodes as polymorphic array
		if err := w.writeFieldHeader(array, 2); err != nil {
			return err
		}
		if err := w.writeUvarint(1); err != nil {
			return err
		}
		if err := v.IconActive.writeTypeHeader(w); err != nil {
			return err
		}
		if err := v.IconActive.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(byteSlice, 3); err != nil {
			return err
		}
		if err := v.Title.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(uvarint, 4); err != nil {
			return err
		}
		if err := v.Action.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(byteSlice, 5); err != nil {
			return err
		}
		if err := v.RootView.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(array, 6); err != nil {
			return err
		}
		if err := v.Menu.write(w); err != nil {
			return err
		}
	}
	if fields[7] {
		if err := w.writeFieldHeader(byteSlice, 7); err != nil {
			return err
		}
		if err := v.Badge.write(w); err != nil {
			return err
		}
	}
	if fields[8] {
		if err := w.writeFieldHeader(uvarint, 8); err != nil {
			return err
		}
		if err := v.Expanded.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *ScaffoldMenuEntry) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			// polymorphic field type (enum) decodes as polymorphic array
			count, err := r.readUvarint()
			if err != nil {
				return err
			}
			if count != 1 {
				return fmt.Errorf("expected exact 1 element in enum field")
			}
			obj, err := Unmarshal(r)
			if err != nil {
				return err
			}
			v.Icon = obj.(Component)
		case 2:
			// polymorphic field type (enum) decodes as polymorphic array
			count, err := r.readUvarint()
			if err != nil {
				return err
			}
			if count != 1 {
				return fmt.Errorf("expected exact 1 element in enum field")
			}
			obj, err := Unmarshal(r)
			if err != nil {
				return err
			}
			v.IconActive = obj.(Component)
		case 3:
			err := v.Title.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Action.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.RootView.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.Menu.read(r)
			if err != nil {
				return err
			}
		case 7:
			err := v.Badge.read(r)
			if err != nil {
				return err
			}
		case 8:
			err := v.Expanded.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// ScopeDestructionRequested can be emitted by a frontend to deallocate a scope, its states and root view at the backend side. This is usually only possible, if you have a kind of destruction event in the frontend.
type ScopeDestructionRequested struct {
	RID RID
}

func (v *ScopeDestructionRequested) write(w *BinaryWriter) error {
	var fields [2]bool
	fields[1] = !v.RID.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(uvarint, 1); err != nil {
			return err
		}
		if err := v.RID.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *ScopeDestructionRequested) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.RID.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type ScrollViewAxis uint64

const (
	ScrollViewAxisVertical   ScrollViewAxis = 0
	ScrollViewAxisHorizontal ScrollViewAxis = 1
)

func (v *ScrollViewAxis) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *ScrollViewAxis) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = ScrollViewAxis(tmp)
	return nil
}

func (v *ScrollViewAxis) reset() {
	*v = ScrollViewAxis(0)
}
func (v *ScrollViewAxis) IsZero() bool {
	return *v == 0
}

// A ScrollView can either be horizontal or vertical.
type ScrollView struct {
	Content         Component
	Border          Border
	Frame           Frame
	Padding         Padding
	BackgroundColor Color
	Axis            ScrollViewAxis
	Invisible       Bool
}

func (v *ScrollView) write(w *BinaryWriter) error {
	var fields [8]bool
	fields[1] = v.Content != nil && !v.Content.IsZero()
	fields[2] = !v.Border.IsZero()
	fields[3] = !v.Frame.IsZero()
	fields[4] = !v.Padding.IsZero()
	fields[5] = !v.BackgroundColor.IsZero()
	fields[6] = !v.Axis.IsZero()
	fields[7] = !v.Invisible.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		// polymorphic field (enum) type encodes as polymorphic array
		if err := w.writeFieldHeader(array, 1); err != nil {
			return err
		}
		if err := w.writeUvarint(1); err != nil {
			return err
		}
		if err := v.Content.writeTypeHeader(w); err != nil {
			return err
		}
		if err := v.Content.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(record, 2); err != nil {
			return err
		}
		if err := v.Border.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(record, 3); err != nil {
			return err
		}
		if err := v.Frame.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(record, 4); err != nil {
			return err
		}
		if err := v.Padding.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(byteSlice, 5); err != nil {
			return err
		}
		if err := v.BackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(uvarint, 6); err != nil {
			return err
		}
		if err := v.Axis.write(w); err != nil {
			return err
		}
	}
	if fields[7] {
		if err := w.writeFieldHeader(uvarint, 7); err != nil {
			return err
		}
		if err := v.Invisible.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *ScrollView) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			// polymorphic field type (enum) decodes as polymorphic array
			count, err := r.readUvarint()
			if err != nil {
				return err
			}
			if count != 1 {
				return fmt.Errorf("expected exact 1 element in enum field")
			}
			obj, err := Unmarshal(r)
			if err != nil {
				return err
			}
			v.Content = obj.(Component)
		case 2:
			err := v.Border.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.Frame.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Padding.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.BackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.Axis.read(r)
			if err != nil {
				return err
			}
		case 7:
			err := v.Invisible.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// A Resource represents a blob with a name and a resource accessor URI.
type Resource struct {
	// Name must not be a path, just the human readable (and not unique) file name.
	Name Str
	// URI is likely an unreadable link to resolve the actual data. It may incorporate additional security tokens and may have a limited lifetime and its scheme is undefined.
	URI URI
	// MimeType is optional and is a hint about the anticipated content.
	MimeType Str
}

func (v *Resource) write(w *BinaryWriter) error {
	var fields [4]bool
	fields[1] = !v.Name.IsZero()
	fields[2] = !v.URI.IsZero()
	fields[3] = !v.MimeType.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.Name.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(byteSlice, 2); err != nil {
			return err
		}
		if err := v.URI.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(byteSlice, 3); err != nil {
			return err
		}
		if err := v.MimeType.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Resource) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Name.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.URI.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.MimeType.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// SendMultipleRequested is an event for the frontend from the backend
// to send the according resources into the system environment.
// A Webbrowser may issue a regular download. A backend should not issue multiple downloads at once but instead
// pack multiple files into a zip file because the browser support for something like a multipart download
// is just broken today. An Android App may trigger the according Intent and opens a picker
// to select the receiving app.
type SendMultipleRequested struct {
	Resources Resources
}

func (v *SendMultipleRequested) write(w *BinaryWriter) error {
	var fields [2]bool
	fields[1] = !v.Resources.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(array, 1); err != nil {
			return err
		}
		if err := v.Resources.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *SendMultipleRequested) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Resources.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// SessionAssigned must not be used by browser clients directly. A http channel implementation must issue this by itself due to security concerns like http-only cookies. Native client (mobile or desktop) should use this event instead.
type SessionAssigned struct {
	SessionID Str
}

func (v *SessionAssigned) write(w *BinaryWriter) error {
	var fields [2]bool
	fields[1] = !v.SessionID.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.SessionID.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *SessionAssigned) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.SessionID.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// Spacer grows or shrinks within a HStack or VStack. In other layouts, the behavior is unspecified.
type Spacer struct {
	Frame           Frame
	Border          Border
	BackgroundColor Color
}

func (v *Spacer) write(w *BinaryWriter) error {
	var fields [4]bool
	fields[1] = !v.Frame.IsZero()
	fields[2] = !v.Border.IsZero()
	fields[3] = !v.BackgroundColor.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(record, 1); err != nil {
			return err
		}
		if err := v.Frame.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(record, 2); err != nil {
			return err
		}
		if err := v.Border.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(byteSlice, 3); err != nil {
			return err
		}
		if err := v.BackgroundColor.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Spacer) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Frame.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Border.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.BackgroundColor.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// Table represents a pre-styled table with limited styling capabilities. Use Grid for maximum flexibility.
type Table struct {
	Header             TableHeader
	Rows               TableRows
	Frame              Frame
	BackgroundColor    Color
	Border             Border
	DefaultCellPadding Padding
	RowDividerColor    Color
	HeaderDividerColor Color
}

func (v *Table) write(w *BinaryWriter) error {
	var fields [9]bool
	fields[1] = !v.Header.IsZero()
	fields[2] = !v.Rows.IsZero()
	fields[3] = !v.Frame.IsZero()
	fields[4] = !v.BackgroundColor.IsZero()
	fields[5] = !v.Border.IsZero()
	fields[6] = !v.DefaultCellPadding.IsZero()
	fields[7] = !v.RowDividerColor.IsZero()
	fields[8] = !v.HeaderDividerColor.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(record, 1); err != nil {
			return err
		}
		if err := v.Header.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(array, 2); err != nil {
			return err
		}
		if err := v.Rows.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(record, 3); err != nil {
			return err
		}
		if err := v.Frame.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(byteSlice, 4); err != nil {
			return err
		}
		if err := v.BackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(record, 5); err != nil {
			return err
		}
		if err := v.Border.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(record, 6); err != nil {
			return err
		}
		if err := v.DefaultCellPadding.write(w); err != nil {
			return err
		}
	}
	if fields[7] {
		if err := w.writeFieldHeader(byteSlice, 7); err != nil {
			return err
		}
		if err := v.RowDividerColor.write(w); err != nil {
			return err
		}
	}
	if fields[8] {
		if err := w.writeFieldHeader(byteSlice, 8); err != nil {
			return err
		}
		if err := v.HeaderDividerColor.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Table) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Header.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Rows.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.Frame.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.BackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.Border.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.DefaultCellPadding.read(r)
			if err != nil {
				return err
			}
		case 7:
			err := v.RowDividerColor.read(r)
			if err != nil {
				return err
			}
		case 8:
			err := v.HeaderDividerColor.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type TableCell struct {
	Content Component
	// Values higher than 65534 are clipped.
	RowSpan Uint
	// Values higher than 1000 are clipped.
	ColSpan                Uint
	Alignment              Alignment
	BackgroundColor        Color
	HoveredBackgroundColor Color
	Padding                Padding
	Border                 Border
	Action                 Ptr
	Hovered                Bool
}

func (v *TableCell) write(w *BinaryWriter) error {
	var fields [11]bool
	fields[1] = v.Content != nil && !v.Content.IsZero()
	fields[2] = !v.RowSpan.IsZero()
	fields[3] = !v.ColSpan.IsZero()
	fields[4] = !v.Alignment.IsZero()
	fields[5] = !v.BackgroundColor.IsZero()
	fields[6] = !v.HoveredBackgroundColor.IsZero()
	fields[7] = !v.Padding.IsZero()
	fields[8] = !v.Border.IsZero()
	fields[9] = !v.Action.IsZero()
	fields[10] = !v.Hovered.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		// polymorphic field (enum) type encodes as polymorphic array
		if err := w.writeFieldHeader(array, 1); err != nil {
			return err
		}
		if err := w.writeUvarint(1); err != nil {
			return err
		}
		if err := v.Content.writeTypeHeader(w); err != nil {
			return err
		}
		if err := v.Content.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(uvarint, 2); err != nil {
			return err
		}
		if err := v.RowSpan.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(uvarint, 3); err != nil {
			return err
		}
		if err := v.ColSpan.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(uvarint, 4); err != nil {
			return err
		}
		if err := v.Alignment.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(byteSlice, 5); err != nil {
			return err
		}
		if err := v.BackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(byteSlice, 6); err != nil {
			return err
		}
		if err := v.HoveredBackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[7] {
		if err := w.writeFieldHeader(record, 7); err != nil {
			return err
		}
		if err := v.Padding.write(w); err != nil {
			return err
		}
	}
	if fields[8] {
		if err := w.writeFieldHeader(record, 8); err != nil {
			return err
		}
		if err := v.Border.write(w); err != nil {
			return err
		}
	}
	if fields[9] {
		if err := w.writeFieldHeader(uvarint, 9); err != nil {
			return err
		}
		if err := v.Action.write(w); err != nil {
			return err
		}
	}
	if fields[10] {
		if err := w.writeFieldHeader(uvarint, 10); err != nil {
			return err
		}
		if err := v.Hovered.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *TableCell) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			// polymorphic field type (enum) decodes as polymorphic array
			count, err := r.readUvarint()
			if err != nil {
				return err
			}
			if count != 1 {
				return fmt.Errorf("expected exact 1 element in enum field")
			}
			obj, err := Unmarshal(r)
			if err != nil {
				return err
			}
			v.Content = obj.(Component)
		case 2:
			err := v.RowSpan.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.ColSpan.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Alignment.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.BackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.HoveredBackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 7:
			err := v.Padding.read(r)
			if err != nil {
				return err
			}
		case 8:
			err := v.Border.read(r)
			if err != nil {
				return err
			}
		case 9:
			err := v.Action.read(r)
			if err != nil {
				return err
			}
		case 10:
			err := v.Hovered.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type TableColumn struct {
	Content Component
	// Values higher than 1000 are clipped.
	ColSpan                    Uint
	Width                      Length
	Alignment                  Alignment
	CellBackgroundColor        Color
	CellAction                 Ptr
	CellPadding                Padding
	CellBorder                 Border
	CellHoveredBackgroundColor Color
	CellHovered                Bool
}

func (v *TableColumn) write(w *BinaryWriter) error {
	var fields [11]bool
	fields[1] = v.Content != nil && !v.Content.IsZero()
	fields[2] = !v.ColSpan.IsZero()
	fields[3] = !v.Width.IsZero()
	fields[4] = !v.Alignment.IsZero()
	fields[5] = !v.CellBackgroundColor.IsZero()
	fields[6] = !v.CellAction.IsZero()
	fields[7] = !v.CellPadding.IsZero()
	fields[8] = !v.CellBorder.IsZero()
	fields[9] = !v.CellHoveredBackgroundColor.IsZero()
	fields[10] = !v.CellHovered.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		// polymorphic field (enum) type encodes as polymorphic array
		if err := w.writeFieldHeader(array, 1); err != nil {
			return err
		}
		if err := w.writeUvarint(1); err != nil {
			return err
		}
		if err := v.Content.writeTypeHeader(w); err != nil {
			return err
		}
		if err := v.Content.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(uvarint, 2); err != nil {
			return err
		}
		if err := v.ColSpan.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(byteSlice, 3); err != nil {
			return err
		}
		if err := v.Width.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(uvarint, 4); err != nil {
			return err
		}
		if err := v.Alignment.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(byteSlice, 5); err != nil {
			return err
		}
		if err := v.CellBackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(uvarint, 6); err != nil {
			return err
		}
		if err := v.CellAction.write(w); err != nil {
			return err
		}
	}
	if fields[7] {
		if err := w.writeFieldHeader(record, 7); err != nil {
			return err
		}
		if err := v.CellPadding.write(w); err != nil {
			return err
		}
	}
	if fields[8] {
		if err := w.writeFieldHeader(record, 8); err != nil {
			return err
		}
		if err := v.CellBorder.write(w); err != nil {
			return err
		}
	}
	if fields[9] {
		if err := w.writeFieldHeader(byteSlice, 9); err != nil {
			return err
		}
		if err := v.CellHoveredBackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[10] {
		if err := w.writeFieldHeader(uvarint, 10); err != nil {
			return err
		}
		if err := v.CellHovered.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *TableColumn) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			// polymorphic field type (enum) decodes as polymorphic array
			count, err := r.readUvarint()
			if err != nil {
				return err
			}
			if count != 1 {
				return fmt.Errorf("expected exact 1 element in enum field")
			}
			obj, err := Unmarshal(r)
			if err != nil {
				return err
			}
			v.Content = obj.(Component)
		case 2:
			err := v.ColSpan.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.Width.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Alignment.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.CellBackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.CellAction.read(r)
			if err != nil {
				return err
			}
		case 7:
			err := v.CellPadding.read(r)
			if err != nil {
				return err
			}
		case 8:
			err := v.CellBorder.read(r)
			if err != nil {
				return err
			}
		case 9:
			err := v.CellHoveredBackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 10:
			err := v.CellHovered.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type TableRow struct {
	Cells                  TableCells
	Height                 Length
	BackgroundColor        Color
	HoveredBackgroundColor Color
	Action                 Ptr
	Hovered                Bool
}

func (v *TableRow) write(w *BinaryWriter) error {
	var fields [7]bool
	fields[1] = !v.Cells.IsZero()
	fields[2] = !v.Height.IsZero()
	fields[3] = !v.BackgroundColor.IsZero()
	fields[4] = !v.HoveredBackgroundColor.IsZero()
	fields[5] = !v.Action.IsZero()
	fields[6] = !v.Hovered.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(array, 1); err != nil {
			return err
		}
		if err := v.Cells.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(byteSlice, 2); err != nil {
			return err
		}
		if err := v.Height.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(byteSlice, 3); err != nil {
			return err
		}
		if err := v.BackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(byteSlice, 4); err != nil {
			return err
		}
		if err := v.HoveredBackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(uvarint, 5); err != nil {
			return err
		}
		if err := v.Action.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(uvarint, 6); err != nil {
			return err
		}
		if err := v.Hovered.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *TableRow) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Cells.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Height.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.BackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.HoveredBackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.Action.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.Hovered.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// TableHeader aggregates the optional header properties and defines columns from left to right. We are not assigning cells to columns by id, to lower the protocol overhead.
type TableHeader struct {
	Columns TableColumns
}

func (v *TableHeader) write(w *BinaryWriter) error {
	var fields [2]bool
	fields[1] = !v.Columns.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(array, 1); err != nil {
			return err
		}
		if err := v.Columns.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *TableHeader) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Columns.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type TextView struct {
	Value Str
	// Color denotes the text color. Leave empty, for the context sensitiv default theme color.
	Color Color
	// BackgroundColor denotes the color of the text background. Leave empty, for the context sensitiv default theme color.
	BackgroundColor        Color
	OnClick                Ptr
	OnHoverStart           Ptr
	OnHoverEnd             Ptr
	Border                 Border
	Padding                Padding
	Frame                  Frame
	AccessibilityLabel     Str
	Font                   Font
	Action                 Ptr
	TextAlignment          TextAlignment
	HoveredBackgroundColor Color
	PressedBackgroundColor Color
	FocusedBackgroundColor Color
	HoveredBorder          Border
	PressedBorder          Border
	FocusedBorder          Border
	LineBreak              Bool
	Invisible              Bool
	Underline              Bool
}

func (v *TextView) write(w *BinaryWriter) error {
	var fields [23]bool
	fields[1] = !v.Value.IsZero()
	fields[2] = !v.Color.IsZero()
	fields[3] = !v.BackgroundColor.IsZero()
	fields[4] = !v.OnClick.IsZero()
	fields[5] = !v.OnHoverStart.IsZero()
	fields[6] = !v.OnHoverEnd.IsZero()
	fields[7] = !v.Border.IsZero()
	fields[8] = !v.Padding.IsZero()
	fields[9] = !v.Frame.IsZero()
	fields[10] = !v.AccessibilityLabel.IsZero()
	fields[11] = !v.Font.IsZero()
	fields[12] = !v.Action.IsZero()
	fields[13] = !v.TextAlignment.IsZero()
	fields[14] = !v.HoveredBackgroundColor.IsZero()
	fields[15] = !v.PressedBackgroundColor.IsZero()
	fields[16] = !v.FocusedBackgroundColor.IsZero()
	fields[17] = !v.HoveredBorder.IsZero()
	fields[18] = !v.PressedBorder.IsZero()
	fields[19] = !v.FocusedBorder.IsZero()
	fields[20] = !v.LineBreak.IsZero()
	fields[21] = !v.Invisible.IsZero()
	fields[22] = !v.Underline.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.Value.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(byteSlice, 2); err != nil {
			return err
		}
		if err := v.Color.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(byteSlice, 3); err != nil {
			return err
		}
		if err := v.BackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(uvarint, 4); err != nil {
			return err
		}
		if err := v.OnClick.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(uvarint, 5); err != nil {
			return err
		}
		if err := v.OnHoverStart.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(uvarint, 6); err != nil {
			return err
		}
		if err := v.OnHoverEnd.write(w); err != nil {
			return err
		}
	}
	if fields[7] {
		if err := w.writeFieldHeader(record, 7); err != nil {
			return err
		}
		if err := v.Border.write(w); err != nil {
			return err
		}
	}
	if fields[8] {
		if err := w.writeFieldHeader(record, 8); err != nil {
			return err
		}
		if err := v.Padding.write(w); err != nil {
			return err
		}
	}
	if fields[9] {
		if err := w.writeFieldHeader(record, 9); err != nil {
			return err
		}
		if err := v.Frame.write(w); err != nil {
			return err
		}
	}
	if fields[10] {
		if err := w.writeFieldHeader(byteSlice, 10); err != nil {
			return err
		}
		if err := v.AccessibilityLabel.write(w); err != nil {
			return err
		}
	}
	if fields[11] {
		if err := w.writeFieldHeader(record, 11); err != nil {
			return err
		}
		if err := v.Font.write(w); err != nil {
			return err
		}
	}
	if fields[12] {
		if err := w.writeFieldHeader(uvarint, 12); err != nil {
			return err
		}
		if err := v.Action.write(w); err != nil {
			return err
		}
	}
	if fields[13] {
		if err := w.writeFieldHeader(uvarint, 13); err != nil {
			return err
		}
		if err := v.TextAlignment.write(w); err != nil {
			return err
		}
	}
	if fields[14] {
		if err := w.writeFieldHeader(byteSlice, 14); err != nil {
			return err
		}
		if err := v.HoveredBackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[15] {
		if err := w.writeFieldHeader(byteSlice, 15); err != nil {
			return err
		}
		if err := v.PressedBackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[16] {
		if err := w.writeFieldHeader(byteSlice, 16); err != nil {
			return err
		}
		if err := v.FocusedBackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[17] {
		if err := w.writeFieldHeader(record, 17); err != nil {
			return err
		}
		if err := v.HoveredBorder.write(w); err != nil {
			return err
		}
	}
	if fields[18] {
		if err := w.writeFieldHeader(record, 18); err != nil {
			return err
		}
		if err := v.PressedBorder.write(w); err != nil {
			return err
		}
	}
	if fields[19] {
		if err := w.writeFieldHeader(record, 19); err != nil {
			return err
		}
		if err := v.FocusedBorder.write(w); err != nil {
			return err
		}
	}
	if fields[20] {
		if err := w.writeFieldHeader(uvarint, 20); err != nil {
			return err
		}
		if err := v.LineBreak.write(w); err != nil {
			return err
		}
	}
	if fields[21] {
		if err := w.writeFieldHeader(uvarint, 21); err != nil {
			return err
		}
		if err := v.Invisible.write(w); err != nil {
			return err
		}
	}
	if fields[22] {
		if err := w.writeFieldHeader(uvarint, 22); err != nil {
			return err
		}
		if err := v.Underline.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *TextView) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Value.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Color.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.BackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.OnClick.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.OnHoverStart.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.OnHoverEnd.read(r)
			if err != nil {
				return err
			}
		case 7:
			err := v.Border.read(r)
			if err != nil {
				return err
			}
		case 8:
			err := v.Padding.read(r)
			if err != nil {
				return err
			}
		case 9:
			err := v.Frame.read(r)
			if err != nil {
				return err
			}
		case 10:
			err := v.AccessibilityLabel.read(r)
			if err != nil {
				return err
			}
		case 11:
			err := v.Font.read(r)
			if err != nil {
				return err
			}
		case 12:
			err := v.Action.read(r)
			if err != nil {
				return err
			}
		case 13:
			err := v.TextAlignment.read(r)
			if err != nil {
				return err
			}
		case 14:
			err := v.HoveredBackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 15:
			err := v.PressedBackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 16:
			err := v.FocusedBackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 17:
			err := v.HoveredBorder.read(r)
			if err != nil {
				return err
			}
		case 18:
			err := v.PressedBorder.read(r)
			if err != nil {
				return err
			}
		case 19:
			err := v.FocusedBorder.read(r)
			if err != nil {
				return err
			}
		case 20:
			err := v.LineBreak.read(r)
			if err != nil {
				return err
			}
		case 21:
			err := v.Invisible.read(r)
			if err != nil {
				return err
			}
		case 22:
			err := v.Underline.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type TextAlignment uint64

const (
	TextAlignInherit TextAlignment = 0
	TextAlignStart   TextAlignment = 1
	TextAlignEnd     TextAlignment = 2
	TextAlignCenter  TextAlignment = 3
	TextAlignJustify TextAlignment = 4
)

func (v *TextAlignment) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *TextAlignment) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = TextAlignment(tmp)
	return nil
}

func (v *TextAlignment) reset() {
	*v = TextAlignment(0)
}
func (v *TextAlignment) IsZero() bool {
	return *v == 0
}

type TextField struct {
	Label          Str
	SupportingText Str
	// ErrorText is shown instead of SupportingText, even if they are (today) independent
	ErrorText Str
	// Value contains the text, which shall be shown.
	Value Str
	Frame Frame
	// InputValue is a binding to a state, into which the frontend will the user entered text. This is the pointer a State.
	InputValue Ptr
	// Style to apply. Use TextFieldReduced in forms where many textfields cause too much visual noise and you need to reduce it. By default, the TextFieldOutlined is applied.
	Style TextFieldStyle
	// Leading shows the given component usually at the left (or right if RTL). This can be used for additional symbols like a magnifying glass for searching.
	Leading Component
	// Trailing show the given component usually at the right (or left if RTL mode). If set, the clear (or x button) must not be shown, to reduce distraction. This can be used for an Info button or a text showing a value unit.
	Trailing Component
	// DebounceTime is in nanoseconds. A zero or omitted value means to enable debounce default logic.
	DebounceTime Duration
	// Lines enforces a single line if <= 0, otherwise it shows the amount of text lines within a text area.
	Lines               Uint
	KeyboardOptions     KeyboardOptions
	Disabled            Bool
	DisableAutocomplete Bool
	// DisableDebounce must be set to true, to disable the default debouncer logic. This will cause a render roundtrip for each keystroke, so be careful not to break the server or cause UX issues due to UI latencies.
	DisableDebounce Bool
	Invisible       Bool
	// If Revealed the password is shown
	Revealed Bool
	// Id represents an optional identifier to locate this component within the view tree. It must be either empty or unique within the entire tree instance.
	Id           Str
	KeydownEnter Ptr
}

func (v *TextField) write(w *BinaryWriter) error {
	var fields [20]bool
	fields[1] = !v.Label.IsZero()
	fields[2] = !v.SupportingText.IsZero()
	fields[3] = !v.ErrorText.IsZero()
	fields[4] = !v.Value.IsZero()
	fields[5] = !v.Frame.IsZero()
	fields[6] = !v.InputValue.IsZero()
	fields[7] = !v.Style.IsZero()
	fields[8] = v.Leading != nil && !v.Leading.IsZero()
	fields[9] = v.Trailing != nil && !v.Trailing.IsZero()
	fields[10] = !v.DebounceTime.IsZero()
	fields[11] = !v.Lines.IsZero()
	fields[12] = !v.KeyboardOptions.IsZero()
	fields[13] = !v.Disabled.IsZero()
	fields[14] = !v.DisableAutocomplete.IsZero()
	fields[15] = !v.DisableDebounce.IsZero()
	fields[16] = !v.Invisible.IsZero()
	fields[17] = !v.Revealed.IsZero()
	fields[18] = !v.Id.IsZero()
	fields[19] = !v.KeydownEnter.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.Label.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(byteSlice, 2); err != nil {
			return err
		}
		if err := v.SupportingText.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(byteSlice, 3); err != nil {
			return err
		}
		if err := v.ErrorText.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(byteSlice, 4); err != nil {
			return err
		}
		if err := v.Value.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(record, 5); err != nil {
			return err
		}
		if err := v.Frame.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(uvarint, 6); err != nil {
			return err
		}
		if err := v.InputValue.write(w); err != nil {
			return err
		}
	}
	if fields[7] {
		if err := w.writeFieldHeader(uvarint, 7); err != nil {
			return err
		}
		if err := v.Style.write(w); err != nil {
			return err
		}
	}
	if fields[8] {
		// polymorphic field (enum) type encodes as polymorphic array
		if err := w.writeFieldHeader(array, 8); err != nil {
			return err
		}
		if err := w.writeUvarint(1); err != nil {
			return err
		}
		if err := v.Leading.writeTypeHeader(w); err != nil {
			return err
		}
		if err := v.Leading.write(w); err != nil {
			return err
		}
	}
	if fields[9] {
		// polymorphic field (enum) type encodes as polymorphic array
		if err := w.writeFieldHeader(array, 9); err != nil {
			return err
		}
		if err := w.writeUvarint(1); err != nil {
			return err
		}
		if err := v.Trailing.writeTypeHeader(w); err != nil {
			return err
		}
		if err := v.Trailing.write(w); err != nil {
			return err
		}
	}
	if fields[10] {
		if err := w.writeFieldHeader(uvarint, 10); err != nil {
			return err
		}
		if err := v.DebounceTime.write(w); err != nil {
			return err
		}
	}
	if fields[11] {
		if err := w.writeFieldHeader(uvarint, 11); err != nil {
			return err
		}
		if err := v.Lines.write(w); err != nil {
			return err
		}
	}
	if fields[12] {
		if err := w.writeFieldHeader(record, 12); err != nil {
			return err
		}
		if err := v.KeyboardOptions.write(w); err != nil {
			return err
		}
	}
	if fields[13] {
		if err := w.writeFieldHeader(uvarint, 13); err != nil {
			return err
		}
		if err := v.Disabled.write(w); err != nil {
			return err
		}
	}
	if fields[14] {
		if err := w.writeFieldHeader(uvarint, 14); err != nil {
			return err
		}
		if err := v.DisableAutocomplete.write(w); err != nil {
			return err
		}
	}
	if fields[15] {
		if err := w.writeFieldHeader(uvarint, 15); err != nil {
			return err
		}
		if err := v.DisableDebounce.write(w); err != nil {
			return err
		}
	}
	if fields[16] {
		if err := w.writeFieldHeader(uvarint, 16); err != nil {
			return err
		}
		if err := v.Invisible.write(w); err != nil {
			return err
		}
	}
	if fields[17] {
		if err := w.writeFieldHeader(uvarint, 17); err != nil {
			return err
		}
		if err := v.Revealed.write(w); err != nil {
			return err
		}
	}
	if fields[18] {
		if err := w.writeFieldHeader(byteSlice, 18); err != nil {
			return err
		}
		if err := v.Id.write(w); err != nil {
			return err
		}
	}
	if fields[19] {
		if err := w.writeFieldHeader(uvarint, 19); err != nil {
			return err
		}
		if err := v.KeydownEnter.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *TextField) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Label.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.SupportingText.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.ErrorText.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Value.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.Frame.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.InputValue.read(r)
			if err != nil {
				return err
			}
		case 7:
			err := v.Style.read(r)
			if err != nil {
				return err
			}
		case 8:
			// polymorphic field type (enum) decodes as polymorphic array
			count, err := r.readUvarint()
			if err != nil {
				return err
			}
			if count != 1 {
				return fmt.Errorf("expected exact 1 element in enum field")
			}
			obj, err := Unmarshal(r)
			if err != nil {
				return err
			}
			v.Leading = obj.(Component)
		case 9:
			// polymorphic field type (enum) decodes as polymorphic array
			count, err := r.readUvarint()
			if err != nil {
				return err
			}
			if count != 1 {
				return fmt.Errorf("expected exact 1 element in enum field")
			}
			obj, err := Unmarshal(r)
			if err != nil {
				return err
			}
			v.Trailing = obj.(Component)
		case 10:
			err := v.DebounceTime.read(r)
			if err != nil {
				return err
			}
		case 11:
			err := v.Lines.read(r)
			if err != nil {
				return err
			}
		case 12:
			err := v.KeyboardOptions.read(r)
			if err != nil {
				return err
			}
		case 13:
			err := v.Disabled.read(r)
			if err != nil {
				return err
			}
		case 14:
			err := v.DisableAutocomplete.read(r)
			if err != nil {
				return err
			}
		case 15:
			err := v.DisableDebounce.read(r)
			if err != nil {
				return err
			}
		case 16:
			err := v.Invisible.read(r)
			if err != nil {
				return err
			}
		case 17:
			err := v.Revealed.read(r)
			if err != nil {
				return err
			}
		case 18:
			err := v.Id.read(r)
			if err != nil {
				return err
			}
		case 19:
			err := v.KeydownEnter.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// Toggle is just a kind of checkbox without a label. However, a toggle shall be used for immediate activation functions. In contrast to that, use a checkbox for form things without an immediate effect.
type Toggle struct {
	// InputValue is where updated value of the checked states are written.
	InputValue Ptr
	Value      Bool
	Disabled   Bool
	Invisible  Bool
}

func (v *Toggle) write(w *BinaryWriter) error {
	var fields [5]bool
	fields[1] = !v.InputValue.IsZero()
	fields[2] = !v.Value.IsZero()
	fields[3] = !v.Disabled.IsZero()
	fields[4] = !v.Invisible.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(uvarint, 1); err != nil {
			return err
		}
		if err := v.InputValue.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(uvarint, 2); err != nil {
			return err
		}
		if err := v.Value.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(uvarint, 3); err != nil {
			return err
		}
		if err := v.Disabled.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(uvarint, 4); err != nil {
			return err
		}
		if err := v.Invisible.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Toggle) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.InputValue.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Value.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.Disabled.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Invisible.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// A TextLayout places its content like a native Text would layout its words, using the same rules for word wrap
// and alignments. This allows to style inline-components individually. SwiftUI can do this using + on
// Text and Images. Jetpack has the concept of annotated strings.
type TextLayout struct {
	Children           Components
	Border             Border
	Frame              Frame
	BackgroundColor    Color
	Padding            Padding
	AccessibilityLabel Str
	Font               Font
	Action             Ptr
	TextAlignment      TextAlignment
	Invisible          Bool
}

func (v *TextLayout) write(w *BinaryWriter) error {
	var fields [11]bool
	fields[1] = !v.Children.IsZero()
	fields[2] = !v.Border.IsZero()
	fields[3] = !v.Frame.IsZero()
	fields[4] = !v.BackgroundColor.IsZero()
	fields[5] = !v.Padding.IsZero()
	fields[6] = !v.AccessibilityLabel.IsZero()
	fields[7] = !v.Font.IsZero()
	fields[8] = !v.Action.IsZero()
	fields[9] = !v.TextAlignment.IsZero()
	fields[10] = !v.Invisible.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(array, 1); err != nil {
			return err
		}
		if err := v.Children.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(record, 2); err != nil {
			return err
		}
		if err := v.Border.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(record, 3); err != nil {
			return err
		}
		if err := v.Frame.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(byteSlice, 4); err != nil {
			return err
		}
		if err := v.BackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(record, 5); err != nil {
			return err
		}
		if err := v.Padding.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(byteSlice, 6); err != nil {
			return err
		}
		if err := v.AccessibilityLabel.write(w); err != nil {
			return err
		}
	}
	if fields[7] {
		if err := w.writeFieldHeader(record, 7); err != nil {
			return err
		}
		if err := v.Font.write(w); err != nil {
			return err
		}
	}
	if fields[8] {
		if err := w.writeFieldHeader(uvarint, 8); err != nil {
			return err
		}
		if err := v.Action.write(w); err != nil {
			return err
		}
	}
	if fields[9] {
		if err := w.writeFieldHeader(uvarint, 9); err != nil {
			return err
		}
		if err := v.TextAlignment.write(w); err != nil {
			return err
		}
	}
	if fields[10] {
		if err := w.writeFieldHeader(uvarint, 10); err != nil {
			return err
		}
		if err := v.Invisible.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *TextLayout) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Children.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Border.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.Frame.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.BackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.Padding.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.AccessibilityLabel.read(r)
			if err != nil {
				return err
			}
		case 7:
			err := v.Font.read(r)
			if err != nil {
				return err
			}
		case 8:
			err := v.Action.read(r)
			if err != nil {
				return err
			}
		case 9:
			err := v.TextAlignment.read(r)
			if err != nil {
				return err
			}
		case 10:
			err := v.Invisible.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// An VStack aligns children elements in a vertical column.
//   - the intrinsic component dimensions are the sum of all sizes of the contained children
//   - the parent can define a custom width and height
//   - if the container is larger than the contained views, it must center vertical or horizontal
//   - the inner gap between components should be around 2dp
type VStack struct {
	Children Components
	Gap      Length
	Frame    Frame
	// Zero value of Alignment is Center (=c) must be applied.
	Alignment       Alignment
	BackgroundColor Color
	Padding         Padding
	// see also https://www.w3.org/WAI/tutorials/images/decision-tree/
	AccessibilityLabel     Str
	Border                 Border
	Font                   Font
	Action                 Ptr
	HoveredBackgroundColor Color
	PressedBackgroundColor Color
	FocusedBackgroundColor Color
	HoveredBorder          Border
	PressedBorder          Border
	FocusedBorder          Border
	StylePreset            StylePreset
	Position               Position
	Disabled               Bool
	Invisible              Bool
	// Id represents an optional identifier to locate this component within the view tree. It must be either empty or unique within the entire tree instance.
	Id Str
}

func (v *VStack) write(w *BinaryWriter) error {
	var fields [22]bool
	fields[1] = !v.Children.IsZero()
	fields[2] = !v.Gap.IsZero()
	fields[3] = !v.Frame.IsZero()
	fields[4] = !v.Alignment.IsZero()
	fields[5] = !v.BackgroundColor.IsZero()
	fields[6] = !v.Padding.IsZero()
	fields[7] = !v.AccessibilityLabel.IsZero()
	fields[8] = !v.Border.IsZero()
	fields[9] = !v.Font.IsZero()
	fields[10] = !v.Action.IsZero()
	fields[11] = !v.HoveredBackgroundColor.IsZero()
	fields[12] = !v.PressedBackgroundColor.IsZero()
	fields[13] = !v.FocusedBackgroundColor.IsZero()
	fields[14] = !v.HoveredBorder.IsZero()
	fields[15] = !v.PressedBorder.IsZero()
	fields[16] = !v.FocusedBorder.IsZero()
	fields[17] = !v.StylePreset.IsZero()
	fields[18] = !v.Position.IsZero()
	fields[19] = !v.Disabled.IsZero()
	fields[20] = !v.Invisible.IsZero()
	fields[21] = !v.Id.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(array, 1); err != nil {
			return err
		}
		if err := v.Children.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(byteSlice, 2); err != nil {
			return err
		}
		if err := v.Gap.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(record, 3); err != nil {
			return err
		}
		if err := v.Frame.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(uvarint, 4); err != nil {
			return err
		}
		if err := v.Alignment.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(byteSlice, 5); err != nil {
			return err
		}
		if err := v.BackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(record, 6); err != nil {
			return err
		}
		if err := v.Padding.write(w); err != nil {
			return err
		}
	}
	if fields[7] {
		if err := w.writeFieldHeader(byteSlice, 7); err != nil {
			return err
		}
		if err := v.AccessibilityLabel.write(w); err != nil {
			return err
		}
	}
	if fields[8] {
		if err := w.writeFieldHeader(record, 8); err != nil {
			return err
		}
		if err := v.Border.write(w); err != nil {
			return err
		}
	}
	if fields[9] {
		if err := w.writeFieldHeader(record, 9); err != nil {
			return err
		}
		if err := v.Font.write(w); err != nil {
			return err
		}
	}
	if fields[10] {
		if err := w.writeFieldHeader(uvarint, 10); err != nil {
			return err
		}
		if err := v.Action.write(w); err != nil {
			return err
		}
	}
	if fields[11] {
		if err := w.writeFieldHeader(byteSlice, 11); err != nil {
			return err
		}
		if err := v.HoveredBackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[12] {
		if err := w.writeFieldHeader(byteSlice, 12); err != nil {
			return err
		}
		if err := v.PressedBackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[13] {
		if err := w.writeFieldHeader(byteSlice, 13); err != nil {
			return err
		}
		if err := v.FocusedBackgroundColor.write(w); err != nil {
			return err
		}
	}
	if fields[14] {
		if err := w.writeFieldHeader(record, 14); err != nil {
			return err
		}
		if err := v.HoveredBorder.write(w); err != nil {
			return err
		}
	}
	if fields[15] {
		if err := w.writeFieldHeader(record, 15); err != nil {
			return err
		}
		if err := v.PressedBorder.write(w); err != nil {
			return err
		}
	}
	if fields[16] {
		if err := w.writeFieldHeader(record, 16); err != nil {
			return err
		}
		if err := v.FocusedBorder.write(w); err != nil {
			return err
		}
	}
	if fields[17] {
		if err := w.writeFieldHeader(uvarint, 17); err != nil {
			return err
		}
		if err := v.StylePreset.write(w); err != nil {
			return err
		}
	}
	if fields[18] {
		if err := w.writeFieldHeader(record, 18); err != nil {
			return err
		}
		if err := v.Position.write(w); err != nil {
			return err
		}
	}
	if fields[19] {
		if err := w.writeFieldHeader(uvarint, 19); err != nil {
			return err
		}
		if err := v.Disabled.write(w); err != nil {
			return err
		}
	}
	if fields[20] {
		if err := w.writeFieldHeader(uvarint, 20); err != nil {
			return err
		}
		if err := v.Invisible.write(w); err != nil {
			return err
		}
	}
	if fields[21] {
		if err := w.writeFieldHeader(byteSlice, 21); err != nil {
			return err
		}
		if err := v.Id.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *VStack) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Children.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Gap.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.Frame.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Alignment.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.BackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.Padding.read(r)
			if err != nil {
				return err
			}
		case 7:
			err := v.AccessibilityLabel.read(r)
			if err != nil {
				return err
			}
		case 8:
			err := v.Border.read(r)
			if err != nil {
				return err
			}
		case 9:
			err := v.Font.read(r)
			if err != nil {
				return err
			}
		case 10:
			err := v.Action.read(r)
			if err != nil {
				return err
			}
		case 11:
			err := v.HoveredBackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 12:
			err := v.PressedBackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 13:
			err := v.FocusedBackgroundColor.read(r)
			if err != nil {
				return err
			}
		case 14:
			err := v.HoveredBorder.read(r)
			if err != nil {
				return err
			}
		case 15:
			err := v.PressedBorder.read(r)
			if err != nil {
				return err
			}
		case 16:
			err := v.FocusedBorder.read(r)
			if err != nil {
				return err
			}
		case 17:
			err := v.StylePreset.read(r)
			if err != nil {
				return err
			}
		case 18:
			err := v.Position.read(r)
			if err != nil {
				return err
			}
		case 19:
			err := v.Disabled.read(r)
			if err != nil {
				return err
			}
		case 20:
			err := v.Invisible.read(r)
			if err != nil {
				return err
			}
		case 21:
			err := v.Id.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type WebView struct {
	URI   URI
	Frame Frame
}

func (v *WebView) write(w *BinaryWriter) error {
	var fields [3]bool
	fields[1] = !v.URI.IsZero()
	fields[2] = !v.Frame.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.URI.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(record, 2); err != nil {
			return err
		}
		if err := v.Frame.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *WebView) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.URI.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Frame.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// WindowInfoChanged is raised by the frontend whenever the window metrics changed in a significant way. It is not guaranteed that every pixel change will trigger such an event. However, a frontend must guarantee to send such an event if the WindowSizeClass is changed.
type WindowInfoChanged struct {
	WindowInfo WindowInfo
	RID        RID
}

func (v *WindowInfoChanged) write(w *BinaryWriter) error {
	var fields [3]bool
	fields[1] = !v.WindowInfo.IsZero()
	fields[2] = !v.RID.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(record, 1); err != nil {
			return err
		}
		if err := v.WindowInfo.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(uvarint, 2); err != nil {
			return err
		}
		if err := v.RID.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *WindowInfoChanged) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.WindowInfo.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.RID.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// UpdateStateValue2Requested is raised from the frontend to update at most 2 state values hold by the backend. It can also immediately invoke a function callback in the same cycle.
type UpdateStateValues2Requested struct {
	StatePtr0 Ptr
	Value0    Str
	StatePtr1 Ptr
	Value1    Str
	// A FunctionPointer is invoked, if not zero.
	FunctionPointer Ptr
	RID             RID
}

func (v *UpdateStateValues2Requested) write(w *BinaryWriter) error {
	var fields [7]bool
	fields[1] = !v.StatePtr0.IsZero()
	fields[2] = !v.Value0.IsZero()
	fields[3] = !v.StatePtr1.IsZero()
	fields[4] = !v.Value1.IsZero()
	fields[5] = !v.FunctionPointer.IsZero()
	fields[6] = !v.RID.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(uvarint, 1); err != nil {
			return err
		}
		if err := v.StatePtr0.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(byteSlice, 2); err != nil {
			return err
		}
		if err := v.Value0.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(uvarint, 3); err != nil {
			return err
		}
		if err := v.StatePtr1.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(byteSlice, 4); err != nil {
			return err
		}
		if err := v.Value1.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(uvarint, 5); err != nil {
			return err
		}
		if err := v.FunctionPointer.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(uvarint, 6); err != nil {
			return err
		}
		if err := v.RID.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *UpdateStateValues2Requested) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.StatePtr0.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Value0.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.StatePtr1.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Value1.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.FunctionPointer.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.RID.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// OpenHttpLink triggers the system open link call.
type OpenHttpLink struct {
	Url    URI
	Target Str
}

func (v *OpenHttpLink) write(w *BinaryWriter) error {
	var fields [3]bool
	fields[1] = !v.Url.IsZero()
	fields[2] = !v.Target.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.Url.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(byteSlice, 2); err != nil {
			return err
		}
		if err := v.Target.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *OpenHttpLink) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Url.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Target.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// OpenHttpFlow starts a http redirect flow process using the specified fields.
type OpenHttpFlow struct {
	Url                URI
	RedirectTarget     Str
	RedirectNavigation Str
	Session            Str
}

func (v *OpenHttpFlow) write(w *BinaryWriter) error {
	var fields [5]bool
	fields[1] = !v.Url.IsZero()
	fields[2] = !v.RedirectTarget.IsZero()
	fields[3] = !v.RedirectNavigation.IsZero()
	fields[4] = !v.Session.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.Url.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(byteSlice, 2); err != nil {
			return err
		}
		if err := v.RedirectTarget.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(byteSlice, 3); err != nil {
			return err
		}
		if err := v.RedirectNavigation.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(byteSlice, 4); err != nil {
			return err
		}
		if err := v.Session.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *OpenHttpFlow) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Url.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.RedirectTarget.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.RedirectNavigation.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Session.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type ClipboardWriteTextRequested struct {
	Text Str
}

func (v *ClipboardWriteTextRequested) write(w *BinaryWriter) error {
	var fields [2]bool
	fields[1] = !v.Text.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.Text.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *ClipboardWriteTextRequested) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Text.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type Menu struct {
	Anchor Component
	Groups MenuGroups
	Frame  Frame
}

func (v *Menu) write(w *BinaryWriter) error {
	var fields [4]bool
	fields[1] = v.Anchor != nil && !v.Anchor.IsZero()
	fields[2] = !v.Groups.IsZero()
	fields[3] = !v.Frame.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		// polymorphic field (enum) type encodes as polymorphic array
		if err := w.writeFieldHeader(array, 1); err != nil {
			return err
		}
		if err := w.writeUvarint(1); err != nil {
			return err
		}
		if err := v.Anchor.writeTypeHeader(w); err != nil {
			return err
		}
		if err := v.Anchor.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(array, 2); err != nil {
			return err
		}
		if err := v.Groups.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(record, 3); err != nil {
			return err
		}
		if err := v.Frame.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Menu) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			// polymorphic field type (enum) decodes as polymorphic array
			count, err := r.readUvarint()
			if err != nil {
				return err
			}
			if count != 1 {
				return fmt.Errorf("expected exact 1 element in enum field")
			}
			obj, err := Unmarshal(r)
			if err != nil {
				return err
			}
			v.Anchor = obj.(Component)
		case 2:
			err := v.Groups.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.Frame.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type MenuGroup struct {
	Items MenuItems
}

func (v *MenuGroup) write(w *BinaryWriter) error {
	var fields [2]bool
	fields[1] = !v.Items.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(array, 1); err != nil {
			return err
		}
		if err := v.Items.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *MenuGroup) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Items.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type MenuItem struct {
	Action  Ptr
	Content Component
}

func (v *MenuItem) write(w *BinaryWriter) error {
	var fields [3]bool
	fields[1] = !v.Action.IsZero()
	fields[2] = v.Content != nil && !v.Content.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(uvarint, 1); err != nil {
			return err
		}
		if err := v.Action.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		// polymorphic field (enum) type encodes as polymorphic array
		if err := w.writeFieldHeader(array, 2); err != nil {
			return err
		}
		if err := w.writeUvarint(1); err != nil {
			return err
		}
		if err := v.Content.writeTypeHeader(w); err != nil {
			return err
		}
		if err := v.Content.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *MenuItem) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Action.read(r)
			if err != nil {
				return err
			}
		case 2:
			// polymorphic field type (enum) decodes as polymorphic array
			count, err := r.readUvarint()
			if err != nil {
				return err
			}
			if count != 1 {
				return fmt.Errorf("expected exact 1 element in enum field")
			}
			obj, err := Unmarshal(r)
			if err != nil {
				return err
			}
			v.Content = obj.(Component)
		}
	}
	return nil
}

// A Form is not rendered visually but is a help for accessibility.
type Form struct {
	Children Components
	Action   Ptr
	// Id represents an optional identifier to locate this component within the view tree. It must be either empty or unique within the entire tree instance.
	Id           Str
	Autocomplete Bool
	Frame        Frame
}

func (v *Form) write(w *BinaryWriter) error {
	var fields [6]bool
	fields[1] = !v.Children.IsZero()
	fields[2] = !v.Action.IsZero()
	fields[3] = !v.Id.IsZero()
	fields[4] = !v.Autocomplete.IsZero()
	fields[5] = !v.Frame.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(array, 1); err != nil {
			return err
		}
		if err := v.Children.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(uvarint, 2); err != nil {
			return err
		}
		if err := v.Action.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(byteSlice, 3); err != nil {
			return err
		}
		if err := v.Id.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(uvarint, 4); err != nil {
			return err
		}
		if err := v.Autocomplete.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(record, 5); err != nil {
			return err
		}
		if err := v.Frame.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Form) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Children.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Action.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.Id.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Autocomplete.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.Frame.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type CountDown struct {
	Action Ptr
	// Duration is in seconds. After the Duration is over, the Action is invoked. If Duration is 0, Action will not get executed.
	Duration       DurationSec
	ShowDays       Bool
	ShowHours      Bool
	ShowMinutes    Bool
	ShowSeconds    Bool
	Frame          Frame
	TextColor      Color
	SeparatorColor Color
}

func (v *CountDown) write(w *BinaryWriter) error {
	var fields [10]bool
	fields[1] = !v.Action.IsZero()
	fields[2] = !v.Duration.IsZero()
	fields[3] = !v.ShowDays.IsZero()
	fields[4] = !v.ShowHours.IsZero()
	fields[5] = !v.ShowMinutes.IsZero()
	fields[6] = !v.ShowSeconds.IsZero()
	fields[7] = !v.Frame.IsZero()
	fields[8] = !v.TextColor.IsZero()
	fields[9] = !v.SeparatorColor.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(uvarint, 1); err != nil {
			return err
		}
		if err := v.Action.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(uvarint, 2); err != nil {
			return err
		}
		if err := v.Duration.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(uvarint, 3); err != nil {
			return err
		}
		if err := v.ShowDays.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(uvarint, 4); err != nil {
			return err
		}
		if err := v.ShowHours.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(uvarint, 5); err != nil {
			return err
		}
		if err := v.ShowMinutes.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(uvarint, 6); err != nil {
			return err
		}
		if err := v.ShowSeconds.write(w); err != nil {
			return err
		}
	}
	if fields[7] {
		if err := w.writeFieldHeader(record, 7); err != nil {
			return err
		}
		if err := v.Frame.write(w); err != nil {
			return err
		}
	}
	if fields[8] {
		if err := w.writeFieldHeader(byteSlice, 8); err != nil {
			return err
		}
		if err := v.TextColor.write(w); err != nil {
			return err
		}
	}
	if fields[9] {
		if err := w.writeFieldHeader(byteSlice, 9); err != nil {
			return err
		}
		if err := v.SeparatorColor.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *CountDown) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Action.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Duration.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.ShowDays.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.ShowHours.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.ShowMinutes.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.ShowSeconds.read(r)
			if err != nil {
				return err
			}
		case 7:
			err := v.Frame.read(r)
			if err != nil {
				return err
			}
		case 8:
			err := v.TextColor.read(r)
			if err != nil {
				return err
			}
		case 9:
			err := v.SeparatorColor.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// DurationSec represents a duration in seconds
type DurationSec uint64

func (v *DurationSec) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *DurationSec) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = DurationSec(tmp)
	return nil
}

func (v *DurationSec) reset() {
	*v = DurationSec(0)
}
func (v *DurationSec) IsZero() bool {
	return *v == 0
}

// CodeEditor provides a simple area for viewing or editing source code snippets.
type CodeEditor struct {
	// Value contains the text, which shall be shown or edited.
	Value    Str
	Frame    Frame
	ReadOnly Bool
	Disabled Bool
	TabSize  Uint
	// InputValue is a binding to a state, into which the frontend will the user entered text. This is the pointer a State.
	InputValue Ptr
	// Language indicates the anticipated syntax highlighter, which shall be enabled. Defined are go, html, css, json, xml, markdown but there may be arbitrary support.
	Language Str
}

func (v *CodeEditor) write(w *BinaryWriter) error {
	var fields [8]bool
	fields[1] = !v.Value.IsZero()
	fields[2] = !v.Frame.IsZero()
	fields[3] = !v.ReadOnly.IsZero()
	fields[4] = !v.Disabled.IsZero()
	fields[5] = !v.TabSize.IsZero()
	fields[6] = !v.InputValue.IsZero()
	fields[7] = !v.Language.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(byteSlice, 1); err != nil {
			return err
		}
		if err := v.Value.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(record, 2); err != nil {
			return err
		}
		if err := v.Frame.write(w); err != nil {
			return err
		}
	}
	if fields[3] {
		if err := w.writeFieldHeader(uvarint, 3); err != nil {
			return err
		}
		if err := v.ReadOnly.write(w); err != nil {
			return err
		}
	}
	if fields[4] {
		if err := w.writeFieldHeader(uvarint, 4); err != nil {
			return err
		}
		if err := v.Disabled.write(w); err != nil {
			return err
		}
	}
	if fields[5] {
		if err := w.writeFieldHeader(uvarint, 5); err != nil {
			return err
		}
		if err := v.TabSize.write(w); err != nil {
			return err
		}
	}
	if fields[6] {
		if err := w.writeFieldHeader(uvarint, 6); err != nil {
			return err
		}
		if err := v.InputValue.write(w); err != nil {
			return err
		}
	}
	if fields[7] {
		if err := w.writeFieldHeader(byteSlice, 7); err != nil {
			return err
		}
		if err := v.Language.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *CodeEditor) read(r *BinaryReader) error {
	v.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Value.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.Frame.read(r)
			if err != nil {
				return err
			}
		case 3:
			err := v.ReadOnly.read(r)
			if err != nil {
				return err
			}
		case 4:
			err := v.Disabled.read(r)
			if err != nil {
				return err
			}
		case 5:
			err := v.TabSize.read(r)
			if err != nil {
				return err
			}
		case 6:
			err := v.InputValue.read(r)
			if err != nil {
				return err
			}
		case 7:
			err := v.Language.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type Writeable interface {
	write(*BinaryWriter) error
	writeTypeHeader(*BinaryWriter) error
}

func Marshal(dst *BinaryWriter, src Writeable) error {
	if err := src.writeTypeHeader(dst); err != nil {
		return err
	}
	if err := src.write(dst); err != nil {
		return err
	}
	return nil
}

type Readable interface {
	read(*BinaryReader) error
}

func Unmarshal(src *BinaryReader) (Readable, error) {
	_, tid, err := src.readTypeHeader()
	if err != nil {
		return nil, err
	}
	switch tid {
	case 1:
		var v Box
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 2:
		var v Ptr
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 3:
		var v UpdateStateValueRequested
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 4:
		var v FunctionCallRequested
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 5:
		var v Alignment
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 6:
		var v Color
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 7:
		var v Shadow
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 8:
		var v Length
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 9:
		var v Border
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 10:
		var v Frame
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 11:
		var v Padding
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 12:
		var v AlignedComponent
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 13:
		var v Components
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 14:
		var v AlignedComponents
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 15:
		var v Checkbox
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 16:
		var v Bool
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 17:
		var v ErrorOccurred
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 18:
		var v Locale
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 19:
		var v FontStyle
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 20:
		var v RootViewID
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 21:
		var v RootViewParameters
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 22:
		var v Str
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 23:
		var v RootViewRenderingRequested
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 24:
		var v RootViewDestructionRequested
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 25:
		var v RootViewInvalidated
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 26:
		var v ErrorRootViewAllocationRequired
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 27:
		var v RootViewAllocationRequested
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 28:
		var v WindowSizeClass
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 29:
		var v ScopeConfigurationChangeRequested
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 30:
		var v ColorScheme
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 31:
		var v WindowInfo
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 32:
		var v DP
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 33:
		var v Density
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 34:
		var v ScopeConfigurationChanged
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 35:
		var v Locales
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 36:
		var v URI
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 37:
		var v NamespaceName
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 38:
		var v NamedColors
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 39:
		var v Theme
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 40:
		var v NamespacedColors
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 41:
		var v NamedLengths
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 42:
		var v Themes
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 43:
		var v DatePickerStyle
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 44:
		var v Day
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 45:
		var v DateData
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 46:
		var v Month
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 47:
		var v Year
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 48:
		var v DatePicker
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 49:
		var v Divider
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 50:
		var v RID
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 51:
		var v FontWeight
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 52:
		var v Font
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 53:
		var v Grid
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 54:
		var v Uint
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 55:
		var v GridCells
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 56:
		var v Lengths
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 57:
		var v GridCell
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 58:
		var v HStack
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 59:
		var v StylePreset
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 60:
		var v Position
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 61:
		var v PositionType
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 62:
		var v Img
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 63:
		var v SVG
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 64:
		var v Strings
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 65:
		var v FileImportRequested
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 66:
		var v KeyboardOptions
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 67:
		var v KeyboardType
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 68:
		var v ModalType
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 69:
		var v Modal
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 70:
		var v ThemeRequested
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 71:
		var v NavigationForwardToRequested
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 72:
		var v NavigationResetRequested
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 73:
		var v NavigationBackRequested
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 74:
		var v NavigationReloadRequested
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 75:
		var v ThemeID
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 77:
		var v WindowTitle
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 78:
		var v Duration
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 79:
		var v PasswordField
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 80:
		var v TextFieldStyle
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 81:
		var v Ping
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 82:
		var v Radiobutton
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 83:
		var v ScaffoldAlignment
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 84:
		var v ScaffoldMenuEntries
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 85:
		var v Scaffold
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 86:
		var v ScaffoldMenuEntry
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 87:
		var v ScopeID
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 88:
		var v ScopeDestructionRequested
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 89:
		var v ScrollViewAxis
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 90:
		var v ScrollView
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 91:
		var v Resource
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 92:
		var v Resources
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 93:
		var v SendMultipleRequested
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 94:
		var v SessionAssigned
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 95:
		var v Spacer
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 96:
		var v Table
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 97:
		var v TableCell
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 98:
		var v TableColumn
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 99:
		var v TableRow
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 100:
		var v TableHeader
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 101:
		var v TableRows
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 102:
		var v TableCells
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 103:
		var v TableColumns
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 104:
		var v TextView
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 105:
		var v TextAlignment
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 106:
		var v TextField
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 107:
		var v Toggle
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 108:
		var v TextLayout
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 109:
		var v VStack
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 110:
		var v WebView
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 111:
		var v WindowInfoChanged
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 112:
		var v UpdateStateValues2Requested
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 113:
		var v OpenHttpLink
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 114:
		var v OpenHttpFlow
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 115:
		var v ClipboardWriteTextRequested
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 116:
		var v Menu
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 117:
		var v MenuGroup
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 118:
		var v MenuItem
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 119:
		var v MenuItems
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 120:
		var v MenuGroups
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 121:
		var v Form
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 122:
		var v CountDown
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 123:
		var v DurationSec
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 124:
		var v CodeEditor
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unknown type in marshal: %d", tid)
	}

}

func (v *Box) reset() {
	v.Children.reset()
	v.Frame.reset()
	v.BackgroundColor.reset()
	v.Padding.reset()
	v.Border.reset()
}

func (v *Box) IsZero() bool {
	return v.Children.IsZero() && v.Frame.IsZero() && v.BackgroundColor.IsZero() && v.Padding.IsZero() && v.Border.IsZero()
}

func (v *UpdateStateValueRequested) reset() {
	v.StatePointer.reset()
	v.FunctionPointer.reset()
	v.RID.reset()
	v.Value.reset()
}

func (v *UpdateStateValueRequested) IsZero() bool {
	return v.StatePointer.IsZero() && v.FunctionPointer.IsZero() && v.RID.IsZero() && v.Value.IsZero()
}

func (v *UpdateStateValueRequested) GetRID() RID {
	return v.RID
}
func (v *FunctionCallRequested) reset() {
	v.Ptr.reset()
	v.RID.reset()
}

func (v *FunctionCallRequested) IsZero() bool {
	return v.Ptr.IsZero() && v.RID.IsZero()
}

// Color specifies either a hex color like #rrggbb or #rrggbbaa or an internal custom color name.
type Color string

func (v *Color) write(r *BinaryWriter) error {
	data := *(*[]byte)(unsafe.Pointer(v))
	if err := r.writeUvarint(uint64(len(data))); err != nil {
		return err
	}
	return r.write(data)
}

func (v *Color) read(r *BinaryReader) error {
	strLen, err := r.readUvarint()
	if err != nil {
		return err
	}

	buf := make([]byte, strLen)

	if err := r.read(buf); err != nil {
		return err
	}

	*v = *(*Color)(unsafe.Pointer(&buf))
	return nil
}

func (v *Color) IsZero() bool {
	return len(*v) == 0
}

func (v *Color) reset() {
	*v = Color("")
}

func (v *Shadow) reset() {
	v.Color.reset()
	v.Radius.reset()
	v.X.reset()
	v.Y.reset()
}

func (v *Shadow) IsZero() bool {
	return v.Color.IsZero() && v.Radius.IsZero() && v.X.IsZero() && v.Y.IsZero()
}

// Length is actually a complex sum type of varying content. It may contain absolute values like dp, rem or relative like 90%. It may also include css calculations or even variable names. Retrospective, we should represent each type individually, however that was not reasonable, when the requirements and hand written protocol implementations were created and now it is to late.
type Length string

func (v *Length) write(r *BinaryWriter) error {
	data := *(*[]byte)(unsafe.Pointer(v))
	if err := r.writeUvarint(uint64(len(data))); err != nil {
		return err
	}
	return r.write(data)
}

func (v *Length) read(r *BinaryReader) error {
	strLen, err := r.readUvarint()
	if err != nil {
		return err
	}

	buf := make([]byte, strLen)

	if err := r.read(buf); err != nil {
		return err
	}

	*v = *(*Length)(unsafe.Pointer(&buf))
	return nil
}

func (v *Length) IsZero() bool {
	return len(*v) == 0
}

func (v *Length) reset() {
	*v = Length("")
}

func (v *Border) reset() {
	v.TopLeftRadius.reset()
	v.TopRightRadius.reset()
	v.BottomLeftRadius.reset()
	v.BottomRightRadius.reset()
	v.LeftWidth.reset()
	v.TopWidth.reset()
	v.RightWidth.reset()
	v.BottomWidth.reset()
	v.LeftColor.reset()
	v.TopColor.reset()
	v.RightColor.reset()
	v.BottomColor.reset()
	v.BoxShadow.reset()
}

func (v *Border) IsZero() bool {
	return v.TopLeftRadius.IsZero() && v.TopRightRadius.IsZero() && v.BottomLeftRadius.IsZero() && v.BottomRightRadius.IsZero() && v.LeftWidth.IsZero() && v.TopWidth.IsZero() && v.RightWidth.IsZero() && v.BottomWidth.IsZero() && v.LeftColor.IsZero() && v.TopColor.IsZero() && v.RightColor.IsZero() && v.BottomColor.IsZero() && v.BoxShadow.IsZero()
}

func (v *Frame) reset() {
	v.MinWidth.reset()
	v.MaxWidth.reset()
	v.MinHeight.reset()
	v.MaxHeight.reset()
	v.Width.reset()
	v.Height.reset()
}

func (v *Frame) IsZero() bool {
	return v.MinWidth.IsZero() && v.MaxWidth.IsZero() && v.MinHeight.IsZero() && v.MaxHeight.IsZero() && v.Width.IsZero() && v.Height.IsZero()
}

func (v *Padding) reset() {
	v.Top.reset()
	v.Left.reset()
	v.Right.reset()
	v.Bottom.reset()
}

func (v *Padding) IsZero() bool {
	return v.Top.IsZero() && v.Left.IsZero() && v.Right.IsZero() && v.Bottom.IsZero()
}

func (v *AlignedComponent) reset() {
	v.Component = nil
	v.Alignment.reset()
}

func (v *AlignedComponent) IsZero() bool {
	return v.Component.IsZero() && v.Alignment.IsZero()
}

// Components is polymorphic array of various concrete Component instances.
type Components []Component

func (v *Components) write(w *BinaryWriter) error {
	if err := w.writeUvarint(uint64(len(*v))); err != nil {
		return err
	}
	for _, item := range *v {
		if err := item.writeTypeHeader(w); err != nil {
			return err
		}
		if err := item.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Components) read(r *BinaryReader) error {
	count, err := r.readUvarint()
	if err != nil {
		return err
	}

	slice := make([]Component, count)
	for i := uint64(0); i < count; i++ {
		obj, err := Unmarshal(r)
		if err != nil {
			return err
		}
		slice[i] = obj.(Component)
	}

	*v = slice
	return nil
}

func (v *Components) IsZero() bool {
	return v == nil || *v == nil || len(*v) == 0
}

func (v *Components) reset() {
	*v = nil
}

// AlignedComponents is an array of layouted tupels of components.
type AlignedComponents []AlignedComponent

func (v *AlignedComponents) write(w *BinaryWriter) error {
	if err := w.writeUvarint(uint64(len(*v))); err != nil {
		return err
	}
	for _, item := range *v {
		if err := item.writeTypeHeader(w); err != nil {
			return err
		}
		if err := item.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *AlignedComponents) read(r *BinaryReader) error {
	count, err := r.readUvarint()
	if err != nil {
		return err
	}

	slice := make([]AlignedComponent, count)
	for i := uint64(0); i < count; i++ {
		obj, err := Unmarshal(r)
		if err != nil {
			return err
		}
		slice[i] = *obj.(*AlignedComponent)
	}

	*v = slice
	return nil
}

func (v *AlignedComponents) IsZero() bool {
	return v == nil || *v == nil || len(*v) == 0
}

func (v *AlignedComponents) reset() {
	*v = nil
}

func (v *Checkbox) reset() {
	v.InputValue.reset()
	v.Value.reset()
	v.Disabled.reset()
	v.Invisible.reset()
	v.Id.reset()
}

func (v *Checkbox) IsZero() bool {
	return v.InputValue.IsZero() && v.Value.IsZero() && v.Disabled.IsZero() && v.Invisible.IsZero() && v.Id.IsZero()
}

// Bool represents just a user defined boolean value. This is how nprotoc works.
type Bool bool

func (v *Bool) write(r *BinaryWriter) error {
	val := uint64(0)
	if v != nil && *v {
		val = 1
	}
	return r.writeUvarint(val)
}

func (v *Bool) read(r *BinaryReader) error {
	val, err := r.readUvarint()
	if err != nil {
		return err
	}

	if val == 1 {
		*v = true
	} else {
		*v = false
	}

	return nil
}

func (v *Bool) IsZero() bool {
	return *v == false
}

func (v *Bool) reset() {
	*v = false
}

func (v *ErrorOccurred) reset() {
	v.Message.reset()
	v.RID.reset()
}

func (v *ErrorOccurred) IsZero() bool {
	return v.Message.IsZero() && v.RID.IsZero()
}

// Locale represents a BCP47 tag like de or de_DE.
type Locale string

func (v *Locale) write(r *BinaryWriter) error {
	data := *(*[]byte)(unsafe.Pointer(v))
	if err := r.writeUvarint(uint64(len(data))); err != nil {
		return err
	}
	return r.write(data)
}

func (v *Locale) read(r *BinaryReader) error {
	strLen, err := r.readUvarint()
	if err != nil {
		return err
	}

	buf := make([]byte, strLen)

	if err := r.read(buf); err != nil {
		return err
	}

	*v = *(*Locale)(unsafe.Pointer(&buf))
	return nil
}

func (v *Locale) IsZero() bool {
	return len(*v) == 0
}

func (v *Locale) reset() {
	*v = Locale("")
}

// RootViewID is a unique address for a specific view factory, e.g. my/component/path. This is typically a page. Even though this looks like an URI, it is not. Especially, there are no path parameters or query parameters.
type RootViewID string

func (v *RootViewID) write(r *BinaryWriter) error {
	data := *(*[]byte)(unsafe.Pointer(v))
	if err := r.writeUvarint(uint64(len(data))); err != nil {
		return err
	}
	return r.write(data)
}

func (v *RootViewID) read(r *BinaryReader) error {
	strLen, err := r.readUvarint()
	if err != nil {
		return err
	}

	buf := make([]byte, strLen)

	if err := r.read(buf); err != nil {
		return err
	}

	*v = *(*RootViewID)(unsafe.Pointer(&buf))
	return nil
}

func (v *RootViewID) IsZero() bool {
	return len(*v) == 0
}

func (v *RootViewID) reset() {
	*v = RootViewID("")
}

// RootViewParameters is a map of string keys and values which is given to a root view which is about to be initialized.
type RootViewParameters map[Str]Str

func (v *RootViewParameters) write(w *BinaryWriter) error {
	if err := w.writeUvarint(uint64(len(*v))); err != nil {
		return err
	}
	for k, v := range *v {
		// key
		if err := k.writeTypeHeader(w); err != nil {
			return err
		}
		if err := k.write(w); err != nil {
			return err
		}
		// value
		if err := v.writeTypeHeader(w); err != nil {
			return err
		}
		if err := v.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *RootViewParameters) read(r *BinaryReader) error {
	count, err := r.readUvarint()
	if err != nil {
		return err
	}

	tmpMap := make(map[Str]Str, count)
	for i := uint64(0); i < count; i++ {
		k, err := Unmarshal(r)
		if err != nil {
			return err
		}
		v, err := Unmarshal(r)
		if err != nil {
			return err
		}
		tmpMap[*k.(*Str)] = *v.(*Str)
	}

	*v = tmpMap
	return nil
}

func (v *RootViewParameters) IsZero() bool {
	return v == nil || *v == nil || len(*v) == 0
}

func (v *RootViewParameters) reset() {
	*v = nil
}

// Str represents just a user defined string value. This is how nprotoc works.
type Str string

func (v *Str) write(r *BinaryWriter) error {
	data := *(*[]byte)(unsafe.Pointer(v))
	if err := r.writeUvarint(uint64(len(data))); err != nil {
		return err
	}
	return r.write(data)
}

func (v *Str) read(r *BinaryReader) error {
	strLen, err := r.readUvarint()
	if err != nil {
		return err
	}

	buf := make([]byte, strLen)

	if err := r.read(buf); err != nil {
		return err
	}

	*v = *(*Str)(unsafe.Pointer(&buf))
	return nil
}

func (v *Str) IsZero() bool {
	return len(*v) == 0
}

func (v *Str) reset() {
	*v = Str("")
}

func (v *RootViewRenderingRequested) reset() {
	v.RID.reset()
}

func (v *RootViewRenderingRequested) IsZero() bool {
	return v.RID.IsZero()
}

func (v *RootViewRenderingRequested) GetRID() RID {
	return v.RID
}
func (v *RootViewDestructionRequested) reset() {
	v.RID.reset()
}

func (v *RootViewDestructionRequested) IsZero() bool {
	return v.RID.IsZero()
}

func (v *RootViewDestructionRequested) GetRID() RID {
	return v.RID
}
func (v *RootViewInvalidated) reset() {
	v.RID.reset()
	v.Root = nil
}

func (v *RootViewInvalidated) IsZero() bool {
	return v.RID.IsZero() && v.Root.IsZero()
}

func (v *ErrorRootViewAllocationRequired) reset() {
	v.RID.reset()
}

func (v *ErrorRootViewAllocationRequired) IsZero() bool {
	return v.RID.IsZero()
}

func (v *RootViewAllocationRequested) reset() {
	v.Locale.reset()
	v.Factory.reset()
	v.RID.reset()
	v.Values.reset()
}

func (v *RootViewAllocationRequested) IsZero() bool {
	return v.Locale.IsZero() && v.Factory.IsZero() && v.RID.IsZero() && v.Values.IsZero()
}

func (v *RootViewAllocationRequested) GetRID() RID {
	return v.RID
}
func (v *ScopeConfigurationChangeRequested) reset() {
	v.RID.reset()
	v.AcceptLanguage.reset()
	v.WindowInfo.reset()
}

func (v *ScopeConfigurationChangeRequested) IsZero() bool {
	return v.RID.IsZero() && v.AcceptLanguage.IsZero() && v.WindowInfo.IsZero()
}

func (v *ScopeConfigurationChangeRequested) GetRID() RID {
	return v.RID
}
func (v *WindowInfo) reset() {
	v.Width.reset()
	v.Height.reset()
	v.Density.reset()
	v.SizeClass.reset()
	v.ColorScheme.reset()
}

func (v *WindowInfo) IsZero() bool {
	return v.Width.IsZero() && v.Height.IsZero() && v.Density.IsZero() && v.SizeClass.IsZero() && v.ColorScheme.IsZero()
}

type DP float64

func (v *DP) write(r *BinaryWriter) error {
	return r.writeFloat64(float64(*v))
}

func (v *DP) read(r *BinaryReader) error {
	val, err := r.readFloat64()
	if err != nil {
		return err
	}

	*v = DP(val)
	return nil
}

func (v *DP) IsZero() bool {
	return *v == 0.0
}

func (v *DP) reset() {
	*v = 0.0
}

type Density float64

func (v *Density) write(r *BinaryWriter) error {
	return r.writeFloat64(float64(*v))
}

func (v *Density) read(r *BinaryReader) error {
	val, err := r.readFloat64()
	if err != nil {
		return err
	}

	*v = Density(val)
	return nil
}

func (v *Density) IsZero() bool {
	return *v == 0.0
}

func (v *Density) reset() {
	*v = 0.0
}

func (v *ScopeConfigurationChanged) reset() {
	v.ApplicationID.reset()
	v.ApplicationName.reset()
	v.ApplicationVersion.reset()
	v.AvailableLocales.reset()
	v.AppIcon.reset()
	v.ActiveLocale.reset()
	v.Themes.reset()
	v.RID.reset()
}

func (v *ScopeConfigurationChanged) IsZero() bool {
	return v.ApplicationID.IsZero() && v.ApplicationName.IsZero() && v.ApplicationVersion.IsZero() && v.AvailableLocales.IsZero() && v.AppIcon.IsZero() && v.ActiveLocale.IsZero() && v.Themes.IsZero() && v.RID.IsZero()
}

// Locales is just a bunch of locales.
type Locales []Locale

func (v *Locales) write(w *BinaryWriter) error {
	if err := w.writeUvarint(uint64(len(*v))); err != nil {
		return err
	}
	for _, item := range *v {
		if err := item.writeTypeHeader(w); err != nil {
			return err
		}
		if err := item.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Locales) read(r *BinaryReader) error {
	count, err := r.readUvarint()
	if err != nil {
		return err
	}

	slice := make([]Locale, count)
	for i := uint64(0); i < count; i++ {
		obj, err := Unmarshal(r)
		if err != nil {
			return err
		}
		slice[i] = *obj.(*Locale)
	}

	*v = slice
	return nil
}

func (v *Locales) IsZero() bool {
	return v == nil || *v == nil || len(*v) == 0
}

func (v *Locales) reset() {
	*v = nil
}

// URI is just a string which looks like an URI or URL
type URI string

func (v *URI) write(r *BinaryWriter) error {
	data := *(*[]byte)(unsafe.Pointer(v))
	if err := r.writeUvarint(uint64(len(data))); err != nil {
		return err
	}
	return r.write(data)
}

func (v *URI) read(r *BinaryReader) error {
	strLen, err := r.readUvarint()
	if err != nil {
		return err
	}

	buf := make([]byte, strLen)

	if err := r.read(buf); err != nil {
		return err
	}

	*v = *(*URI)(unsafe.Pointer(&buf))
	return nil
}

func (v *URI) IsZero() bool {
	return len(*v) == 0
}

func (v *URI) reset() {
	*v = URI("")
}

// NamespaceName refers to a component or views namespace declaration. Besides the universe space, this is almost relevant for the backend, however it defines variables at the frontend, thus it may open some optimizations.
type NamespaceName string

func (v *NamespaceName) write(r *BinaryWriter) error {
	data := *(*[]byte)(unsafe.Pointer(v))
	if err := r.writeUvarint(uint64(len(data))); err != nil {
		return err
	}
	return r.write(data)
}

func (v *NamespaceName) read(r *BinaryReader) error {
	strLen, err := r.readUvarint()
	if err != nil {
		return err
	}

	buf := make([]byte, strLen)

	if err := r.read(buf); err != nil {
		return err
	}

	*v = *(*NamespaceName)(unsafe.Pointer(&buf))
	return nil
}

func (v *NamespaceName) IsZero() bool {
	return len(*v) == 0
}

func (v *NamespaceName) reset() {
	*v = NamespaceName("")
}

// NamedColors represents a map of names with associated color values.
type NamedColors map[Str]Color

func (v *NamedColors) write(w *BinaryWriter) error {
	if err := w.writeUvarint(uint64(len(*v))); err != nil {
		return err
	}
	for k, v := range *v {
		// key
		if err := k.writeTypeHeader(w); err != nil {
			return err
		}
		if err := k.write(w); err != nil {
			return err
		}
		// value
		if err := v.writeTypeHeader(w); err != nil {
			return err
		}
		if err := v.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *NamedColors) read(r *BinaryReader) error {
	count, err := r.readUvarint()
	if err != nil {
		return err
	}

	tmpMap := make(map[Str]Color, count)
	for i := uint64(0); i < count; i++ {
		k, err := Unmarshal(r)
		if err != nil {
			return err
		}
		v, err := Unmarshal(r)
		if err != nil {
			return err
		}
		tmpMap[*k.(*Str)] = *v.(*Color)
	}

	*v = tmpMap
	return nil
}

func (v *NamedColors) IsZero() bool {
	return v == nil || *v == nil || len(*v) == 0
}

func (v *NamedColors) reset() {
	*v = nil
}

func (v *Theme) reset() {
	v.Colors.reset()
	v.Lengths.reset()
}

func (v *Theme) IsZero() bool {
	return v.Colors.IsZero() && v.Lengths.IsZero()
}

// NamespacedColors represents a map of namespaces with associated color values.
type NamespacedColors map[NamespaceName]NamedColors

func (v *NamespacedColors) write(w *BinaryWriter) error {
	if err := w.writeUvarint(uint64(len(*v))); err != nil {
		return err
	}
	for k, v := range *v {
		// key
		if err := k.writeTypeHeader(w); err != nil {
			return err
		}
		if err := k.write(w); err != nil {
			return err
		}
		// value
		if err := v.writeTypeHeader(w); err != nil {
			return err
		}
		if err := v.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *NamespacedColors) read(r *BinaryReader) error {
	count, err := r.readUvarint()
	if err != nil {
		return err
	}

	tmpMap := make(map[NamespaceName]NamedColors, count)
	for i := uint64(0); i < count; i++ {
		k, err := Unmarshal(r)
		if err != nil {
			return err
		}
		v, err := Unmarshal(r)
		if err != nil {
			return err
		}
		tmpMap[*k.(*NamespaceName)] = *v.(*NamedColors)
	}

	*v = tmpMap
	return nil
}

func (v *NamespacedColors) IsZero() bool {
	return v == nil || *v == nil || len(*v) == 0
}

func (v *NamespacedColors) reset() {
	*v = nil
}

// NamedLengths represents a map of names with associated length values.
type NamedLengths map[Str]Length

func (v *NamedLengths) write(w *BinaryWriter) error {
	if err := w.writeUvarint(uint64(len(*v))); err != nil {
		return err
	}
	for k, v := range *v {
		// key
		if err := k.writeTypeHeader(w); err != nil {
			return err
		}
		if err := k.write(w); err != nil {
			return err
		}
		// value
		if err := v.writeTypeHeader(w); err != nil {
			return err
		}
		if err := v.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *NamedLengths) read(r *BinaryReader) error {
	count, err := r.readUvarint()
	if err != nil {
		return err
	}

	tmpMap := make(map[Str]Length, count)
	for i := uint64(0); i < count; i++ {
		k, err := Unmarshal(r)
		if err != nil {
			return err
		}
		v, err := Unmarshal(r)
		if err != nil {
			return err
		}
		tmpMap[*k.(*Str)] = *v.(*Length)
	}

	*v = tmpMap
	return nil
}

func (v *NamedLengths) IsZero() bool {
	return v == nil || *v == nil || len(*v) == 0
}

func (v *NamedLengths) reset() {
	*v = nil
}

func (v *Themes) reset() {
	v.Light.reset()
	v.Dark.reset()
}

func (v *Themes) IsZero() bool {
	return v.Light.IsZero() && v.Dark.IsZero()
}

func (v *DateData) reset() {
	v.Day.reset()
	v.Month.reset()
	v.Year.reset()
}

func (v *DateData) IsZero() bool {
	return v.Day.IsZero() && v.Month.IsZero() && v.Year.IsZero()
}

func (v *DatePicker) reset() {
	v.Label.reset()
	v.SupportingText.reset()
	v.ErrorText.reset()
	v.Style.reset()
	v.Value.reset()
	v.InputValue.reset()
	v.EndValue.reset()
	v.EndInputValue.reset()
	v.Frame.reset()
	v.Invisible.reset()
	v.Disabled.reset()
}

func (v *DatePicker) IsZero() bool {
	return v.Label.IsZero() && v.SupportingText.IsZero() && v.ErrorText.IsZero() && v.Style.IsZero() && v.Value.IsZero() && v.InputValue.IsZero() && v.EndValue.IsZero() && v.EndInputValue.IsZero() && v.Frame.IsZero() && v.Invisible.IsZero() && v.Disabled.IsZero()
}

func (v *Divider) reset() {
	v.Frame.reset()
	v.Border.reset()
	v.Padding.reset()
}

func (v *Divider) IsZero() bool {
	return v.Frame.IsZero() && v.Border.IsZero() && v.Padding.IsZero()
}

func (v *Font) reset() {
	v.Name.reset()
	v.Size.reset()
	v.Style.reset()
	v.Weight.reset()
}

func (v *Font) IsZero() bool {
	return v.Name.IsZero() && v.Size.IsZero() && v.Style.IsZero() && v.Weight.IsZero()
}

func (v *Grid) reset() {
	v.Cells.reset()
	v.Rows.reset()
	v.Columns.reset()
	v.RowGap.reset()
	v.ColGap.reset()
	v.Frame.reset()
	v.BackgroundColor.reset()
	v.Padding.reset()
	v.Border.reset()
	v.AccessibilityLabel.reset()
	v.Font.reset()
	v.ColWidths.reset()
	v.Invisible.reset()
}

func (v *Grid) IsZero() bool {
	return v.Cells.IsZero() && v.Rows.IsZero() && v.Columns.IsZero() && v.RowGap.IsZero() && v.ColGap.IsZero() && v.Frame.IsZero() && v.BackgroundColor.IsZero() && v.Padding.IsZero() && v.Border.IsZero() && v.AccessibilityLabel.IsZero() && v.Font.IsZero() && v.ColWidths.IsZero() && v.Invisible.IsZero()
}

// GridCells is just a bunch of GridCells.
type GridCells []GridCell

func (v *GridCells) write(w *BinaryWriter) error {
	if err := w.writeUvarint(uint64(len(*v))); err != nil {
		return err
	}
	for _, item := range *v {
		if err := item.writeTypeHeader(w); err != nil {
			return err
		}
		if err := item.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *GridCells) read(r *BinaryReader) error {
	count, err := r.readUvarint()
	if err != nil {
		return err
	}

	slice := make([]GridCell, count)
	for i := uint64(0); i < count; i++ {
		obj, err := Unmarshal(r)
		if err != nil {
			return err
		}
		slice[i] = *obj.(*GridCell)
	}

	*v = slice
	return nil
}

func (v *GridCells) IsZero() bool {
	return v == nil || *v == nil || len(*v) == 0
}

func (v *GridCells) reset() {
	*v = nil
}

// Lengths is just a bunch of length values.
type Lengths []Length

func (v *Lengths) write(w *BinaryWriter) error {
	if err := w.writeUvarint(uint64(len(*v))); err != nil {
		return err
	}
	for _, item := range *v {
		if err := item.writeTypeHeader(w); err != nil {
			return err
		}
		if err := item.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Lengths) read(r *BinaryReader) error {
	count, err := r.readUvarint()
	if err != nil {
		return err
	}

	slice := make([]Length, count)
	for i := uint64(0); i < count; i++ {
		obj, err := Unmarshal(r)
		if err != nil {
			return err
		}
		slice[i] = *obj.(*Length)
	}

	*v = slice
	return nil
}

func (v *Lengths) IsZero() bool {
	return v == nil || *v == nil || len(*v) == 0
}

func (v *Lengths) reset() {
	*v = nil
}

func (v *GridCell) reset() {
	v.Body = nil
	v.ColStart.reset()
	v.ColEnd.reset()
	v.RowStart.reset()
	v.RowEnd.reset()
	v.ColSpan.reset()
	v.RowSpan.reset()
	v.Padding.reset()
	v.Alignment.reset()
}

func (v *GridCell) IsZero() bool {
	return v.Body.IsZero() && v.ColStart.IsZero() && v.ColEnd.IsZero() && v.RowStart.IsZero() && v.RowEnd.IsZero() && v.ColSpan.IsZero() && v.RowSpan.IsZero() && v.Padding.IsZero() && v.Alignment.IsZero()
}

func (v *HStack) reset() {
	v.Children.reset()
	v.Gap.reset()
	v.Frame.reset()
	v.Alignment.reset()
	v.BackgroundColor.reset()
	v.Padding.reset()
	v.AccessibilityLabel.reset()
	v.Border.reset()
	v.Font.reset()
	v.Action.reset()
	v.HoveredBackgroundColor.reset()
	v.PressedBackgroundColor.reset()
	v.FocusedBackgroundColor.reset()
	v.HoveredBorder.reset()
	v.PressedBorder.reset()
	v.FocusedBorder.reset()
	v.Wrap.reset()
	v.StylePreset.reset()
	v.Position.reset()
	v.Disabled.reset()
	v.Invisible.reset()
	v.Id.reset()
}

func (v *HStack) IsZero() bool {
	return v.Children.IsZero() && v.Gap.IsZero() && v.Frame.IsZero() && v.Alignment.IsZero() && v.BackgroundColor.IsZero() && v.Padding.IsZero() && v.AccessibilityLabel.IsZero() && v.Border.IsZero() && v.Font.IsZero() && v.Action.IsZero() && v.HoveredBackgroundColor.IsZero() && v.PressedBackgroundColor.IsZero() && v.FocusedBackgroundColor.IsZero() && v.HoveredBorder.IsZero() && v.PressedBorder.IsZero() && v.FocusedBorder.IsZero() && v.Wrap.IsZero() && v.StylePreset.IsZero() && v.Position.IsZero() && v.Disabled.IsZero() && v.Invisible.IsZero() && v.Id.IsZero()
}

func (v *Position) reset() {
	v.Kind.reset()
	v.Left.reset()
	v.Top.reset()
	v.Right.reset()
	v.Bottom.reset()
}

func (v *Position) IsZero() bool {
	return v.Kind.IsZero() && v.Left.IsZero() && v.Top.IsZero() && v.Right.IsZero() && v.Bottom.IsZero()
}

func (v *Img) reset() {
	v.Uri.reset()
	v.AccessibilityLabel.reset()
	v.Border.reset()
	v.Frame.reset()
	v.Padding.reset()
	v.SVG.reset()
	v.FillColor.reset()
	v.StrokeColor.reset()
	v.Invisible.reset()
}

func (v *Img) IsZero() bool {
	return v.Uri.IsZero() && v.AccessibilityLabel.IsZero() && v.Border.IsZero() && v.Frame.IsZero() && v.Padding.IsZero() && v.SVG.IsZero() && v.FillColor.IsZero() && v.StrokeColor.IsZero() && v.Invisible.IsZero()
}

// SVG contains the valid embeddable source of Scalable Vector Graphics.
type SVG []byte

func (v *SVG) write(r *BinaryWriter) error {
	data := *(*[]byte)(unsafe.Pointer(v))
	if err := r.writeUvarint(uint64(len(data))); err != nil {
		return err
	}
	return r.write(data)
}

func (v *SVG) read(r *BinaryReader) error {
	strLen, err := r.readUvarint()
	if err != nil {
		return err
	}

	buf := make([]byte, strLen)

	if err := r.read(buf); err != nil {
		return err
	}

	*v = *(*SVG)(unsafe.Pointer(&buf))
	return nil
}

func (v *SVG) IsZero() bool {
	return len(*v) == 0
}

func (v *SVG) reset() {
	*v = SVG("")
}

// Strings is just a bunch of string values.
type Strings []Str

func (v *Strings) write(w *BinaryWriter) error {
	if err := w.writeUvarint(uint64(len(*v))); err != nil {
		return err
	}
	for _, item := range *v {
		if err := item.writeTypeHeader(w); err != nil {
			return err
		}
		if err := item.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Strings) read(r *BinaryReader) error {
	count, err := r.readUvarint()
	if err != nil {
		return err
	}

	slice := make([]Str, count)
	for i := uint64(0); i < count; i++ {
		obj, err := Unmarshal(r)
		if err != nil {
			return err
		}
		slice[i] = *obj.(*Str)
	}

	*v = slice
	return nil
}

func (v *Strings) IsZero() bool {
	return v == nil || *v == nil || len(*v) == 0
}

func (v *Strings) reset() {
	*v = nil
}

func (v *FileImportRequested) reset() {
	v.ID.reset()
	v.ScopeID.reset()
	v.Multiple.reset()
	v.MaxBytes.reset()
	v.AllowedMimeTypes.reset()
}

func (v *FileImportRequested) IsZero() bool {
	return v.ID.IsZero() && v.ScopeID.IsZero() && v.Multiple.IsZero() && v.MaxBytes.IsZero() && v.AllowedMimeTypes.IsZero()
}

func (v *KeyboardOptions) reset() {
	v.Capitalization.reset()
	v.AutoCorrectEnabled.reset()
	v.KeyboardType.reset()
}

func (v *KeyboardOptions) IsZero() bool {
	return v.Capitalization.IsZero() && v.AutoCorrectEnabled.IsZero() && v.KeyboardType.IsZero()
}

func (v *Modal) reset() {
	v.Content = nil
	v.OnDismissRequest.reset()
	v.ModalType.reset()
	v.Top.reset()
	v.Left.reset()
	v.Right.reset()
	v.Bottom.reset()
}

func (v *Modal) IsZero() bool {
	return v.Content.IsZero() && v.OnDismissRequest.IsZero() && v.ModalType.IsZero() && v.Top.IsZero() && v.Left.IsZero() && v.Right.IsZero() && v.Bottom.IsZero()
}

func (v *ThemeRequested) reset() {
	v.Theme.reset()
}

func (v *ThemeRequested) IsZero() bool {
	return v.Theme.IsZero()
}

func (v *NavigationForwardToRequested) reset() {
	v.RootView.reset()
	v.Values.reset()
}

func (v *NavigationForwardToRequested) IsZero() bool {
	return v.RootView.IsZero() && v.Values.IsZero()
}

func (v *NavigationResetRequested) reset() {
	v.RootView.reset()
	v.Values.reset()
}

func (v *NavigationResetRequested) IsZero() bool {
	return v.RootView.IsZero() && v.Values.IsZero()
}

func (v *NavigationBackRequested) reset() {
}

func (v *NavigationBackRequested) IsZero() bool {
	return true
}

func (v *NavigationReloadRequested) reset() {
}

func (v *NavigationReloadRequested) IsZero() bool {
	return true
}

// ThemeID refers to a specific theme. E.g. dark or light
type ThemeID string

func (v *ThemeID) write(r *BinaryWriter) error {
	data := *(*[]byte)(unsafe.Pointer(v))
	if err := r.writeUvarint(uint64(len(data))); err != nil {
		return err
	}
	return r.write(data)
}

func (v *ThemeID) read(r *BinaryReader) error {
	strLen, err := r.readUvarint()
	if err != nil {
		return err
	}

	buf := make([]byte, strLen)

	if err := r.read(buf); err != nil {
		return err
	}

	*v = *(*ThemeID)(unsafe.Pointer(&buf))
	return nil
}

func (v *ThemeID) IsZero() bool {
	return len(*v) == 0
}

func (v *ThemeID) reset() {
	*v = ThemeID("")
}

func (v *WindowTitle) reset() {
	v.Value.reset()
}

func (v *WindowTitle) IsZero() bool {
	return v.Value.IsZero()
}

func (v *PasswordField) reset() {
	v.Label.reset()
	v.SupportingText.reset()
	v.ErrorText.reset()
	v.Value.reset()
	v.Frame.reset()
	v.InputValue.reset()
	v.Style.reset()
	v.DebounceTime.reset()
	v.Lines.reset()
	v.Disabled.reset()
	v.DisableAutocomplete.reset()
	v.DisableDebounce.reset()
	v.Invisible.reset()
	v.Revealed.reset()
	v.Id.reset()
	v.KeydownEnter.reset()
}

func (v *PasswordField) IsZero() bool {
	return v.Label.IsZero() && v.SupportingText.IsZero() && v.ErrorText.IsZero() && v.Value.IsZero() && v.Frame.IsZero() && v.InputValue.IsZero() && v.Style.IsZero() && v.DebounceTime.IsZero() && v.Lines.IsZero() && v.Disabled.IsZero() && v.DisableAutocomplete.IsZero() && v.DisableDebounce.IsZero() && v.Invisible.IsZero() && v.Revealed.IsZero() && v.Id.IsZero() && v.KeydownEnter.IsZero()
}

func (v *Ping) reset() {
}

func (v *Ping) IsZero() bool {
	return true
}

func (v *Radiobutton) reset() {
	v.InputValue.reset()
	v.Value.reset()
	v.Disabled.reset()
	v.Invisible.reset()
}

func (v *Radiobutton) IsZero() bool {
	return v.InputValue.IsZero() && v.Value.IsZero() && v.Disabled.IsZero() && v.Invisible.IsZero()
}

type ScaffoldMenuEntries []ScaffoldMenuEntry

func (v *ScaffoldMenuEntries) write(w *BinaryWriter) error {
	if err := w.writeUvarint(uint64(len(*v))); err != nil {
		return err
	}
	for _, item := range *v {
		if err := item.writeTypeHeader(w); err != nil {
			return err
		}
		if err := item.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *ScaffoldMenuEntries) read(r *BinaryReader) error {
	count, err := r.readUvarint()
	if err != nil {
		return err
	}

	slice := make([]ScaffoldMenuEntry, count)
	for i := uint64(0); i < count; i++ {
		obj, err := Unmarshal(r)
		if err != nil {
			return err
		}
		slice[i] = *obj.(*ScaffoldMenuEntry)
	}

	*v = slice
	return nil
}

func (v *ScaffoldMenuEntries) IsZero() bool {
	return v == nil || *v == nil || len(*v) == 0
}

func (v *ScaffoldMenuEntries) reset() {
	*v = nil
}

func (v *Scaffold) reset() {
	v.Body = nil
	v.Logo = nil
	v.Menu.reset()
	v.Alignment.reset()
}

func (v *Scaffold) IsZero() bool {
	return v.Body.IsZero() && v.Logo.IsZero() && v.Menu.IsZero() && v.Alignment.IsZero()
}

func (v *ScaffoldMenuEntry) reset() {
	v.Icon = nil
	v.IconActive = nil
	v.Title.reset()
	v.Action.reset()
	v.RootView.reset()
	v.Menu.reset()
	v.Badge.reset()
	v.Expanded.reset()
}

func (v *ScaffoldMenuEntry) IsZero() bool {
	return v.Icon.IsZero() && v.IconActive.IsZero() && v.Title.IsZero() && v.Action.IsZero() && v.RootView.IsZero() && v.Menu.IsZero() && v.Badge.IsZero() && v.Expanded.IsZero()
}

type ScopeID string

func (v *ScopeID) write(r *BinaryWriter) error {
	data := *(*[]byte)(unsafe.Pointer(v))
	if err := r.writeUvarint(uint64(len(data))); err != nil {
		return err
	}
	return r.write(data)
}

func (v *ScopeID) read(r *BinaryReader) error {
	strLen, err := r.readUvarint()
	if err != nil {
		return err
	}

	buf := make([]byte, strLen)

	if err := r.read(buf); err != nil {
		return err
	}

	*v = *(*ScopeID)(unsafe.Pointer(&buf))
	return nil
}

func (v *ScopeID) IsZero() bool {
	return len(*v) == 0
}

func (v *ScopeID) reset() {
	*v = ScopeID("")
}

func (v *ScopeDestructionRequested) reset() {
	v.RID.reset()
}

func (v *ScopeDestructionRequested) IsZero() bool {
	return v.RID.IsZero()
}

func (v *ScopeDestructionRequested) GetRID() RID {
	return v.RID
}
func (v *ScrollView) reset() {
	v.Content = nil
	v.Border.reset()
	v.Frame.reset()
	v.Padding.reset()
	v.BackgroundColor.reset()
	v.Axis.reset()
	v.Invisible.reset()
}

func (v *ScrollView) IsZero() bool {
	return v.Content.IsZero() && v.Border.IsZero() && v.Frame.IsZero() && v.Padding.IsZero() && v.BackgroundColor.IsZero() && v.Axis.IsZero() && v.Invisible.IsZero()
}

func (v *Resource) reset() {
	v.Name.reset()
	v.URI.reset()
	v.MimeType.reset()
}

func (v *Resource) IsZero() bool {
	return v.Name.IsZero() && v.URI.IsZero() && v.MimeType.IsZero()
}

type Resources []Resource

func (v *Resources) write(w *BinaryWriter) error {
	if err := w.writeUvarint(uint64(len(*v))); err != nil {
		return err
	}
	for _, item := range *v {
		if err := item.writeTypeHeader(w); err != nil {
			return err
		}
		if err := item.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *Resources) read(r *BinaryReader) error {
	count, err := r.readUvarint()
	if err != nil {
		return err
	}

	slice := make([]Resource, count)
	for i := uint64(0); i < count; i++ {
		obj, err := Unmarshal(r)
		if err != nil {
			return err
		}
		slice[i] = *obj.(*Resource)
	}

	*v = slice
	return nil
}

func (v *Resources) IsZero() bool {
	return v == nil || *v == nil || len(*v) == 0
}

func (v *Resources) reset() {
	*v = nil
}

func (v *SendMultipleRequested) reset() {
	v.Resources.reset()
}

func (v *SendMultipleRequested) IsZero() bool {
	return v.Resources.IsZero()
}

func (v *SessionAssigned) reset() {
	v.SessionID.reset()
}

func (v *SessionAssigned) IsZero() bool {
	return v.SessionID.IsZero()
}

func (v *Spacer) reset() {
	v.Frame.reset()
	v.Border.reset()
	v.BackgroundColor.reset()
}

func (v *Spacer) IsZero() bool {
	return v.Frame.IsZero() && v.Border.IsZero() && v.BackgroundColor.IsZero()
}

func (v *Table) reset() {
	v.Header.reset()
	v.Rows.reset()
	v.Frame.reset()
	v.BackgroundColor.reset()
	v.Border.reset()
	v.DefaultCellPadding.reset()
	v.RowDividerColor.reset()
	v.HeaderDividerColor.reset()
}

func (v *Table) IsZero() bool {
	return v.Header.IsZero() && v.Rows.IsZero() && v.Frame.IsZero() && v.BackgroundColor.IsZero() && v.Border.IsZero() && v.DefaultCellPadding.IsZero() && v.RowDividerColor.IsZero() && v.HeaderDividerColor.IsZero()
}

func (v *TableCell) reset() {
	v.Content = nil
	v.RowSpan.reset()
	v.ColSpan.reset()
	v.Alignment.reset()
	v.BackgroundColor.reset()
	v.HoveredBackgroundColor.reset()
	v.Padding.reset()
	v.Border.reset()
	v.Action.reset()
	v.Hovered.reset()
}

func (v *TableCell) IsZero() bool {
	return v.Content.IsZero() && v.RowSpan.IsZero() && v.ColSpan.IsZero() && v.Alignment.IsZero() && v.BackgroundColor.IsZero() && v.HoveredBackgroundColor.IsZero() && v.Padding.IsZero() && v.Border.IsZero() && v.Action.IsZero() && v.Hovered.IsZero()
}

func (v *TableColumn) reset() {
	v.Content = nil
	v.ColSpan.reset()
	v.Width.reset()
	v.Alignment.reset()
	v.CellBackgroundColor.reset()
	v.CellAction.reset()
	v.CellPadding.reset()
	v.CellBorder.reset()
	v.CellHoveredBackgroundColor.reset()
	v.CellHovered.reset()
}

func (v *TableColumn) IsZero() bool {
	return v.Content.IsZero() && v.ColSpan.IsZero() && v.Width.IsZero() && v.Alignment.IsZero() && v.CellBackgroundColor.IsZero() && v.CellAction.IsZero() && v.CellPadding.IsZero() && v.CellBorder.IsZero() && v.CellHoveredBackgroundColor.IsZero() && v.CellHovered.IsZero()
}

func (v *TableRow) reset() {
	v.Cells.reset()
	v.Height.reset()
	v.BackgroundColor.reset()
	v.HoveredBackgroundColor.reset()
	v.Action.reset()
	v.Hovered.reset()
}

func (v *TableRow) IsZero() bool {
	return v.Cells.IsZero() && v.Height.IsZero() && v.BackgroundColor.IsZero() && v.HoveredBackgroundColor.IsZero() && v.Action.IsZero() && v.Hovered.IsZero()
}

func (v *TableHeader) reset() {
	v.Columns.reset()
}

func (v *TableHeader) IsZero() bool {
	return v.Columns.IsZero()
}

type TableRows []TableRow

func (v *TableRows) write(w *BinaryWriter) error {
	if err := w.writeUvarint(uint64(len(*v))); err != nil {
		return err
	}
	for _, item := range *v {
		if err := item.writeTypeHeader(w); err != nil {
			return err
		}
		if err := item.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *TableRows) read(r *BinaryReader) error {
	count, err := r.readUvarint()
	if err != nil {
		return err
	}

	slice := make([]TableRow, count)
	for i := uint64(0); i < count; i++ {
		obj, err := Unmarshal(r)
		if err != nil {
			return err
		}
		slice[i] = *obj.(*TableRow)
	}

	*v = slice
	return nil
}

func (v *TableRows) IsZero() bool {
	return v == nil || *v == nil || len(*v) == 0
}

func (v *TableRows) reset() {
	*v = nil
}

type TableCells []TableCell

func (v *TableCells) write(w *BinaryWriter) error {
	if err := w.writeUvarint(uint64(len(*v))); err != nil {
		return err
	}
	for _, item := range *v {
		if err := item.writeTypeHeader(w); err != nil {
			return err
		}
		if err := item.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *TableCells) read(r *BinaryReader) error {
	count, err := r.readUvarint()
	if err != nil {
		return err
	}

	slice := make([]TableCell, count)
	for i := uint64(0); i < count; i++ {
		obj, err := Unmarshal(r)
		if err != nil {
			return err
		}
		slice[i] = *obj.(*TableCell)
	}

	*v = slice
	return nil
}

func (v *TableCells) IsZero() bool {
	return v == nil || *v == nil || len(*v) == 0
}

func (v *TableCells) reset() {
	*v = nil
}

type TableColumns []TableColumn

func (v *TableColumns) write(w *BinaryWriter) error {
	if err := w.writeUvarint(uint64(len(*v))); err != nil {
		return err
	}
	for _, item := range *v {
		if err := item.writeTypeHeader(w); err != nil {
			return err
		}
		if err := item.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *TableColumns) read(r *BinaryReader) error {
	count, err := r.readUvarint()
	if err != nil {
		return err
	}

	slice := make([]TableColumn, count)
	for i := uint64(0); i < count; i++ {
		obj, err := Unmarshal(r)
		if err != nil {
			return err
		}
		slice[i] = *obj.(*TableColumn)
	}

	*v = slice
	return nil
}

func (v *TableColumns) IsZero() bool {
	return v == nil || *v == nil || len(*v) == 0
}

func (v *TableColumns) reset() {
	*v = nil
}

func (v *TextView) reset() {
	v.Value.reset()
	v.Color.reset()
	v.BackgroundColor.reset()
	v.OnClick.reset()
	v.OnHoverStart.reset()
	v.OnHoverEnd.reset()
	v.Border.reset()
	v.Padding.reset()
	v.Frame.reset()
	v.AccessibilityLabel.reset()
	v.Font.reset()
	v.Action.reset()
	v.TextAlignment.reset()
	v.HoveredBackgroundColor.reset()
	v.PressedBackgroundColor.reset()
	v.FocusedBackgroundColor.reset()
	v.HoveredBorder.reset()
	v.PressedBorder.reset()
	v.FocusedBorder.reset()
	v.LineBreak.reset()
	v.Invisible.reset()
	v.Underline.reset()
}

func (v *TextView) IsZero() bool {
	return v.Value.IsZero() && v.Color.IsZero() && v.BackgroundColor.IsZero() && v.OnClick.IsZero() && v.OnHoverStart.IsZero() && v.OnHoverEnd.IsZero() && v.Border.IsZero() && v.Padding.IsZero() && v.Frame.IsZero() && v.AccessibilityLabel.IsZero() && v.Font.IsZero() && v.Action.IsZero() && v.TextAlignment.IsZero() && v.HoveredBackgroundColor.IsZero() && v.PressedBackgroundColor.IsZero() && v.FocusedBackgroundColor.IsZero() && v.HoveredBorder.IsZero() && v.PressedBorder.IsZero() && v.FocusedBorder.IsZero() && v.LineBreak.IsZero() && v.Invisible.IsZero() && v.Underline.IsZero()
}

func (v *TextField) reset() {
	v.Label.reset()
	v.SupportingText.reset()
	v.ErrorText.reset()
	v.Value.reset()
	v.Frame.reset()
	v.InputValue.reset()
	v.Style.reset()
	v.Leading = nil
	v.Trailing = nil
	v.DebounceTime.reset()
	v.Lines.reset()
	v.KeyboardOptions.reset()
	v.Disabled.reset()
	v.DisableAutocomplete.reset()
	v.DisableDebounce.reset()
	v.Invisible.reset()
	v.Revealed.reset()
	v.Id.reset()
	v.KeydownEnter.reset()
}

func (v *TextField) IsZero() bool {
	return v.Label.IsZero() && v.SupportingText.IsZero() && v.ErrorText.IsZero() && v.Value.IsZero() && v.Frame.IsZero() && v.InputValue.IsZero() && v.Style.IsZero() && v.Leading.IsZero() && v.Trailing.IsZero() && v.DebounceTime.IsZero() && v.Lines.IsZero() && v.KeyboardOptions.IsZero() && v.Disabled.IsZero() && v.DisableAutocomplete.IsZero() && v.DisableDebounce.IsZero() && v.Invisible.IsZero() && v.Revealed.IsZero() && v.Id.IsZero() && v.KeydownEnter.IsZero()
}

func (v *Toggle) reset() {
	v.InputValue.reset()
	v.Value.reset()
	v.Disabled.reset()
	v.Invisible.reset()
}

func (v *Toggle) IsZero() bool {
	return v.InputValue.IsZero() && v.Value.IsZero() && v.Disabled.IsZero() && v.Invisible.IsZero()
}

func (v *TextLayout) reset() {
	v.Children.reset()
	v.Border.reset()
	v.Frame.reset()
	v.BackgroundColor.reset()
	v.Padding.reset()
	v.AccessibilityLabel.reset()
	v.Font.reset()
	v.Action.reset()
	v.TextAlignment.reset()
	v.Invisible.reset()
}

func (v *TextLayout) IsZero() bool {
	return v.Children.IsZero() && v.Border.IsZero() && v.Frame.IsZero() && v.BackgroundColor.IsZero() && v.Padding.IsZero() && v.AccessibilityLabel.IsZero() && v.Font.IsZero() && v.Action.IsZero() && v.TextAlignment.IsZero() && v.Invisible.IsZero()
}

func (v *VStack) reset() {
	v.Children.reset()
	v.Gap.reset()
	v.Frame.reset()
	v.Alignment.reset()
	v.BackgroundColor.reset()
	v.Padding.reset()
	v.AccessibilityLabel.reset()
	v.Border.reset()
	v.Font.reset()
	v.Action.reset()
	v.HoveredBackgroundColor.reset()
	v.PressedBackgroundColor.reset()
	v.FocusedBackgroundColor.reset()
	v.HoveredBorder.reset()
	v.PressedBorder.reset()
	v.FocusedBorder.reset()
	v.StylePreset.reset()
	v.Position.reset()
	v.Disabled.reset()
	v.Invisible.reset()
	v.Id.reset()
}

func (v *VStack) IsZero() bool {
	return v.Children.IsZero() && v.Gap.IsZero() && v.Frame.IsZero() && v.Alignment.IsZero() && v.BackgroundColor.IsZero() && v.Padding.IsZero() && v.AccessibilityLabel.IsZero() && v.Border.IsZero() && v.Font.IsZero() && v.Action.IsZero() && v.HoveredBackgroundColor.IsZero() && v.PressedBackgroundColor.IsZero() && v.FocusedBackgroundColor.IsZero() && v.HoveredBorder.IsZero() && v.PressedBorder.IsZero() && v.FocusedBorder.IsZero() && v.StylePreset.IsZero() && v.Position.IsZero() && v.Disabled.IsZero() && v.Invisible.IsZero() && v.Id.IsZero()
}

func (v *WebView) reset() {
	v.URI.reset()
	v.Frame.reset()
}

func (v *WebView) IsZero() bool {
	return v.URI.IsZero() && v.Frame.IsZero()
}

func (v *WindowInfoChanged) reset() {
	v.WindowInfo.reset()
	v.RID.reset()
}

func (v *WindowInfoChanged) IsZero() bool {
	return v.WindowInfo.IsZero() && v.RID.IsZero()
}

func (v *WindowInfoChanged) GetRID() RID {
	return v.RID
}
func (v *UpdateStateValues2Requested) reset() {
	v.StatePtr0.reset()
	v.Value0.reset()
	v.StatePtr1.reset()
	v.Value1.reset()
	v.FunctionPointer.reset()
	v.RID.reset()
}

func (v *UpdateStateValues2Requested) IsZero() bool {
	return v.StatePtr0.IsZero() && v.Value0.IsZero() && v.StatePtr1.IsZero() && v.Value1.IsZero() && v.FunctionPointer.IsZero() && v.RID.IsZero()
}

func (v *UpdateStateValues2Requested) GetRID() RID {
	return v.RID
}
func (v *OpenHttpLink) reset() {
	v.Url.reset()
	v.Target.reset()
}

func (v *OpenHttpLink) IsZero() bool {
	return v.Url.IsZero() && v.Target.IsZero()
}

func (v *OpenHttpFlow) reset() {
	v.Url.reset()
	v.RedirectTarget.reset()
	v.RedirectNavigation.reset()
	v.Session.reset()
}

func (v *OpenHttpFlow) IsZero() bool {
	return v.Url.IsZero() && v.RedirectTarget.IsZero() && v.RedirectNavigation.IsZero() && v.Session.IsZero()
}

func (v *ClipboardWriteTextRequested) reset() {
	v.Text.reset()
}

func (v *ClipboardWriteTextRequested) IsZero() bool {
	return v.Text.IsZero()
}

func (v *Menu) reset() {
	v.Anchor = nil
	v.Groups.reset()
	v.Frame.reset()
}

func (v *Menu) IsZero() bool {
	return v.Anchor.IsZero() && v.Groups.IsZero() && v.Frame.IsZero()
}

func (v *MenuGroup) reset() {
	v.Items.reset()
}

func (v *MenuGroup) IsZero() bool {
	return v.Items.IsZero()
}

func (v *MenuItem) reset() {
	v.Action.reset()
	v.Content = nil
}

func (v *MenuItem) IsZero() bool {
	return v.Action.IsZero() && v.Content.IsZero()
}

// MenuItems is just a bunch of menu items which belong together.
type MenuItems []MenuItem

func (v *MenuItems) write(w *BinaryWriter) error {
	if err := w.writeUvarint(uint64(len(*v))); err != nil {
		return err
	}
	for _, item := range *v {
		if err := item.writeTypeHeader(w); err != nil {
			return err
		}
		if err := item.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *MenuItems) read(r *BinaryReader) error {
	count, err := r.readUvarint()
	if err != nil {
		return err
	}

	slice := make([]MenuItem, count)
	for i := uint64(0); i < count; i++ {
		obj, err := Unmarshal(r)
		if err != nil {
			return err
		}
		slice[i] = *obj.(*MenuItem)
	}

	*v = slice
	return nil
}

func (v *MenuItems) IsZero() bool {
	return v == nil || *v == nil || len(*v) == 0
}

func (v *MenuItems) reset() {
	*v = nil
}

// MenuGroups is just a bunch of groups.
type MenuGroups []MenuGroup

func (v *MenuGroups) write(w *BinaryWriter) error {
	if err := w.writeUvarint(uint64(len(*v))); err != nil {
		return err
	}
	for _, item := range *v {
		if err := item.writeTypeHeader(w); err != nil {
			return err
		}
		if err := item.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *MenuGroups) read(r *BinaryReader) error {
	count, err := r.readUvarint()
	if err != nil {
		return err
	}

	slice := make([]MenuGroup, count)
	for i := uint64(0); i < count; i++ {
		obj, err := Unmarshal(r)
		if err != nil {
			return err
		}
		slice[i] = *obj.(*MenuGroup)
	}

	*v = slice
	return nil
}

func (v *MenuGroups) IsZero() bool {
	return v == nil || *v == nil || len(*v) == 0
}

func (v *MenuGroups) reset() {
	*v = nil
}

func (v *Form) reset() {
	v.Children.reset()
	v.Action.reset()
	v.Id.reset()
	v.Autocomplete.reset()
	v.Frame.reset()
}

func (v *Form) IsZero() bool {
	return v.Children.IsZero() && v.Action.IsZero() && v.Id.IsZero() && v.Autocomplete.IsZero() && v.Frame.IsZero()
}

func (v *CountDown) reset() {
	v.Action.reset()
	v.Duration.reset()
	v.ShowDays.reset()
	v.ShowHours.reset()
	v.ShowMinutes.reset()
	v.ShowSeconds.reset()
	v.Frame.reset()
	v.TextColor.reset()
	v.SeparatorColor.reset()
}

func (v *CountDown) IsZero() bool {
	return v.Action.IsZero() && v.Duration.IsZero() && v.ShowDays.IsZero() && v.ShowHours.IsZero() && v.ShowMinutes.IsZero() && v.ShowSeconds.IsZero() && v.Frame.IsZero() && v.TextColor.IsZero() && v.SeparatorColor.IsZero()
}

func (v *CodeEditor) reset() {
	v.Value.reset()
	v.Frame.reset()
	v.ReadOnly.reset()
	v.Disabled.reset()
	v.TabSize.reset()
	v.InputValue.reset()
	v.Language.reset()
}

func (v *CodeEditor) IsZero() bool {
	return v.Value.IsZero() && v.Frame.IsZero() && v.ReadOnly.IsZero() && v.Disabled.IsZero() && v.TabSize.IsZero() && v.InputValue.IsZero() && v.Language.IsZero()
}

func (v *Box) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 1); err != nil {
		return err
	}
	return nil
}

func (v *Ptr) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 2); err != nil {
		return err
	}
	return nil
}

func (v *UpdateStateValueRequested) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 3); err != nil {
		return err
	}
	return nil
}

func (v *FunctionCallRequested) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 4); err != nil {
		return err
	}
	return nil
}

func (v *Alignment) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 5); err != nil {
		return err
	}
	return nil
}

func (v *Color) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(byteSlice, 6); err != nil {
		return err
	}
	return nil
}

func (v *Shadow) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 7); err != nil {
		return err
	}
	return nil
}

func (v *Length) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(byteSlice, 8); err != nil {
		return err
	}
	return nil
}

func (v *Border) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 9); err != nil {
		return err
	}
	return nil
}

func (v *Frame) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 10); err != nil {
		return err
	}
	return nil
}

func (v *Padding) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 11); err != nil {
		return err
	}
	return nil
}

func (v *AlignedComponent) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 12); err != nil {
		return err
	}
	return nil
}

func (v *Components) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(array, 13); err != nil {
		return err
	}
	return nil
}

func (v *AlignedComponents) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(array, 14); err != nil {
		return err
	}
	return nil
}

func (v *Checkbox) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 15); err != nil {
		return err
	}
	return nil
}

func (v *Bool) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 16); err != nil {
		return err
	}
	return nil
}

func (v *ErrorOccurred) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 17); err != nil {
		return err
	}
	return nil
}

func (v *Locale) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(byteSlice, 18); err != nil {
		return err
	}
	return nil
}

func (v *FontStyle) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 19); err != nil {
		return err
	}
	return nil
}

func (v *RootViewID) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(byteSlice, 20); err != nil {
		return err
	}
	return nil
}

func (v *RootViewParameters) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(array, 21); err != nil {
		return err
	}
	return nil
}

func (v *Str) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(byteSlice, 22); err != nil {
		return err
	}
	return nil
}

func (v *RootViewRenderingRequested) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 23); err != nil {
		return err
	}
	return nil
}

func (v *RootViewDestructionRequested) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 24); err != nil {
		return err
	}
	return nil
}

func (v *RootViewInvalidated) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 25); err != nil {
		return err
	}
	return nil
}

func (v *ErrorRootViewAllocationRequired) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 26); err != nil {
		return err
	}
	return nil
}

func (v *RootViewAllocationRequested) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 27); err != nil {
		return err
	}
	return nil
}

func (v *WindowSizeClass) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 28); err != nil {
		return err
	}
	return nil
}

func (v *ScopeConfigurationChangeRequested) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 29); err != nil {
		return err
	}
	return nil
}

func (v *ColorScheme) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 30); err != nil {
		return err
	}
	return nil
}

func (v *WindowInfo) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 31); err != nil {
		return err
	}
	return nil
}

func (v *DP) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(f64, 32); err != nil {
		return err
	}
	return nil
}

func (v *Density) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(f64, 33); err != nil {
		return err
	}
	return nil
}

func (v *ScopeConfigurationChanged) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 34); err != nil {
		return err
	}
	return nil
}

func (v *Locales) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(array, 35); err != nil {
		return err
	}
	return nil
}

func (v *URI) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(byteSlice, 36); err != nil {
		return err
	}
	return nil
}

func (v *NamespaceName) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(byteSlice, 37); err != nil {
		return err
	}
	return nil
}

func (v *NamedColors) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(array, 38); err != nil {
		return err
	}
	return nil
}

func (v *Theme) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 39); err != nil {
		return err
	}
	return nil
}

func (v *NamespacedColors) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(array, 40); err != nil {
		return err
	}
	return nil
}

func (v *NamedLengths) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(array, 41); err != nil {
		return err
	}
	return nil
}

func (v *Themes) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 42); err != nil {
		return err
	}
	return nil
}

func (v *DatePickerStyle) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 43); err != nil {
		return err
	}
	return nil
}

func (v *Day) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 44); err != nil {
		return err
	}
	return nil
}

func (v *DateData) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 45); err != nil {
		return err
	}
	return nil
}

func (v *Month) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 46); err != nil {
		return err
	}
	return nil
}

func (v *Year) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 47); err != nil {
		return err
	}
	return nil
}

func (v *DatePicker) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 48); err != nil {
		return err
	}
	return nil
}

func (v *Divider) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 49); err != nil {
		return err
	}
	return nil
}

func (v *RID) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 50); err != nil {
		return err
	}
	return nil
}

func (v *FontWeight) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 51); err != nil {
		return err
	}
	return nil
}

func (v *Font) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 52); err != nil {
		return err
	}
	return nil
}

func (v *Grid) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 53); err != nil {
		return err
	}
	return nil
}

func (v *Uint) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 54); err != nil {
		return err
	}
	return nil
}

func (v *GridCells) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(array, 55); err != nil {
		return err
	}
	return nil
}

func (v *Lengths) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(array, 56); err != nil {
		return err
	}
	return nil
}

func (v *GridCell) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 57); err != nil {
		return err
	}
	return nil
}

func (v *HStack) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 58); err != nil {
		return err
	}
	return nil
}

func (v *StylePreset) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 59); err != nil {
		return err
	}
	return nil
}

func (v *Position) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 60); err != nil {
		return err
	}
	return nil
}

func (v *PositionType) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 61); err != nil {
		return err
	}
	return nil
}

func (v *Img) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 62); err != nil {
		return err
	}
	return nil
}

func (v *SVG) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(byteSlice, 63); err != nil {
		return err
	}
	return nil
}

func (v *Strings) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(array, 64); err != nil {
		return err
	}
	return nil
}

func (v *FileImportRequested) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 65); err != nil {
		return err
	}
	return nil
}

func (v *KeyboardOptions) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 66); err != nil {
		return err
	}
	return nil
}

func (v *KeyboardType) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 67); err != nil {
		return err
	}
	return nil
}

func (v *ModalType) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 68); err != nil {
		return err
	}
	return nil
}

func (v *Modal) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 69); err != nil {
		return err
	}
	return nil
}

func (v *ThemeRequested) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 70); err != nil {
		return err
	}
	return nil
}

func (v *NavigationForwardToRequested) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 71); err != nil {
		return err
	}
	return nil
}

func (v *NavigationResetRequested) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 72); err != nil {
		return err
	}
	return nil
}

func (v *NavigationBackRequested) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 73); err != nil {
		return err
	}
	return nil
}

func (v *NavigationReloadRequested) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 74); err != nil {
		return err
	}
	return nil
}

func (v *ThemeID) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(byteSlice, 75); err != nil {
		return err
	}
	return nil
}

func (v *WindowTitle) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 77); err != nil {
		return err
	}
	return nil
}

func (v *Duration) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 78); err != nil {
		return err
	}
	return nil
}

func (v *PasswordField) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 79); err != nil {
		return err
	}
	return nil
}

func (v *TextFieldStyle) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 80); err != nil {
		return err
	}
	return nil
}

func (v *Ping) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 81); err != nil {
		return err
	}
	return nil
}

func (v *Radiobutton) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 82); err != nil {
		return err
	}
	return nil
}

func (v *ScaffoldAlignment) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 83); err != nil {
		return err
	}
	return nil
}

func (v *ScaffoldMenuEntries) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(array, 84); err != nil {
		return err
	}
	return nil
}

func (v *Scaffold) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 85); err != nil {
		return err
	}
	return nil
}

func (v *ScaffoldMenuEntry) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 86); err != nil {
		return err
	}
	return nil
}

func (v *ScopeID) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(byteSlice, 87); err != nil {
		return err
	}
	return nil
}

func (v *ScopeDestructionRequested) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 88); err != nil {
		return err
	}
	return nil
}

func (v *ScrollViewAxis) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 89); err != nil {
		return err
	}
	return nil
}

func (v *ScrollView) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 90); err != nil {
		return err
	}
	return nil
}

func (v *Resource) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 91); err != nil {
		return err
	}
	return nil
}

func (v *Resources) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(array, 92); err != nil {
		return err
	}
	return nil
}

func (v *SendMultipleRequested) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 93); err != nil {
		return err
	}
	return nil
}

func (v *SessionAssigned) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 94); err != nil {
		return err
	}
	return nil
}

func (v *Spacer) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 95); err != nil {
		return err
	}
	return nil
}

func (v *Table) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 96); err != nil {
		return err
	}
	return nil
}

func (v *TableCell) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 97); err != nil {
		return err
	}
	return nil
}

func (v *TableColumn) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 98); err != nil {
		return err
	}
	return nil
}

func (v *TableRow) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 99); err != nil {
		return err
	}
	return nil
}

func (v *TableHeader) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 100); err != nil {
		return err
	}
	return nil
}

func (v *TableRows) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(array, 101); err != nil {
		return err
	}
	return nil
}

func (v *TableCells) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(array, 102); err != nil {
		return err
	}
	return nil
}

func (v *TableColumns) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(array, 103); err != nil {
		return err
	}
	return nil
}

func (v *TextView) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 104); err != nil {
		return err
	}
	return nil
}

func (v *TextAlignment) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 105); err != nil {
		return err
	}
	return nil
}

func (v *TextField) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 106); err != nil {
		return err
	}
	return nil
}

func (v *Toggle) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 107); err != nil {
		return err
	}
	return nil
}

func (v *TextLayout) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 108); err != nil {
		return err
	}
	return nil
}

func (v *VStack) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 109); err != nil {
		return err
	}
	return nil
}

func (v *WebView) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 110); err != nil {
		return err
	}
	return nil
}

func (v *WindowInfoChanged) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 111); err != nil {
		return err
	}
	return nil
}

func (v *UpdateStateValues2Requested) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 112); err != nil {
		return err
	}
	return nil
}

func (v *OpenHttpLink) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 113); err != nil {
		return err
	}
	return nil
}

func (v *OpenHttpFlow) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 114); err != nil {
		return err
	}
	return nil
}

func (v *ClipboardWriteTextRequested) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 115); err != nil {
		return err
	}
	return nil
}

func (v *Menu) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 116); err != nil {
		return err
	}
	return nil
}

func (v *MenuGroup) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 117); err != nil {
		return err
	}
	return nil
}

func (v *MenuItem) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 118); err != nil {
		return err
	}
	return nil
}

func (v *MenuItems) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(array, 119); err != nil {
		return err
	}
	return nil
}

func (v *MenuGroups) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(array, 120); err != nil {
		return err
	}
	return nil
}

func (v *Form) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 121); err != nil {
		return err
	}
	return nil
}

func (v *CountDown) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 122); err != nil {
		return err
	}
	return nil
}

func (v *DurationSec) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(uvarint, 123); err != nil {
		return err
	}
	return nil
}

func (v *CodeEditor) writeTypeHeader(w *BinaryWriter) error {
	if err := w.writeTypeHeader(record, 124); err != nil {
		return err
	}
	return nil
}
