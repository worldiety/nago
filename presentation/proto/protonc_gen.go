// Code generated by NAGO nprotoc DO NOT EDIT.

package proto

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"unsafe"
)

type BinaryWriter struct {
	writer *bytes.Buffer
	tmp    [32]byte
}

func NewBinaryWriter(writer *bytes.Buffer) *BinaryWriter {
	return &BinaryWriter{
		writer: writer,
	}
}

func (w *BinaryWriter) write(p []byte) error {
	_, err := w.writer.Write(p)
	return err
}

func (w *BinaryWriter) writeBool(b bool) {

	if b {
		w.tmp[0] = 1
	} else {
		w.tmp[0] = 0
	}

	w.write(w.tmp[0:1])
}

func (w *BinaryWriter) writeVarint(i int64) {
	n := binary.PutVarint(w.tmp[:], i)
	w.write(w.tmp[0:n])
}

func (w *BinaryWriter) writeUvarint(i uint64) error {
	n := binary.PutUvarint(w.tmp[:], i)
	w.write(w.tmp[0:n])
	return nil
}

func (w *BinaryWriter) writeByte(b byte) error {
	return w.writer.WriteByte(b)
}

func (w *BinaryWriter) writeFieldHeader(shape shape, id fieldId) error {
	return w.writeByte(fieldHeader{
		shape:   shape,
		fieldId: id,
	}.asValue())
}

func (w *BinaryWriter) writeTypeHeader(shape shape, id typeId) error {
	if err := w.writeFieldHeader(shape, 0); err != nil {
		return err
	}

	return w.writeUvarint(uint64(id))
}

func (w *BinaryWriter) writeSlice(s []byte) error {
	n := len(s)
	if err := w.writeUvarint(uint64(n)); err != nil {
		return err
	}
	w.write(s)

	return nil
}

type BinaryReader struct {
	reader *bytes.Buffer
	tmp    [32]byte
}

func NewBinaryReader(reader *bytes.Buffer) *BinaryReader {
	return &BinaryReader{
		reader: reader,
	}
}

func (r *BinaryReader) read(b []byte) error {
	n, err := r.reader.Read(b)
	if err != nil {
		return err
	}

	if n != len(b) {
		return fmt.Errorf("short read")
	}

	return nil
}

func (r *BinaryReader) readByte() (byte, error) {
	return r.reader.ReadByte()
}

func (r *BinaryReader) readFieldHeader() (fieldHeader, error) {
	b, err := r.reader.ReadByte()
	if err != nil {
		return fieldHeader{}, err
	}

	return parseFieldHeader(b), nil
}

func (r *BinaryReader) readTypeHeader() (shape, typeId, error) {
	h, err := r.readFieldHeader()
	if err != nil {
		return 0, 0, fmt.Errorf("failed to read type header: %w", err)
	}

	if h.isField() {
		return 0, 0, fmt.Errorf("nprotoc: expected a type header but got a field header")
	}

	tid, err := r.readUvarint()
	if err != nil {
		return 0, 0, fmt.Errorf("failed to read type id header: %w", err)
	}

	return h.shape, typeId(tid), nil
}

func (r *BinaryReader) readUvarint() (uint64, error) {
	return binary.ReadUvarint(r.reader)
}

type shape uint8

func (s shape) String() string {
	switch s {
	case f32:
		return "f32"
	case f64:
		return "f64"
	case envelope:
		return "envelope"
	case uvarint:
		return "uvarint"
	case varint:
		return "varint"
	case byteSlice:
		return "byteSlice"
	case record:
		return "record"
	case array:
		return "array"
	}

	panic(fmt.Sprintf("unknown shape: %d", s))
}

const (
	envelope = shape(iota)
	uvarint
	varint
	byteSlice
	record
	f32
	f64
	array
)

type fieldId uint

type fieldHeader struct {
	shape   shape
	fieldId fieldId
}

func (f fieldHeader) isField() bool {
	return f.fieldId != 0
}

func (f fieldHeader) asValue() uint8 {
	return uint8(((int(f.shape)) << 5) | ((int(f.fieldId)) & 0b00011111))
}

func parseFieldHeader(value uint8) fieldHeader {
	return fieldHeader{
		shape:   shape((value >> 5) & 0b00000111),
		fieldId: fieldId(value & 0b00011111),
	}
}

type typeId uint

type typeHeader struct {
	shape   shape
	fieldId fieldId
	typeId  typeId
}

func (f typeHeader) isType() bool {
	return f.fieldId == 0
}

func parseTypeHeader(value uint8) fieldHeader {
	return fieldHeader{
		shape:   shape((value >> 5) & 0b00000111),
		fieldId: fieldId(value & 0b00011111),
	}
}

// NagoEvent is the union type of all allowed NAGO protocol events. Everything which goes through a NAGO channel must be an Event at the root level.
type NagoEvent interface {
	// a marker method to indicate the enum / union type membership
	isNagoEvent()
}

func (UpdateStateValueRequested) isNagoEvent() {}
func (FunctionCallRequested) isNagoEvent()     {}

// Ptr represents an allocated instance within the backend which is unique in the associated scope.
type Ptr uint64

const (
	// Null represents the zero value and a nil or null pointer address.
	Null = 0
)

func (v *Ptr) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *Ptr) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = Ptr(tmp)
	return nil
}

func (v *Ptr) reset() {
	*v = Ptr(0)
}
func (v *Ptr) IsZero() bool {
	return *v == 0
}

// UpdateStateValueRequested is raised from the frontend to update a state value hold by the backend. It can also immediately invoke a function callback in the same cycle.
type UpdateStateValueRequested struct {
	// The StatePointer must not be zero.
	StatePointer Ptr
	// A FunctionPointer is invoked, if not zero.
	FunctionPointer Ptr
}

func (v *UpdateStateValueRequested) write(w *BinaryWriter) error {
	var fields [3]bool
	fields[1] = !v.StatePointer.IsZero()
	fields[2] = !v.FunctionPointer.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(uvarint, 1); err != nil {
			return err
		}
		if err := v.StatePointer.write(w); err != nil {
			return err
		}
	}
	if fields[2] {
		if err := w.writeFieldHeader(uvarint, 2); err != nil {
			return err
		}
		if err := v.FunctionPointer.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *UpdateStateValueRequested) read(r *BinaryReader) error {
	v.StatePointer.reset()
	v.FunctionPointer.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.StatePointer.read(r)
			if err != nil {
				return err
			}
		case 2:
			err := v.FunctionPointer.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (v *UpdateStateValueRequested) IsZero() bool {
	return *v == (UpdateStateValueRequested{})
}

// FunctionCallRequested tells the backend that the given pointer in the associated scope shall be invoked for a side effect.
type FunctionCallRequested struct {
	// Ptr denotes the remote pointer of the function.
	Ptr Ptr
}

func (v *FunctionCallRequested) write(w *BinaryWriter) error {
	var fields [2]bool
	fields[1] = !v.Ptr.IsZero()

	fieldCount := byte(0)
	for _, present := range fields {
		if present {
			fieldCount++
		}
	}
	if err := w.writeByte(fieldCount); err != nil {
		return err
	}
	if fields[1] {
		if err := w.writeFieldHeader(uvarint, 1); err != nil {
			return err
		}
		if err := v.Ptr.write(w); err != nil {
			return err
		}
	}
	return nil
}

func (v *FunctionCallRequested) read(r *BinaryReader) error {
	v.Ptr.reset()
	fieldCount, err := r.readByte()
	if err != nil {
		return err
	}
	for range fieldCount {
		fh, err := r.readFieldHeader()
		if err != nil {
			return err
		}
		switch fh.fieldId {
		case 1:
			err := v.Ptr.read(r)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (v *FunctionCallRequested) IsZero() bool {
	return *v == (FunctionCallRequested{})
}

// Alignment is specified as follows:
//
//	┌─TopLeading───────────Top─────────TopTrailing─┐
//	│                                              │
//	│                                              │
//	│                                              │
//	│                                              │
//	│                                              │
//	│                                              │
//	│                                              │
//	│ Leading            Center            Trailing│
//	│                                              │
//	│                                              │
//	│                                              │
//	│                                              │
//	│                                              │
//	│                                              │
//	│                                              │
//	└BottomLeading───────Bottom──────BottomTrailing┘
//
// An empty Alignment must be interpreted as Center (="c").
type Alignment uint64

const (
	Center         = 0
	Top            = 1
	Bottom         = 2
	Leading        = 3
	Trailing       = 4
	TopLeading     = 5
	TopTrailing    = 6
	BottomLeading  = 7
	BottomTrailing = 8
)

func (v *Alignment) write(r *BinaryWriter) error {
	return r.writeUvarint(uint64(*v))
}

func (v *Alignment) read(r *BinaryReader) error {
	tmp, err := r.readUvarint()
	if err != nil {
		return err
	}
	*v = Alignment(tmp)
	return nil
}

func (v *Alignment) reset() {
	*v = Alignment(0)
}
func (v *Alignment) IsZero() bool {
	return *v == 0
}

type Writeable interface {
	write(*BinaryWriter) error
}

func Marshal(dst *BinaryWriter, src Writeable) error {
	switch src := src.(type) {
	case *Ptr:
		if err := dst.writeTypeHeader(uvarint, 2); err != nil {
			return err
		}
		return src.write(dst)
	case *UpdateStateValueRequested:
		if err := dst.writeTypeHeader(record, 3); err != nil {
			return err
		}
		return src.write(dst)
	case *FunctionCallRequested:
		if err := dst.writeTypeHeader(record, 4); err != nil {
			return err
		}
		return src.write(dst)
	case *Alignment:
		if err := dst.writeTypeHeader(uvarint, 5); err != nil {
			return err
		}
		return src.write(dst)
	case *Color:
		if err := dst.writeTypeHeader(byteSlice, 6); err != nil {
			return err
		}
		return src.write(dst)
	default:
		return fmt.Errorf("unknown type in marshal: %T", src)
	}
	return nil
}

type Readable interface {
	read(*BinaryReader) error
}

func Unmarshal(src *BinaryReader) (Readable, error) {
	_, tid, err := src.readTypeHeader()
	if err != nil {
		return nil, err
	}
	switch tid {
	case 2:
		var v Ptr
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 3:
		var v UpdateStateValueRequested
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 4:
		var v FunctionCallRequested
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 5:
		var v Alignment
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	case 6:
		var v Color
		if err := v.read(src); err != nil {
			return nil, err
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unknown type in marshal: %d", tid)
	}

}

// Color specifies either a hex color like #rrggbb or #rrggbbaa or an internal custom color name.
type Color string

func (v *Color) write(r *BinaryWriter) error {
	data := *(*[]byte)(unsafe.Pointer(v))
	if err := r.writeUvarint(uint64(len(data))); err != nil {
		return err
	}
	return r.write(data)
}

func (v *Color) read(r *BinaryReader) error {
	strLen, err := r.readUvarint()
	if err != nil {
		return err
	}

	buf := make([]byte, strLen)

	if err := r.read(buf); err != nil {
		return err
	}

	*v = *(*Color)(unsafe.Pointer(&buf))
	return nil
}
