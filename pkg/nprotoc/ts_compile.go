package nprotoc

import (
	_ "embed"
	"fmt"
	"strings"
	"unicode"
)

//go:embed ts_binary.ts
var tsStub string

func (c *Compiler) GenerateTS() ([]byte, error) {
	c.pn("// Code generated by NAGO nprotoc DO NOT EDIT.\n\n")
	c.p(tsStub)
	for typename, decl := range c.sortedDecl() {
		switch decl := decl.(type) {
		case Uint:
			c.tsEmitUint(typename, decl)
		case Enum:
			c.tsEmitEnum(typename, decl)
		case Record:
			if err := c.tsEmitRecord(typename, decl); err != nil {
				return nil, err
			}
		}

	}

	if err := c.tsEmitMarshal(); err != nil {
		return nil, err
	}

	if err := c.tsEmitUnmarshal(); err != nil {
		return nil, err
	}

	return c.buf.Bytes(), nil
}

// returns either empty string or "implements A,B,C"
func (c *Compiler) tsImplements(typename Typename) string {
	var tmp strings.Builder
	for i, s := range c.implements(typename) {
		tmp.WriteString(string(s))
		if i != len(c.implements(typename))-1 {
			tmp.WriteString(",")
		}
	}

	if tmp.Len() == 0 {
		return ""
	}

	return "implements " + tmp.String() + " "
}

// returns either empty string or lines like
// isA(): void {}
func (c *Compiler) tsMarkerMethods(typename Typename) []string {
	var res []string
	for _, s := range c.implements(typename) {
		res = append(res, fmt.Sprintf("is%s(): void{}", s))
	}

	return res
}

func tsFieldName(str string) string {
	if str == "" {
		return ""
	}

	var buf strings.Builder
	for i, r := range str {
		if i == 0 {
			buf.WriteRune(unicode.ToLower(r))
		} else {
			buf.WriteRune(r)
		}
	}

	return buf.String()
}
