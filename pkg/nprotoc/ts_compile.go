package nprotoc

import (
	_ "embed"
	"fmt"
	"strings"
	"unicode"
)

//go:embed ts_binary.ts
var tsStub string

func (c *Compiler) GenerateTS() ([]byte, error) {
	c.pn("// Code generated by NAGO nprotoc DO NOT EDIT.\n\n")
	c.p(tsStub)
	for typename, decl := range c.sortedDecl() {
		switch decl := decl.(type) {
		case Uint:
			if err := c.tsEmitUint(typename, decl); err != nil {
				return nil, err
			}
		case Enum:
			c.tsEmitEnum(typename, decl)
		case String:
			if err := c.tsEmitString(typename, decl); err != nil {
				return nil, err
			}
		case Record:
			if err := c.tsEmitRecord(typename, decl); err != nil {
				return nil, err
			}
		case Array:
			if err := c.tsEmitArray(typename, decl); err != nil {
				return nil, err
			}
		}

	}

	if err := c.tsEmitMarshal(); err != nil {
		return nil, err
	}

	if err := c.tsEmitUnmarshal(); err != nil {
		return nil, err
	}

	return c.buf.Bytes(), nil
}

// returns either empty string or "implements A,B,C"
func (c *Compiler) tsImplements(typename Typename) string {
	var tmp strings.Builder
	for i, s := range c.implements(typename) {
		tmp.WriteString(string(s))
		if i != len(c.implements(typename))-1 {
			tmp.WriteString(",")
		}
	}

	t := "implements Writeable, Readable "
	if tmp.Len() == 0 {
		return t
	}

	return t + ", " + tmp.String() + " "
}

// returns either empty string or lines like
// isA(): void {}
func (c *Compiler) tsMarkerMethods(typename Typename) []string {
	var res []string
	for _, s := range c.implements(typename) {
		res = append(res, fmt.Sprintf("is%s(): void{}", s))
	}

	return res
}

func tsFieldName(str string) string {
	if str == "" {
		return ""
	}

	var buf strings.Builder
	for i, r := range str {
		if i == 0 {
			buf.WriteRune(unicode.ToLower(r))
		} else {
			buf.WriteRune(r)
		}
	}

	return buf.String()
}

func (c *Compiler) tsCanBeUndefined(t Typename) bool {
	sh, err := c.shapeOf(t)
	if err != nil {
		return false
	}

	return sh == xobjectAsArray
}

func (c *Compiler) tsEmitWriteTypeHeader(t Typename) error {
	sh, err := c.shapeOf(t)
	if err != nil {
		return err
	}

	decl, ok := c.declr[t]
	if !ok {
		return fmt.Errorf("type %s is not declared", t)
	}

	idDecl, ok := decl.(IdentityTypeDeclaration)
	if !ok {
		return fmt.Errorf("type %s is an ID type declaration and cannot be used in this context", t)
	}

	c.pn("writeTypeHeader(dst: BinaryWriter): void {")
	c.inc()

	c.pf("dst.writeTypeHeader(Shapes.%s, %d);\n", strings.ToUpper(sh.String()), idDecl.ID())
	c.pn("return")
	c.dec()
	c.pn("}")

	return nil
}
