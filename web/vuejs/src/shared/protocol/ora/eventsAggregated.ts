/**
 * Code generated by github.com/worldiety/macro. DO NOT EDIT.
 */


import type { Event } from '@/shared/protocol/ora/event';
import type { EventType } from '@/shared/protocol/ora/eventType';
import type { RequestId } from '@/shared/protocol/ora/requestId';

/**
 * An EventsAggregated forms an envelope message which contains a bunch of the actual events, which shall be applied within a single event processing step at the receivers side in exactly the given order.
 * A receiver must ensure the sequential processing of the contained messages and must not apply them in different order, partially or in parallel. Nested transactions are invalid.
 * 
 * It looks quite obfuscated, however this minified version is intentional.
 * For example, a frontend may issue aggregated events for each keystroke (setting a property and calling a func) so this premature optimization is likely a win.
 * 
 * The _requestId_ is optional and its content is an arbitrary value from the sender.
 * If the _requestId_ is neither null nor empty, the receiver must respond with an _ack_ event.
 * The _ack_ event must be the first message in the next transaction from the receiver.
 * However, due to channel interruptions, the _ack_ may get lost, thus a participant must handle this gracefully using a timeout mechanism.
 * The frontend must not freeze, but shall instead visualize the waiting, e.g. by debouncing interactive elements or by even disabling the entire screen and showing an indeterminate progress.
 */
export interface EventsAggregated {
    // Type
    type: 'T'/*EventType*/;
    // Events
    events: Event[];
    // RequestId
    r /*RequestId*/: RequestId;
}

