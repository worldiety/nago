// DO NOT EDIT. Generated by ora-gen-ts

import type { Event } from '@/shared/protocol/event';
import type { RequestId } from '@/shared/protocol/requestId';



/**
* An EventsAggregated forms an envelope message which contains a bunch of the actual events, which shall be applied within a single event processing step at the receivers side in exactly the given order.
A receiver must ensure the sequential processing of the contained messages and must not apply them in different order, partially or in parallel. Nested transactions are invalid.

It looks quite obfuscated, however this minified version is intentional.
For example, a frontend may issue aggregated events for each keystroke (setting a property and calling a func) so this premature optimization is likely a win.


The _requestId_ is optional and its content is an arbitrary value from the sender.
If the _requestId_ is neither null nor empty, the receiver must respond with an _ack_ event.
The _ack_ event must be the first message in the next transaction from the receiver.
However, due to channel interruptions, the _ack_ may get lost, thus a participant must handle this gracefully using a timeout mechanism.
The frontend must not freeze, but shall instead visualize the waiting, e.g. by debouncing interactive elements or by even disabling the entire screen and showing an indeterminate progress.

*/
export interface EventsAggregated {
    
     /**
     * The magic type constant for a Transaction.
     */
    type: 'T';
    
     /**
     * The aggregated events to apply in-order at once.
     */
    events: Event[];
    r: RequestId;
    
}
