This documentation is auto-generated by ora-doc-gen. Do NOT edit.

Generated at 2024-04-15 10:54:22.


<style>
table th:first-of-type {
    width: 20%;
}
table th:nth-of-type(2) {
    width: 30%;
}
table th:nth-of-type(3) {
    width: 50%;
}
table th:nth-of-type(4) {
    width: 30%;
}
</style>


## channel

A **channel** or **event stream** is bidirectional and has exactly 2 participants which are both receivers and senders of messages.
The nature is asynchronous, thus a sucessful write into a channel does neither imply that the messsage has been received nor processed.
The physical layer of a channel is not specified, so there may be different channel implementations, e.g. based on a WebSocket or using Server Side Events (SSE) or other simple (long) poll mechanics.

One communication participant is the backend and one is the frontend.
The frontend has no knowlege about any business domain.
Instead, it creates a user interface by interpreting a render tree which is generated by the backend and serialized into a message respective event.

At least, all messages must be supported to be serialized as JSON.
We considered more efficient serialisation formats, like protobuf, flatbuffers, cap'n proto etc. but we think the added complexity is not worth the advantages, especially in the current project status.
Before changing the serialization format, we recommend to use a channel with transparent compression.
Future versions may additionally negotiate other encodings.

## event

An **event** is basically a message from a channel, from a high level perspective.
However, events are aggregated into transactions.

## receiver

A **receiver** denotes the intended listener of a message, which is either the frontend or backend, whoever has not send the message.

## events

### Acknowledged


An Acknowledged event is the response to an [EventsAggregated] event if a [RequestId] had been set. 
A transaction forms an envelope message which contains a bunch of the actual events, which shall be applied within a single event processing step at the receivers side in exactly the given order.
A receiver must ensure the sequential processing of the contained messages and must not apply them in different order, partially or in parallel. Nested transactions are invalid.

It looks quite obfuscated, however this minified version is intentional, because it may succeed each transaction call.
A frontend may request acknowledges for each event, e.g. while typing in a text field, so this premature optimization is likely a win.

The ack event is send as a response from the receiver of a transaction in which the optional _requestId_ property has been set by the sender.
It can be used to debounce UI elements but can also be omitted to improve latency or in situations where the sender is not interested if the event has been received.
It must not enveloped into a transaction.


| field | type | description |
|--|--|--|
|type|EventType (const `A`)|The magic type constant.|
|r|RequestId|The request identifier, which is sent back.|


_Specification of Acknowledged_


```json
{
   "type": "",
   "r": 0
 }
```
_Example serialization of Acknowledged_

### EventsAggregated


An EventsAggregated forms an envelope message which contains a bunch of the actual events, which shall be applied within a single event processing step at the receivers side in exactly the given order.
A receiver must ensure the sequential processing of the contained messages and must not apply them in different order, partially or in parallel. Nested transactions are invalid.

It looks quite obfuscated, however this minified version is intentional.
For example, a frontend may issue aggregated events for each keystroke (setting a property and calling a func) so this premature optimization is likely a win.


The _requestId_ is optional and its content is an arbitrary value from the sender.
If the _requestId_ is neither null nor empty, the receiver must respond with an _ack_ event.
The _ack_ event must be the first message in the next transaction from the receiver.
However, due to channel interruptions, the _ack_ may get lost, thus a participant must handle this gracefully using a timeout mechanism.
The frontend must not freeze, but shall instead visualize the waiting, e.g. by debouncing interactive elements or by even disabling the entire screen and showing an indeterminate progress.


| field | type | description |
|--|--|--|
|type|EventType (const `T`)|The magic type constant for a Transaction.|
|events|[]Event|The aggregated events to apply in-order at once.|
|r|RequestId||


_Specification of EventsAggregated_


```json
{
   "type": "",
   "events": null,
   "r": 0
 }
```
_Example serialization of EventsAggregated_

### NewComponentRequested


NewComponentRequested allocates an addressable component explicitely in the backend within its channel scope.
Adressable components are like pages in a classic server side rendering or like routing targets in single page apps.
We do not call them _page_ anymore, because that has wrong assocations in the web world.
Adressable components exist independently from each other and share no lifecycle with each other.
However, a frontend can create as many component instances it wants.
It does not matter, if these components are of the same type, addresses or entirely different.
The backend responds with a component invalidation event.

Factories of addressable components are always stateless.
However, often it does not make sense without additional parameters, e.g. because a detail view needs to know which entity has to be displayed.


| field | type | description |
|--|--|--|
|type|EventType (const `NewComponentRequested`)||
|activeLocale|string|This locale has been picked by the backend.|
|factory|ComponentFactoryId|This is the unique address for a specific component factory, e.g. my/component/path. This is typically a page.|
|values|map[string]string|Contains string encoded parameters for a component. This is like query parameters.|
|requestId|RequestId|Request ID used to generate a new component request and is returned in the according response.|


_Specification of NewComponentRequested_


```json
{
   "type": "",
   "activeLocale": "",
   "factory": "",
   "values": null,
   "requestId": 0
 }
```
_Example serialization of NewComponentRequested_

### ComponentInvalidated

| field | type | description |
|--|--|--|
|type|EventType (const `ComponentInvalidated`)||
|requestId|RequestId|Request ID from the ComponentInvalidationRequested or NewComponentRequested event.|
|value|Component|The rendered component tree.|


_Specification of ComponentInvalidated_


```json
{
   "type": "",
   "requestId": 0,
   "value": null
 }
```
_Example serialization of ComponentInvalidated_

### ComponentInvalidationRequested

| field | type | description |
|--|--|--|
|type|EventType (const `ComponentInvalidationRequested`)||
|requestId|RequestId|Request ID from the NewComponentRequested event.|
|ptr|Ptr|The pointer of the component, which shall be rendered again. Only Pointer created with NewComponentRequested are valid.|


_Specification of ComponentInvalidationRequested_


```json
{
   "type": "",
   "requestId": 0,
   "ptr": 0
 }
```
_Example serialization of ComponentInvalidationRequested_

### ErrorOccurred

| field | type | description |
|--|--|--|
|type|EventType (const `ErrorOccurred`)||
|requestId|RequestId|Request ID from the NewComponentRequested event.|
|message|string|A message describing the error.|


_Specification of ErrorOccurred_


```json
{
   "type": "",
   "requestId": 0,
   "message": ""
 }
```
_Example serialization of ErrorOccurred_

### ComponentDestructionRequested

| field | type | description |
|--|--|--|
|type|EventType (const `ComponentDestructionRequested`)||
|requestId|RequestId|Request ID.|
|ptr|Ptr|The pointer of the component, which shall be rendered again. Only Pointer created with NewComponentRequested are valid.|


_Specification of ComponentDestructionRequested_


```json
{
   "type": "",
   "requestId": 0,
   "ptr": 0
 }
```
_Example serialization of ComponentDestructionRequested_

### ScopeDestructionRequested

| field | type | description |
|--|--|--|
|type|EventType (const `ScopeDestructionRequested`)||
|requestId|RequestId|Request ID.|


_Specification of ScopeDestructionRequested_


```json
{
   "type": "",
   "requestId": 0
 }
```
_Example serialization of ScopeDestructionRequested_

### ConfigurationRequested


ConfigurationRequested is issued by the frontend to get the applications general configuration.
A backend developer has potentially defined a lot of configuration details about the application.
For example, there may be a color theme, customized icons, image resources, an application name and the available set of navigations, launch intents or other meta information.
It is expected, that this only happens once during initialization of the frontend process.

| field | type | description |
|--|--|--|
|type|EventType (const `ConfigurationRequested`)||
|acceptLanguage|string||
|colorScheme|ColorScheme|Color scheme hint which the frontend has picked. This may reduce graphical glitches, if the backend creates images or webview resources for the frontend.|
|requestId|RequestId||


_Specification of ConfigurationRequested_


```json
{
   "type": "",
   "acceptLanguage": "",
   "colorScheme": "",
   "requestId": 0
 }
```
_Example serialization of ConfigurationRequested_

### ConfigurationDefined


A ConfigurationDefined event is the response to a [ConfigurationRequested] event.
According to the locale request, string and svg resources can be localized by the backend. The returned locale is the actually picked locale from the requested locale query string.

It looks quite obfuscated, however this minified version is intentional, because it may succeed each transaction call.
A frontend may request acknowledges for each event, e.g. while typing in a text field, so this premature optimization is likely a win.


| field | type | description |
|--|--|--|
|type|EventType (const `ConfigurationDefined`)||
|applicationName|string||
|availableLocales|[]string||
|activeLocale|string||
|themes|Themes||
|resources|Resources||
|requestId|RequestId||


_Specification of ConfigurationDefined_


```json
{
   "type": "",
   "applicationName": "",
   "availableLocales": null,
   "activeLocale": "",
   "themes": {
     "dark": {
       "colors": {
         "black": "#00000000",
         "white": "#00000000",
         "primary": "#00000000",
         "interactive": "#00000000",
         "alertNegative": "#00000000",
         "alertPositive": "#00000000"
       }
     },
     "light": {
       "colors": {
         "black": "#00000000",
         "white": "#00000000",
         "primary": "#00000000",
         "interactive": "#00000000",
         "alertNegative": "#00000000",
         "alertPositive": "#00000000"
       }
     },
     "highContrast": {
       "colors": {
         "black": "#00000000",
         "white": "#00000000",
         "primary": "#00000000",
         "interactive": "#00000000",
         "alertNegative": "#00000000",
         "alertPositive": "#00000000"
       }
     },
     "protanopie": {
       "colors": {
         "black": "#00000000",
         "white": "#00000000",
         "primary": "#00000000",
         "interactive": "#00000000",
         "alertNegative": "#00000000",
         "alertPositive": "#00000000"
       }
     },
     "deuteranopie": {
       "colors": {
         "black": "#00000000",
         "white": "#00000000",
         "primary": "#00000000",
         "interactive": "#00000000",
         "alertNegative": "#00000000",
         "alertPositive": "#00000000"
       }
     },
     "tritanopie": {
       "colors": {
         "black": "#00000000",
         "white": "#00000000",
         "primary": "#00000000",
         "interactive": "#00000000",
         "alertNegative": "#00000000",
         "alertPositive": "#00000000"
       }
     }
   },
   "resources": {
     "svgs": null
   },
   "requestId": 0
 }
```
_Example serialization of ConfigurationDefined_

### SetPropertyValueRequested

| field | type | description |
|--|--|--|
|type|EventType (const `P`)|P stands for Set**P**ropertValue. It is expected, that we must process countless of these events.|
|p|Ptr|p denotes the remote pointer.|
|v|string|v denotes the serialized value to set the property to.|
|requestId|RequestId||


_Specification of SetPropertyValueRequested_


```json
{
   "type": "",
   "p": 0,
   "v": "",
   "requestId": 0
 }
```
_Example serialization of SetPropertyValueRequested_

### FunctionCallRequested

| field | type | description |
|--|--|--|
|type|EventType (const `F`)|F stands for **F**unctionCallRequested. It is expected, that we must process countless of these events.|
|p|Ptr|p denotes the remote pointer.|
|requestId|RequestId||


_Specification of FunctionCallRequested_


```json
{
   "type": "",
   "p": 0,
   "requestId": 0
 }
```
_Example serialization of FunctionCallRequested_

## Components

### Button


description:"A Button is the only button"

| field | type | description |
|--|--|--|
|id|Ptr||
|type|ComponentType (const `Button`)||
|caption|Property[string]|Caption of the button|
|preIcon|Property[SVG]||
|postIcon|Property[SVG]||
|color|Property[Intent]||
|disabled|Property[bool]||
|action|Property[Ptr]||


_Specification of Button_


```json
{
   "id": 0,
   "type": "",
   "caption": {
     "id": 0,
     "value": ""
   },
   "preIcon": {
     "id": 0,
     "value": ""
   },
   "postIcon": {
     "id": 0,
     "value": ""
   },
   "color": {
     "id": 0,
     "value": ""
   },
   "disabled": {
     "id": 0,
     "value": false
   },
   "action": {
     "id": 0,
     "value": 0
   }
 }
```
_Example serialization of Button_

