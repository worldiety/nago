This documentation is auto-generated by ora-doc-gen. Do NOT edit.

Generated at 2024-04-12 08:31:35.


<style>
table th:first-of-type {
    width: 20%;
}
table th:nth-of-type(2) {
    width: 30%;
}
table th:nth-of-type(3) {
    width: 50%;
}
table th:nth-of-type(4) {
    width: 30%;
}
</style>


## channel

A **channel** or **event stream** is bidirectional and has exactly 2 participants which are both receivers and senders of messages.
The nature is asynchronous, thus a sucessful write into a channel does neither imply that the messsage has been received nor processed.
The physical layer of a channel is not specified, so there may be different channel implementations, e.g. based on a WebSocket or using Server Side Events (SSE) or other simple (long) poll mechanics.

One communication participant is the backend and one is the frontend.
The frontend has no knowlege about any business domain.
Instead, it creates a user interface by interpreting a render tree which is generated by the backend and serialized into a message respective event.

At least, all messages must be supported to be serialized as JSON.
We considered more efficient serialisation formats, like protobuf, flatbuffers, cap'n proto etc. but we think the added complexity is not worth the advantages, especially in the current project status.
Before changing the serialization format, we recommend to use a channel with transparent compression.
Future versions may additionally negotiate other encodings.

## event

An **event** is basically a message from a channel, from a high level perspective.
However, events are aggregated into transactions.

## receiver

A **receiver** denotes the intended listener of a message, which is either the frontend or backend, whoever has not send the message.

## events

### Acknowledged


An Acknowledged event is the response to an [EventsAggregated] event if a [RequestId] had been set. 
A transaction forms an envelope message which contains a bunch of the actual events, which shall be applied within a single event processing step at the receivers side in exactly the given order.
A receiver must ensure the sequential processing of the contained messages and must not apply them in different order, partially or in parallel. Nested transactions are invalid.

It looks quite obfuscated, however this minified version is intentional, because it may succeed each transaction call.
A frontend may request acknowledges for each event, e.g. while typing in a text field, so this premature optimization is likely a win.

The ack event is send as a response from the receiver of a transaction in which the optional _requestId_ property has been set by the sender.
It can be used to debounce UI elements but can also be omitted to improve latency or in situations where the sender is not interested if the event has been received.
It must not enveloped into a transaction.


| field | type | description |
|--|--|--|
|type|EventType (const `A`)|The magic type constant.|
|r|RequestId|The request identifier, which is sent back.|


_Specification of Acknowledged_


```json
{
   "type": "",
   "r": 0
 }
```
_Example serialization of Acknowledged_

### EventsAggregated


An EventsAggregated forms an envelope message which contains a bunch of the actual events, which shall be applied within a single event processing step at the receivers side in exactly the given order.
A receiver must ensure the sequential processing of the contained messages and must not apply them in different order, partially or in parallel. Nested transactions are invalid.

It looks quite obfuscated, however this minified version is intentional.
For example, a frontend may issue aggregated events for each keystroke (setting a property and calling a func) so this premature optimization is likely a win.


The _requestId_ is optional and its content is an arbitrary value from the sender.
If the _requestId_ is neither null nor empty, the receiver must respond with an _ack_ event.
The _ack_ event must be the first message in the next transaction from the receiver.
However, due to channel interruptions, the _ack_ may get lost, thus a participant must handle this gracefully using a timeout mechanism.
The frontend must not freeze, but shall instead visualize the waiting, e.g. by debouncing interactive elements or by even disabling the entire screen and showing an indeterminate progress.


| field | type | description |
|--|--|--|
|type|EventType (const `T`)|The magic type constant for a Transaction.|
|events|[]Event|The aggregated events to apply in-order at once.|
|r|RequestId||


_Specification of EventsAggregated_


```json
{
   "type": "",
   "events": null,
   "r": 0
 }
```
_Example serialization of EventsAggregated_

### NewComponentRequested


NewComponentRequested allocates an addressable component explicitely in the backend within its channel scope.
Adressable components are like pages in a classic server side rendering or like routing targets in single page apps.
We do not call them _page_ anymore, because that has wrong assocations in the web world.
Adressable components exist independently from each other and share no lifecycle with each other.
However, a frontend can create as many component instances it wants.
It does not matter, if these components are of the same type, addresses or entirely different.
The backend responds with a component invalidation event.

Factories of addressable components are always stateless.
However, often it does not make sense without additional parameters, e.g. because a detail view needs to know which entity has to be displayed.


| field | type | description |
|--|--|--|
|type|EventType (const `NewComponentRequested`)||
|activeLocale|string|This locale has been picked by the backend.|
|factory|ComponentFactoryId|This is the unique address for a specific component factory, e.g. my/component/path. This is typically a page.|
|values|map[string]string|Contains string encoded parameters for a component. This is like query parameters.|
|requestId|RequestId|Request ID used to generate a new component request and is returned in the according response.|


_Specification of NewComponentRequested_


```json
{
   "type": "",
   "activeLocale": "",
   "factory": "",
   "values": null,
   "requestId": 0
 }
```
_Example serialization of NewComponentRequested_

### ComponentInvalidated

| field | type | description |
|--|--|--|
|type|EventType (const `ComponentInvalidated`)||
|requestId|RequestId|Request ID from the ComponentInvalidationRequested or NewComponentRequested event.|
|value|Component|The rendered component tree.|


_Specification of ComponentInvalidated_


```json
{
   "type": "",
   "requestId": 0,
   "value": null
 }
```
_Example serialization of ComponentInvalidated_

### ComponentInvalidationRequested

| field | type | description |
|--|--|--|
|type|EventType (const `ComponentInvalidationRequested`)||
|requestId|RequestId|Request ID from the NewComponentRequested event.|
|ptr|Ptr|The pointer of the component, which shall be rendered again. Only Pointer created with NewComponentRequested are valid.|


_Specification of ComponentInvalidationRequested_


```json
{
   "type": "",
   "requestId": 0,
   "ptr": 0
 }
```
_Example serialization of ComponentInvalidationRequested_

### ErrorOccurred

| field | type | description |
|--|--|--|
|type|EventType (const `ErrorOccurred`)||
|requestId|RequestId|Request ID from the NewComponentRequested event.|
|message|string|A message describing the error.|


_Specification of ErrorOccurred_


```json
{
   "type": "",
   "requestId": 0,
   "message": ""
 }
```
_Example serialization of ErrorOccurred_

### ComponentDestructionRequested

| field | type | description |
|--|--|--|
|type|EventType (const `ComponentDestructionRequested`)||
|requestId|RequestId|Request ID.|
|ptr|Ptr|The pointer of the component, which shall be rendered again. Only Pointer created with NewComponentRequested are valid.|


_Specification of ComponentDestructionRequested_


```json
{
   "type": "",
   "requestId": 0,
   "ptr": 0
 }
```
_Example serialization of ComponentDestructionRequested_

### ScopeDestructionRequested

| field | type | description |
|--|--|--|
|type|EventType (const `ScopeDestructionRequested`)||
|requestId|RequestId|Request ID.|


_Specification of ScopeDestructionRequested_


```json
{
   "type": "",
   "requestId": 0
 }
```
_Example serialization of ScopeDestructionRequested_

## Components

### Button


description:"A Button is the only button"

| field | type | description |
|--|--|--|
|id|Ptr||
|type|ComponentType (const `Button`)||
|caption|Property[string]|Caption of the button|
|preIcon|Property[RIDSVG]||
|postIcon|Property[RIDSVG]||
|color|Property[Intent]||
|disabled|Property[bool]||
|action|Property[Ptr]||


_Specification of Button_


```json
{
   "id": 0,
   "type": "",
   "caption": {
     "id": 0,
     "value": ""
   },
   "preIcon": {
     "id": 0,
     "value": 0
   },
   "postIcon": {
     "id": 0,
     "value": 0
   },
   "color": {
     "id": 0,
     "value": ""
   },
   "disabled": {
     "id": 0,
     "value": false
   },
   "action": {
     "id": 0,
     "value": 0
   }
 }
```
_Example serialization of Button_

