// Code generated by NAGO nprotoc DO NOT EDIT.


export class BinaryWriter {
    private buffer: Uint8Array;
    private view: DataView;
    private offset: number = 0;
    private tmp: Uint8Array;

    constructor(size: number = 1024) {
        this.buffer = new Uint8Array(size);
        this.tmp = new Uint8Array(8);
        this.view = new DataView(this.buffer.buffer);
    }

    private ensureCapacity(additionalBytes: number) {
        if (this.offset + additionalBytes > this.buffer.length) {
            const newBuffer = new Uint8Array(this.buffer.length * 2);
            newBuffer.set(this.buffer);
            this.buffer = newBuffer;
            this.view = new DataView(this.buffer.buffer);
        }
    }

    write(p: Uint8Array) {
        this.ensureCapacity(p.length);
        this.buffer.set(p, this.offset);
        this.offset += p.length;
    }

    writeBool(b: boolean) {
        this.ensureCapacity(1);
        this.buffer[this.offset++] = b ? 1 : 0;
    }

    writeVarint(value: number) {
        this.ensureCapacity(10); // Maximum varint size is 10 bytes
        let v = value;
        while (v > 127) {
            this.buffer[this.offset++] = (v & 0x7f) | 0x80;
            v >>>= 7;
        }
        this.buffer[this.offset++] = v;
    }

    writeUvarint(value: number) {
        this.writeVarint(value >>> 0);
    }

    writeByte(b: number) {
        this.ensureCapacity(1);
        this.buffer[this.offset++] = b;
    }

    writeFieldHeader(shape: Shape, id: FieldId) {
        this.writeByte((shape << 5) | (id & 0b00011111));
    }

    writeTypeHeader(shape: Shape, id: TypeId) {
        this.writeFieldHeader(shape, 0);
        this.writeUvarint(id);
    }

    writeSlice(data: Uint8Array) {
        this.writeUvarint(data.length);
        this.write(data);
    }

    getBuffer(): Uint8Array {
        return this.buffer.slice(0, this.offset);
    }

    writeFloat64(value: number): void {
        const buffer = new ArrayBuffer(8);
        const float64Bits = new DataView(buffer);
        float64Bits.setFloat64(0, value, true);
        this.tmp.set(new Uint8Array(buffer));
        this.write(this.tmp);
    }
}

export class BinaryReader {
    private buffer: Uint8Array;
    private view: DataView;
    private offset: number = 0;

    constructor(buffer: Uint8Array) {
        this.buffer = buffer;
        this.view = new DataView(buffer.buffer);
    }

    readByte(): number {
        if (this.offset >= this.buffer.length) throw new Error("Out of bounds");
        return this.buffer[this.offset++];
    }

    // Reads a specific number of bytes from the buffer
    readBytes(length: number): Uint8Array {
        if (this.offset + length > this.buffer.length) {
            throw new Error("Attempt to read beyond buffer length");
        }

        const bytes = this.buffer.slice(this.offset, this.offset + length);
        this.offset += length;
        return bytes;
    }

    readFieldHeader(): FieldHeader {
        const value = this.readByte();
        return {
            shape: (value >> 5) & 0b00000111,
            fieldId: value & 0b00011111,
        };
    }

    readTypeHeader(): { shape: Shape; typeId: TypeId } {
        const header = this.readFieldHeader();
        if (header.fieldId !== 0) {
            throw new Error("Expected type header, got field header");
        }
        const typeId = this.readUvarint();
        return {shape: header.shape, typeId};
    }

    readUvarint(): number {
        let result = 0;
        let shift = 0;
        while (true) {
            const byte = this.readByte();
            result |= (byte & 0x7f) << shift;
            if ((byte & 0x80) === 0) break;
            shift += 7;
            if (shift > 35) throw new Error("Varint too long");
        }
        return result;
    }

    readFloat64(): number {
        let tmp = this.readBytes(8);
        const buffer = tmp.buffer;
        const view = new DataView(buffer);
        return view.getFloat64(0, true);
    }
}

// Types and Enums

export type Shape = number;
export type FieldId = number;
export type TypeId = number;

export enum Shapes {
    ENVELOPE = 0,
    UVARINT,
    VARINT,
    BYTESLICE,
    RECORD,
    F32,
    F64,
    ARRAY,
}

export interface FieldHeader {
    shape: Shape;
    fieldId: FieldId;
}

// Interface for writable objects
export interface Writeable {
    write(writer: BinaryWriter): void;

    writeTypeHeader(dst: BinaryWriter): void
}


// Interface for readable objects
export interface Readable {
    read(reader: BinaryReader): void;

    isZero(): boolean;
}
// Component is the building primitive for any widget, behavior or ui element in NAGO.
export interface Component extends Writeable, Readable{
	// a marker method to indicate the enum / union type membership
	isComponent(): void;
}

// NagoEvent is the union type of all allowed NAGO protocol events. Everything which goes through a NAGO channel must be an Event at the root level.
export interface NagoEvent extends Writeable, Readable{
	// a marker method to indicate the enum / union type membership
	isNagoEvent(): void;
}

// A Box aligns children elements in absolute within its bounds.
//  - there is no intrinsic component dimension, so you have to set it by hand
//  - z-order is defined as defined children order, thus later children are put on top of others
//  - it is undefined behavior, to define multiple children with the same alignment. So this must not be rendered.
export class Box implements Writeable, Readable , Component  {
		public children: AlignedComponents;

		public frame: Frame;

		public backgroundColor: Color;

		public padding: Padding;

		public border: Border;

	constructor(children: AlignedComponents = new AlignedComponents(), frame: Frame = new Frame(), backgroundColor: Color = new Color(), padding: Padding = new Padding(), border: Border = new Border(), ) {
		this.children = children;
		this.frame = frame;
		this.backgroundColor = backgroundColor;
		this.padding = padding;
		this.border = border;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.children.read(reader);
					break
				}
				case 2: {
					this.frame.read(reader);
					break
				}
				case 3: {
					this.backgroundColor.read(reader);
					break
				}
				case 4: {
					this.padding.read(reader);
					break
				}
				case 5: {
					this.border.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.children.isZero(),!this.frame.isZero(),!this.backgroundColor.isZero(),!this.padding.isZero(),!this.border.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			this.children.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.RECORD, 2);
			this.frame.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			this.backgroundColor.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.RECORD, 4);
			this.padding.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.RECORD, 5);
			this.border.write(writer);
		}
	}

	isZero(): boolean {
		return this.children.isZero() && this.frame.isZero() && this.backgroundColor.isZero() && this.padding.isZero() && this.border.isZero()
	}

	reset(): void {
		this.children.reset()
		this.frame.reset()
		this.backgroundColor.reset()
		this.padding.reset()
		this.border.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 1);
		return
	}
	isComponent(): void{}
}


// Ptr represents an allocated instance within the backend which is unique in the associated scope.
export class Ptr implements Writeable, Readable {
 
	public value: number; // Using number to handle uint64 (precision limits apply)
	
	constructor(value: number = 0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0;
	}
	
	reset(): void {
		this.value = 0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readUvarint();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.UVARINT, 2);
		return
	}
}

// companion enum containing all defined constants for Ptr
export enum PtrValues {
	// Null represents the zero value and a nil or null pointer address.
	Null = 0,
}



// UpdateStateValueRequested is raised from the frontend to update a state value hold by the backend. It can also immediately invoke a function callback in the same cycle.
export class UpdateStateValueRequested implements Writeable, Readable , NagoEvent  {
	// The StatePointer must not be zero.
	public statePointer: Ptr;

	// A FunctionPointer is invoked, if not zero.
	public functionPointer: Ptr;

		public rID: RID;

		public value: Str;

	constructor(statePointer: Ptr = new Ptr(), functionPointer: Ptr = new Ptr(), rID: RID = new RID(), value: Str = new Str(), ) {
		this.statePointer = statePointer;
		this.functionPointer = functionPointer;
		this.rID = rID;
		this.value = value;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.statePointer.read(reader);
					break
				}
				case 2: {
					this.functionPointer.read(reader);
					break
				}
				case 3: {
					this.rID.read(reader);
					break
				}
				case 4: {
					this.value.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.statePointer.isZero(),!this.functionPointer.isZero(),!this.rID.isZero(),!this.value.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			this.statePointer.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			this.functionPointer.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			this.rID.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			this.value.write(writer);
		}
	}

	isZero(): boolean {
		return this.statePointer.isZero() && this.functionPointer.isZero() && this.rID.isZero() && this.value.isZero()
	}

	reset(): void {
		this.statePointer.reset()
		this.functionPointer.reset()
		this.rID.reset()
		this.value.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 3);
		return
	}
	isNagoEvent(): void{}
}


// FunctionCallRequested tells the backend that the given pointer in the associated scope shall be invoked for a side effect.
export class FunctionCallRequested implements Writeable, Readable , NagoEvent  {
	// Ptr denotes the remote pointer of the function.
	public ptr: Ptr;

	// RID is used to trace a request-response cycle.
	public rID: RID;

	constructor(ptr: Ptr = new Ptr(), rID: RID = new RID(), ) {
		this.ptr = ptr;
		this.rID = rID;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.ptr.read(reader);
					break
				}
				case 2: {
					this.rID.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.ptr.isZero(),!this.rID.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			this.ptr.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			this.rID.write(writer);
		}
	}

	isZero(): boolean {
		return this.ptr.isZero() && this.rID.isZero()
	}

	reset(): void {
		this.ptr.reset()
		this.rID.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 4);
		return
	}
	isNagoEvent(): void{}
}


// Alignment is specified as follows:
// 
// 	┌─TopLeading───────────Top─────────TopTrailing─┐
// 	│                                              │
// 	│                                              │
// 	│                                              │
// 	│                                              │
// 	│                                              │
// 	│                                              │
// 	│                                              │
// 	│ Leading            Center            Trailing│
// 	│                                              │
// 	│                                              │
// 	│                                              │
// 	│                                              │
// 	│                                              │
// 	│                                              │
// 	│                                              │
// 	└BottomLeading───────Bottom──────BottomTrailing┘
// 
// An empty Alignment must be interpreted as Center (="c").
export class Alignment implements Writeable, Readable {
 
	public value: number; // Using number to handle uint64 (precision limits apply)
	
	constructor(value: number = 0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0;
	}
	
	reset(): void {
		this.value = 0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readUvarint();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.UVARINT, 5);
		return
	}
}

// companion enum containing all defined constants for Alignment
export enum AlignmentValues {
		Center = 0,
		Top = 1,
		Bottom = 2,
		Leading = 3,
		Trailing = 4,
		TopLeading = 5,
		TopTrailing = 6,
		BottomLeading = 7,
		BottomTrailing = 8,
}



// Color specifies either a hex color like #rrggbb or #rrggbbaa or an internal custom color name.
export class Color implements Writeable, Readable {
 
  public value: string; 

  constructor(value: string = "") {
    this.value = value;
  }

  isZero(): boolean {
    return this.value === "";
  }

  reset(): void {
    this.value = "";
  }

  // Get the string representation of the Color
  toString(): string {
    return this.value;
  }

  write(writer: BinaryWriter): void {
    const data = new TextEncoder().encode(this.value); // Convert string to Uint8Array
    writer.writeUvarint(data.length); // Write the length of the string
    writer.write(data); // Write the string data
  }

  read(reader: BinaryReader): void {
	const strLen = reader.readUvarint(); // Read the length of the string
    const buf = reader.readBytes(strLen); // Read the string data
    this.value = new TextDecoder().decode(buf); // Convert Uint8Array to string
  }

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.BYTESLICE, 6);
		return
	}
}


// Shadow defines a shadow effect around the border of an element. The x and y coordinates are relative to the element.
export class Shadow implements Writeable, Readable  {
	// Color of the shadow.
	public color: Color;

	// Radius for spread and blur length of the shadow.
	public radius: Length;

	// X is the horizontal offset of the shadow relative to the element.
	public x: Length;

	// Y is the vertical offset of the shadow relative to the element.
	public y: Length;

	constructor(color: Color = new Color(), radius: Length = new Length(), x: Length = new Length(), y: Length = new Length(), ) {
		this.color = color;
		this.radius = radius;
		this.x = x;
		this.y = y;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.color.read(reader);
					break
				}
				case 2: {
					this.radius.read(reader);
					break
				}
				case 3: {
					this.x.read(reader);
					break
				}
				case 4: {
					this.y.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.color.isZero(),!this.radius.isZero(),!this.x.isZero(),!this.y.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			this.color.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			this.radius.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			this.x.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			this.y.write(writer);
		}
	}

	isZero(): boolean {
		return this.color.isZero() && this.radius.isZero() && this.x.isZero() && this.y.isZero()
	}

	reset(): void {
		this.color.reset()
		this.radius.reset()
		this.x.reset()
		this.y.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 7);
		return
	}
}


// Length is actually a complex sum type of varying content. It may contain absolute values like dp, rem or relative like 90%. It may also include css calculations or even variable names. Retrospective, we should represent each type individually, however that was not reasonable, when the requirements and hand written protocol implementations were created and now it is to late.
export class Length implements Writeable, Readable {
 
  public value: string; 

  constructor(value: string = "") {
    this.value = value;
  }

  isZero(): boolean {
    return this.value === "";
  }

  reset(): void {
    this.value = "";
  }

  // Get the string representation of the Color
  toString(): string {
    return this.value;
  }

  write(writer: BinaryWriter): void {
    const data = new TextEncoder().encode(this.value); // Convert string to Uint8Array
    writer.writeUvarint(data.length); // Write the length of the string
    writer.write(data); // Write the string data
  }

  read(reader: BinaryReader): void {
	const strLen = reader.readUvarint(); // Read the length of the string
    const buf = reader.readBytes(strLen); // Read the string data
    this.value = new TextDecoder().decode(buf); // Convert Uint8Array to string
  }

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.BYTESLICE, 8);
		return
	}
}


// Border adds the defined border and dimension to the component. Note, that a border will change the dimension.
export class Border implements Writeable, Readable  {
		public topLeftRadius: Length;

		public topRightRadius: Length;

		public bottomLeftRadius: Length;

		public bottomRightRadius: Length;

		public leftWidth: Length;

		public topWidth: Length;

		public rightWidth: Length;

		public bottomWidth: Length;

		public leftColor: Color;

		public topColor: Color;

		public rightColor: Color;

		public bottomColor: Color;

		public boxShadow: Shadow;

	constructor(topLeftRadius: Length = new Length(), topRightRadius: Length = new Length(), bottomLeftRadius: Length = new Length(), bottomRightRadius: Length = new Length(), leftWidth: Length = new Length(), topWidth: Length = new Length(), rightWidth: Length = new Length(), bottomWidth: Length = new Length(), leftColor: Color = new Color(), topColor: Color = new Color(), rightColor: Color = new Color(), bottomColor: Color = new Color(), boxShadow: Shadow = new Shadow(), ) {
		this.topLeftRadius = topLeftRadius;
		this.topRightRadius = topRightRadius;
		this.bottomLeftRadius = bottomLeftRadius;
		this.bottomRightRadius = bottomRightRadius;
		this.leftWidth = leftWidth;
		this.topWidth = topWidth;
		this.rightWidth = rightWidth;
		this.bottomWidth = bottomWidth;
		this.leftColor = leftColor;
		this.topColor = topColor;
		this.rightColor = rightColor;
		this.bottomColor = bottomColor;
		this.boxShadow = boxShadow;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.topLeftRadius.read(reader);
					break
				}
				case 2: {
					this.topRightRadius.read(reader);
					break
				}
				case 3: {
					this.bottomLeftRadius.read(reader);
					break
				}
				case 4: {
					this.bottomRightRadius.read(reader);
					break
				}
				case 5: {
					this.leftWidth.read(reader);
					break
				}
				case 6: {
					this.topWidth.read(reader);
					break
				}
				case 7: {
					this.rightWidth.read(reader);
					break
				}
				case 8: {
					this.bottomWidth.read(reader);
					break
				}
				case 9: {
					this.leftColor.read(reader);
					break
				}
				case 10: {
					this.topColor.read(reader);
					break
				}
				case 11: {
					this.rightColor.read(reader);
					break
				}
				case 12: {
					this.bottomColor.read(reader);
					break
				}
				case 13: {
					this.boxShadow.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.topLeftRadius.isZero(),!this.topRightRadius.isZero(),!this.bottomLeftRadius.isZero(),!this.bottomRightRadius.isZero(),!this.leftWidth.isZero(),!this.topWidth.isZero(),!this.rightWidth.isZero(),!this.bottomWidth.isZero(),!this.leftColor.isZero(),!this.topColor.isZero(),!this.rightColor.isZero(),!this.bottomColor.isZero(),!this.boxShadow.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			this.topLeftRadius.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			this.topRightRadius.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			this.bottomLeftRadius.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			this.bottomRightRadius.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			this.leftWidth.write(writer);
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 6);
			this.topWidth.write(writer);
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 7);
			this.rightWidth.write(writer);
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 8);
			this.bottomWidth.write(writer);
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 9);
			this.leftColor.write(writer);
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 10);
			this.topColor.write(writer);
		}
		if (fields[11]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 11);
			this.rightColor.write(writer);
		}
		if (fields[12]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 12);
			this.bottomColor.write(writer);
		}
		if (fields[13]) {
			writer.writeFieldHeader(Shapes.RECORD, 13);
			this.boxShadow.write(writer);
		}
	}

	isZero(): boolean {
		return this.topLeftRadius.isZero() && this.topRightRadius.isZero() && this.bottomLeftRadius.isZero() && this.bottomRightRadius.isZero() && this.leftWidth.isZero() && this.topWidth.isZero() && this.rightWidth.isZero() && this.bottomWidth.isZero() && this.leftColor.isZero() && this.topColor.isZero() && this.rightColor.isZero() && this.bottomColor.isZero() && this.boxShadow.isZero()
	}

	reset(): void {
		this.topLeftRadius.reset()
		this.topRightRadius.reset()
		this.bottomLeftRadius.reset()
		this.bottomRightRadius.reset()
		this.leftWidth.reset()
		this.topWidth.reset()
		this.rightWidth.reset()
		this.bottomWidth.reset()
		this.leftColor.reset()
		this.topColor.reset()
		this.rightColor.reset()
		this.bottomColor.reset()
		this.boxShadow.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 9);
		return
	}
}


// Frame defines the geometrics bounds of an element.
export class Frame implements Writeable, Readable  {
		public minWidth: Length;

		public maxWidth: Length;

		public minHeight: Length;

		public maxHeight: Length;

		public width: Length;

		public height: Length;

	constructor(minWidth: Length = new Length(), maxWidth: Length = new Length(), minHeight: Length = new Length(), maxHeight: Length = new Length(), width: Length = new Length(), height: Length = new Length(), ) {
		this.minWidth = minWidth;
		this.maxWidth = maxWidth;
		this.minHeight = minHeight;
		this.maxHeight = maxHeight;
		this.width = width;
		this.height = height;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.minWidth.read(reader);
					break
				}
				case 2: {
					this.maxWidth.read(reader);
					break
				}
				case 3: {
					this.minHeight.read(reader);
					break
				}
				case 4: {
					this.maxHeight.read(reader);
					break
				}
				case 5: {
					this.width.read(reader);
					break
				}
				case 6: {
					this.height.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.minWidth.isZero(),!this.maxWidth.isZero(),!this.minHeight.isZero(),!this.maxHeight.isZero(),!this.width.isZero(),!this.height.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			this.minWidth.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			this.maxWidth.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			this.minHeight.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			this.maxHeight.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			this.width.write(writer);
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 6);
			this.height.write(writer);
		}
	}

	isZero(): boolean {
		return this.minWidth.isZero() && this.maxWidth.isZero() && this.minHeight.isZero() && this.maxHeight.isZero() && this.width.isZero() && this.height.isZero()
	}

	reset(): void {
		this.minWidth.reset()
		this.maxWidth.reset()
		this.minHeight.reset()
		this.maxHeight.reset()
		this.width.reset()
		this.height.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 10);
		return
	}
}


// Padding defines additional room within an element.
export class Padding implements Writeable, Readable  {
		public top: Length;

		public left: Length;

		public right: Length;

		public bottom: Length;

	constructor(top: Length = new Length(), left: Length = new Length(), right: Length = new Length(), bottom: Length = new Length(), ) {
		this.top = top;
		this.left = left;
		this.right = right;
		this.bottom = bottom;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.top.read(reader);
					break
				}
				case 2: {
					this.left.read(reader);
					break
				}
				case 3: {
					this.right.read(reader);
					break
				}
				case 4: {
					this.bottom.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.top.isZero(),!this.left.isZero(),!this.right.isZero(),!this.bottom.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			this.top.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			this.left.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			this.right.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			this.bottom.write(writer);
		}
	}

	isZero(): boolean {
		return this.top.isZero() && this.left.isZero() && this.right.isZero() && this.bottom.isZero()
	}

	reset(): void {
		this.top.reset()
		this.left.reset()
		this.right.reset()
		this.bottom.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 11);
		return
	}
}


// AlignedComponent defines a tupel of a component and an associated alignment.
export class AlignedComponent implements Writeable, Readable  {
		public component?: Component;

		public alignment: Alignment;

	constructor(component = undefined, alignment: Alignment = new Alignment(), ) {
		this.component = component;
		this.alignment = alignment;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
					  throw new Error(`unexpected length: ` + len);
					}
					this.component = unmarshal(reader) as Component;
					break
				}
				case 2: {
					this.alignment.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,this.component!== undefined && !this.component.isZero(),!this.alignment.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			writer.writeByte(1);
			this.component!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			this.alignment.write(writer);
		}
	}

	isZero(): boolean {
		return (this.component=== undefined || this.component.isZero()) && this.alignment.isZero()
	}

	reset(): void {
		this.component = undefined
		this.alignment.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 12);
		return
	}
}


// Components is polymorphic array of various concrete Component instances.
export class Components implements Writeable, Readable  {
	public value: Component[];
	
	constructor(value: Component[] = []) {
 
      this.value = value;
    }

  isZero(): boolean {
	return !this.value || this.value.length === 0;
  }

  reset(): void {
	this.value = [];
  }


  write(writer: BinaryWriter): void {
	writer.writeUvarint(this.value.length); // Write the length of the array
	for (const c of this.value) {
	  c.writeTypeHeader(writer); // Write the type header for each component
	  c.write(writer); // Write the component data
	}
  }

	  
  read(reader: BinaryReader): void {
	const count = reader.readUvarint(); // Read the length of the array
	const values: Component[] = [];

	for (let i = 0; i < count; i++) {
	  const obj = unmarshal(reader); // Read and unmarshal each component
	  values.push(obj as Component); // Cast and add to the array
	}

	this.value = values;
  }	
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 13);
		return
	}
}


// AlignedComponents is an array of layouted tupels of components.
export class AlignedComponents implements Writeable, Readable  {
	public value: AlignedComponent[];
	
	constructor(value: AlignedComponent[] = []) {
 
      this.value = value;
    }

  isZero(): boolean {
	return !this.value || this.value.length === 0;
  }

  reset(): void {
	this.value = [];
  }


  write(writer: BinaryWriter): void {
	writer.writeUvarint(this.value.length); // Write the length of the array
	for (const c of this.value) {
	  c.writeTypeHeader(writer); // Write the type header for each component
	  c.write(writer); // Write the component data
	}
  }

	  
  read(reader: BinaryReader): void {
	const count = reader.readUvarint(); // Read the length of the array
	const values: AlignedComponent[] = [];

	for (let i = 0; i < count; i++) {
	  const obj = unmarshal(reader); // Read and unmarshal each component
	  values.push(obj as AlignedComponent); // Cast and add to the array
	}

	this.value = values;
  }	
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 14);
		return
	}
}


// Checkbox represents a user interface element which spans a visible area to click or tap from the user. Use it for controls, which do not cause an immediate effect. See also [Toggle].
export class Checkbox implements Writeable, Readable , Component  {
	// InputValue is where updated value of the checked states are written.
	public inputValue: Ptr;

		public value: Bool;

		public disabled: Bool;

		public invisible: Bool;

	constructor(inputValue: Ptr = new Ptr(), value: Bool = new Bool(), disabled: Bool = new Bool(), invisible: Bool = new Bool(), ) {
		this.inputValue = inputValue;
		this.value = value;
		this.disabled = disabled;
		this.invisible = invisible;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.inputValue.read(reader);
					break
				}
				case 2: {
					this.value.read(reader);
					break
				}
				case 3: {
					this.disabled.read(reader);
					break
				}
				case 4: {
					this.invisible.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.inputValue.isZero(),!this.value.isZero(),!this.disabled.isZero(),!this.invisible.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			this.inputValue.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			this.value.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			this.disabled.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			this.invisible.write(writer);
		}
	}

	isZero(): boolean {
		return this.inputValue.isZero() && this.value.isZero() && this.disabled.isZero() && this.invisible.isZero()
	}

	reset(): void {
		this.inputValue.reset()
		this.value.reset()
		this.disabled.reset()
		this.invisible.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 15);
		return
	}
	isComponent(): void{}
}


// Bool represents just a user defined boolean value. This is how nprotoc works.
export class Bool implements Writeable, Readable {
 
	public value: boolean; 
	
	constructor(value: boolean = false) {
		this.value = value;
	}
	
	isZero(): boolean {
		return !this.value;
	}
	
	reset(): void {
		this.value = false;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value?1:0);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readUvarint() === 1;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.UVARINT, 16);
		return
	}
}


// ErrorOccurred is used, if some unforeseen error occurred. Usually the frontend did something wrong, e.g. in a life-cycle.
export class ErrorOccurred implements Writeable, Readable , NagoEvent  {
	// Message of some generic error.
	public message: Str;

	// RID is used to trace a request-response cycle.
	public rID: RID;

	constructor(message: Str = new Str(), rID: RID = new RID(), ) {
		this.message = message;
		this.rID = rID;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.message.read(reader);
					break
				}
				case 2: {
					this.rID.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.message.isZero(),!this.rID.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			this.message.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			this.rID.write(writer);
		}
	}

	isZero(): boolean {
		return this.message.isZero() && this.rID.isZero()
	}

	reset(): void {
		this.message.reset()
		this.rID.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 17);
		return
	}
	isNagoEvent(): void{}
}


// Locale represents a BCP47 tag like de or de_DE.
export class Locale implements Writeable, Readable {
 
  public value: string; 

  constructor(value: string = "") {
    this.value = value;
  }

  isZero(): boolean {
    return this.value === "";
  }

  reset(): void {
    this.value = "";
  }

  // Get the string representation of the Color
  toString(): string {
    return this.value;
  }

  write(writer: BinaryWriter): void {
    const data = new TextEncoder().encode(this.value); // Convert string to Uint8Array
    writer.writeUvarint(data.length); // Write the length of the string
    writer.write(data); // Write the string data
  }

  read(reader: BinaryReader): void {
	const strLen = reader.readUvarint(); // Read the length of the string
    const buf = reader.readBytes(strLen); // Read the string data
    this.value = new TextDecoder().decode(buf); // Convert Uint8Array to string
  }

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.BYTESLICE, 18);
		return
	}
}


// RID represents a request id and may be used by the frontend to distinguish different generations of answers.
export class FontStyle implements Writeable, Readable {
 
	public value: number; // Using number to handle uint64 (precision limits apply)
	
	constructor(value: number = 0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0;
	}
	
	reset(): void {
		this.value = 0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readUvarint();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.UVARINT, 19);
		return
	}
}

// companion enum containing all defined constants for FontStyle
export enum FontStyleValues {
	// A 0 represents something which was issued without any user interaction, which means by own-initiative.
	Unsolicited = 0,
		Normal = 1,
		Italic = 2,
}



// RootViewID is a unique address for a specific view factory, e.g. my/component/path. This is typically a page. Even though this looks like an URI, it is not. Especially, there are no path parameters or query parameters.
export class RootViewID implements Writeable, Readable {
 
  public value: string; 

  constructor(value: string = "") {
    this.value = value;
  }

  isZero(): boolean {
    return this.value === "";
  }

  reset(): void {
    this.value = "";
  }

  // Get the string representation of the Color
  toString(): string {
    return this.value;
  }

  write(writer: BinaryWriter): void {
    const data = new TextEncoder().encode(this.value); // Convert string to Uint8Array
    writer.writeUvarint(data.length); // Write the length of the string
    writer.write(data); // Write the string data
  }

  read(reader: BinaryReader): void {
	const strLen = reader.readUvarint(); // Read the length of the string
    const buf = reader.readBytes(strLen); // Read the string data
    this.value = new TextDecoder().decode(buf); // Convert Uint8Array to string
  }

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.BYTESLICE, 20);
		return
	}
}


// RootViewParameters is a map of string keys and values which is given to a root view which is about to be initialized.
export class RootViewParameters implements Writeable, Readable  {
	public value: Map<Str,Str>;
	
	constructor(value: Map<Str,Str> = new Map<Str,Str>()) {
	 
      this.value = value;
    }

  isZero(): boolean {
	return !this.value || this.value.size === 0;
  }

  reset(): void {
	this.value = new Map<Str,Str>();
  }


  write(writer: BinaryWriter): void {
	writer.writeUvarint(this.value.size); // Write the length of the map
	for (const [key, value] of this.value) {
      // write key
	  key.writeTypeHeader(writer); 
	  key.write(writer); 

      // write value
	  value.writeTypeHeader(writer); 
	  value.write(writer); 
	}
  }

	  
  read(reader: BinaryReader): void {
	const count = reader.readUvarint(); 
	const values = new Map<Str,Str>();

	for (let i = 0; i < count; i++) {
	  const key = unmarshal(reader);
      const val = unmarshal(reader);

	  values.set(key as Str, val as Str); 
	}

	this.value = values;
  }	
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 21);
		return
	}
}


// Str represents just a user defined string value. This is how nprotoc works.
export class Str implements Writeable, Readable {
 
  public value: string; 

  constructor(value: string = "") {
    this.value = value;
  }

  isZero(): boolean {
    return this.value === "";
  }

  reset(): void {
    this.value = "";
  }

  // Get the string representation of the Color
  toString(): string {
    return this.value;
  }

  write(writer: BinaryWriter): void {
    const data = new TextEncoder().encode(this.value); // Convert string to Uint8Array
    writer.writeUvarint(data.length); // Write the length of the string
    writer.write(data); // Write the string data
  }

  read(reader: BinaryReader): void {
	const strLen = reader.readUvarint(); // Read the length of the string
    const buf = reader.readBytes(strLen); // Read the string data
    this.value = new TextDecoder().decode(buf); // Convert Uint8Array to string
  }

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.BYTESLICE, 22);
		return
	}
}


// RootViewRenderingRequested is issued by the frontend to force a rendering at the backend.
export class RootViewRenderingRequested implements Writeable, Readable , NagoEvent  {
		public rID: RID;

	constructor(rID: RID = new RID(), ) {
		this.rID = rID;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.rID.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.rID.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			this.rID.write(writer);
		}
	}

	isZero(): boolean {
		return this.rID.isZero()
	}

	reset(): void {
		this.rID.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 23);
		return
	}
	isNagoEvent(): void{}
}


// The RootViewDestructionRequested event destroys the currently allocated root view. If nothing is allocated, this is a no-op.
export class RootViewDestructionRequested implements Writeable, Readable , NagoEvent  {
	// RID is used to generate a new component request and is returned in the according response.
	public rID: RID;

	constructor(rID: RID = new RID(), ) {
		this.rID = rID;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.rID.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.rID.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			this.rID.write(writer);
		}
	}

	isZero(): boolean {
		return this.rID.isZero()
	}

	reset(): void {
		this.rID.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 24);
		return
	}
	isNagoEvent(): void{}
}


// The RootViewInvalidated event is always generated at the backend side, if a new representation of an allocated root view shall be shown.
export class RootViewInvalidated implements Writeable, Readable , NagoEvent  {
	// RID may be 0, if it is an proactive rendering.
	public rID: RID;

	// The Root component to display.
	public root?: Component;

	constructor(rID: RID = new RID(), root = undefined, ) {
		this.rID = rID;
		this.root = root;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.rID.read(reader);
					break
				}
				case 2: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
					  throw new Error(`unexpected length: ` + len);
					}
					this.root = unmarshal(reader) as Component;
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.rID.isZero(),this.root!== undefined && !this.root.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			this.rID.write(writer);
		}
		if (fields[2]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 2);
			writer.writeByte(1);
			this.root!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.rID.isZero() && (this.root=== undefined || this.root.isZero())
	}

	reset(): void {
		this.rID.reset()
		this.root = undefined
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 25);
		return
	}
	isNagoEvent(): void{}
}


// ErrorRootViewAllocationRequired indicates, that there is no root view and it must be allocated to continue. This may happen, e.g. if the server was restarted or redeployed or a timeout occurred and the scope or root view was collected.
export class ErrorRootViewAllocationRequired implements Writeable, Readable , NagoEvent  {
	// RID is used to trace a request-response cycle.
	public rID: RID;

	constructor(rID: RID = new RID(), ) {
		this.rID = rID;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.rID.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.rID.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			this.rID.write(writer);
		}
	}

	isZero(): boolean {
		return this.rID.isZero()
	}

	reset(): void {
		this.rID.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 26);
		return
	}
	isNagoEvent(): void{}
}


// NewComponentRequested allocates an addressable component explicitely in the backend within its channel scope.
// Adressable components are like pages in a classic server side rendering or like routing targets in single page apps.
// We do not call them _page_ anymore, because that has wrong assocations in the web world.
// Adressable components exist independently from each other and share no lifecycle with each other.
// However, a frontend can create as many component instances it wants.
// It does not matter, if these components are of the same type, addresses or entirely different.
// The backend responds with a component invalidation event.
// Factories of addressable components are always stateless.
// However, often it does not make sense without additional parameters, e.g. because a detail view needs to know which entity has to be displayed.
export class RootViewAllocationRequested implements Writeable, Readable , NagoEvent  {
	// Locale of the frontend which is assumed as the users language. This may be the webbrowser primary locale which may be derived from the operating system.
	public locale: Locale;

	// Factory denotes the registered root view identifier.
	public factory: RootViewID;

	// RID is used to generate a new component request and is returned in the according response.
	public rID: RID;

	// Values contains string encoded parameters for a component. This is like query parameters in the web world.
	public values: RootViewParameters;

	constructor(locale: Locale = new Locale(), factory: RootViewID = new RootViewID(), rID: RID = new RID(), values: RootViewParameters = new RootViewParameters(), ) {
		this.locale = locale;
		this.factory = factory;
		this.rID = rID;
		this.values = values;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.locale.read(reader);
					break
				}
				case 2: {
					this.factory.read(reader);
					break
				}
				case 3: {
					this.rID.read(reader);
					break
				}
				case 4: {
					this.values.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.locale.isZero(),!this.factory.isZero(),!this.rID.isZero(),!this.values.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			this.locale.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			this.factory.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			this.rID.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.ARRAY, 4);
			this.values.write(writer);
		}
	}

	isZero(): boolean {
		return this.locale.isZero() && this.factory.isZero() && this.rID.isZero() && this.values.isZero()
	}

	reset(): void {
		this.locale.reset()
		this.factory.reset()
		this.rID.reset()
		this.values.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 27);
		return
	}
	isNagoEvent(): void{}
}


// ColorScheme represents which kind of theme shall be rendered.WindowSizeClass represents media break points of the screen which an ora application is shown.
// The definition of a size class is disjunct and for all possible sizes, exact one size class will match.
// See also https://developer.android.com/develop/ui/views/layout/window-size-classes and
// https://tailwindcss.com/docs/responsive-design.
export class WindowSizeClass implements Writeable, Readable {
 
	public value: number; // Using number to handle uint64 (precision limits apply)
	
	constructor(value: number = 0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0;
	}
	
	reset(): void {
		this.value = 0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readUvarint();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.UVARINT, 28);
		return
	}
}

// companion enum containing all defined constants for WindowSizeClass
export enum WindowSizeClassValues {
	// SizeClassSmall are devices below 640 dp screen width.
	SizeClassSmall = 0,
	// SizeClassMedium are devices below 768dp screen width.
	SizeClassMedium = 1,
	// SizeClassLarge are devices below 1024dp screen width.
	SizeClassLarge = 2,
	// SizeClassXL are devices below 1280dp screen width.
	SizeClassXL = 3,
	// SizeClass2XL are devices below 1536dp screen width.
	SizeClass2XL = 4,
}



// A ScopeConfigurationRequested event can be issued at any time.ConfigurationRequested is issued by the frontend to get the applications general configuration.
// A backend developer has potentially defined a lot of configuration details about the application.
// For example, there may be a color theme, customized icons, image resources, an application name and the available set of navigations, launch intents or other meta information.
// It is expected, that this only happens once during initialization of the frontend process.
export class ScopeConfigurationChangeRequested implements Writeable, Readable , NagoEvent  {
	// RID is used to generate a new component request and is returned in the according response.
	public rID: RID;

		public acceptLanguage: Locale;

		public windowInfo: WindowInfo;

	constructor(rID: RID = new RID(), acceptLanguage: Locale = new Locale(), windowInfo: WindowInfo = new WindowInfo(), ) {
		this.rID = rID;
		this.acceptLanguage = acceptLanguage;
		this.windowInfo = windowInfo;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.rID.read(reader);
					break
				}
				case 2: {
					this.acceptLanguage.read(reader);
					break
				}
				case 3: {
					this.windowInfo.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.rID.isZero(),!this.acceptLanguage.isZero(),!this.windowInfo.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			this.rID.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			this.acceptLanguage.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.RECORD, 3);
			this.windowInfo.write(writer);
		}
	}

	isZero(): boolean {
		return this.rID.isZero() && this.acceptLanguage.isZero() && this.windowInfo.isZero()
	}

	reset(): void {
		this.rID.reset()
		this.acceptLanguage.reset()
		this.windowInfo.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 29);
		return
	}
	isNagoEvent(): void{}
}


// ColorScheme represents which kind of theme shall be rendered.
export class ColorScheme implements Writeable, Readable {
 
	public value: number; // Using number to handle uint64 (precision limits apply)
	
	constructor(value: number = 0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0;
	}
	
	reset(): void {
		this.value = 0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readUvarint();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.UVARINT, 30);
		return
	}
}

// companion enum containing all defined constants for ColorScheme
export enum ColorSchemeValues {
	// Light represents the light theme color mode.
	Light = 0,
	// Dark represents the dark theme color mode.
	Dark = 1,
}



// WindowInfo describes the area into which the frontend renders the ora view tree.
// A user can simply change the layout of the screen, e.g. by rotation the smartphone or
// changing the size of a browser window.
export class WindowInfo implements Writeable, Readable  {
		public width: DP;

		public height: DP;

		public density: Density;

		public sizeClass: WindowSizeClass;

	// ColorScheme which the frontend wants to pick. This may reduce graphical glitches, if the backend creates images or webview resources for the frontend.
	public colorScheme: ColorScheme;

	constructor(width: DP = new DP(), height: DP = new DP(), density: Density = new Density(), sizeClass: WindowSizeClass = new WindowSizeClass(), colorScheme: ColorScheme = new ColorScheme(), ) {
		this.width = width;
		this.height = height;
		this.density = density;
		this.sizeClass = sizeClass;
		this.colorScheme = colorScheme;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.width.read(reader);
					break
				}
				case 2: {
					this.height.read(reader);
					break
				}
				case 3: {
					this.density.read(reader);
					break
				}
				case 4: {
					this.sizeClass.read(reader);
					break
				}
				case 5: {
					this.colorScheme.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.width.isZero(),!this.height.isZero(),!this.density.isZero(),!this.sizeClass.isZero(),!this.colorScheme.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.F64, 1);
			this.width.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.F64, 2);
			this.height.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.F64, 3);
			this.density.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			this.sizeClass.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.UVARINT, 5);
			this.colorScheme.write(writer);
		}
	}

	isZero(): boolean {
		return this.width.isZero() && this.height.isZero() && this.density.isZero() && this.sizeClass.isZero() && this.colorScheme.isZero()
	}

	reset(): void {
		this.width.reset()
		this.height.reset()
		this.density.reset()
		this.sizeClass.reset()
		this.colorScheme.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 31);
		return
	}
}


export class DP implements Writeable, Readable {
 
	public value: number; 
	
	constructor(value: number = 0.0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0.0;
	}
	
	reset(): void {
		this.value = 0.0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeFloat64(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readFloat64();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.F64, 32);
		return
	}
}


export class Density implements Writeable, Readable {
 
	public value: number; 
	
	constructor(value: number = 0.0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0.0;
	}
	
	reset(): void {
		this.value = 0.0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeFloat64(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readFloat64();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.F64, 33);
		return
	}
}


// A ConfigurationDefined event is the response to a [ScopeConfigurationChangeRequested] event.
// According to the locale request, string and svg resources can be localized by the backend.
// The returned locale is the actually picked locale from the requested locale query string.
export class ScopeConfigurationChanged implements Writeable, Readable , NagoEvent  {
		public applicationID: Str;

		public applicationName: Str;

		public applicationVersion: Str;

		public availableLocales: Locales;

		public appIcon: URI;

		public activeLocale: Locale;

		public themes: Themes;

		public rID: RID;

	constructor(applicationID: Str = new Str(), applicationName: Str = new Str(), applicationVersion: Str = new Str(), availableLocales: Locales = new Locales(), appIcon: URI = new URI(), activeLocale: Locale = new Locale(), themes: Themes = new Themes(), rID: RID = new RID(), ) {
		this.applicationID = applicationID;
		this.applicationName = applicationName;
		this.applicationVersion = applicationVersion;
		this.availableLocales = availableLocales;
		this.appIcon = appIcon;
		this.activeLocale = activeLocale;
		this.themes = themes;
		this.rID = rID;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.applicationID.read(reader);
					break
				}
				case 2: {
					this.applicationName.read(reader);
					break
				}
				case 3: {
					this.applicationVersion.read(reader);
					break
				}
				case 4: {
					this.availableLocales.read(reader);
					break
				}
				case 5: {
					this.appIcon.read(reader);
					break
				}
				case 6: {
					this.activeLocale.read(reader);
					break
				}
				case 7: {
					this.themes.read(reader);
					break
				}
				case 8: {
					this.rID.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.applicationID.isZero(),!this.applicationName.isZero(),!this.applicationVersion.isZero(),!this.availableLocales.isZero(),!this.appIcon.isZero(),!this.activeLocale.isZero(),!this.themes.isZero(),!this.rID.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			this.applicationID.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			this.applicationName.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			this.applicationVersion.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.ARRAY, 4);
			this.availableLocales.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			this.appIcon.write(writer);
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 6);
			this.activeLocale.write(writer);
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.RECORD, 7);
			this.themes.write(writer);
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.UVARINT, 8);
			this.rID.write(writer);
		}
	}

	isZero(): boolean {
		return this.applicationID.isZero() && this.applicationName.isZero() && this.applicationVersion.isZero() && this.availableLocales.isZero() && this.appIcon.isZero() && this.activeLocale.isZero() && this.themes.isZero() && this.rID.isZero()
	}

	reset(): void {
		this.applicationID.reset()
		this.applicationName.reset()
		this.applicationVersion.reset()
		this.availableLocales.reset()
		this.appIcon.reset()
		this.activeLocale.reset()
		this.themes.reset()
		this.rID.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 34);
		return
	}
	isNagoEvent(): void{}
}


// Locales is just a bunch of locales.
export class Locales implements Writeable, Readable  {
	public value: Locale[];
	
	constructor(value: Locale[] = []) {
 
      this.value = value;
    }

  isZero(): boolean {
	return !this.value || this.value.length === 0;
  }

  reset(): void {
	this.value = [];
  }


  write(writer: BinaryWriter): void {
	writer.writeUvarint(this.value.length); // Write the length of the array
	for (const c of this.value) {
	  c.writeTypeHeader(writer); // Write the type header for each component
	  c.write(writer); // Write the component data
	}
  }

	  
  read(reader: BinaryReader): void {
	const count = reader.readUvarint(); // Read the length of the array
	const values: Locale[] = [];

	for (let i = 0; i < count; i++) {
	  const obj = unmarshal(reader); // Read and unmarshal each component
	  values.push(obj as Locale); // Cast and add to the array
	}

	this.value = values;
  }	
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 35);
		return
	}
}


// URI is just a string which looks like an URI or URL
export class URI implements Writeable, Readable {
 
  public value: string; 

  constructor(value: string = "") {
    this.value = value;
  }

  isZero(): boolean {
    return this.value === "";
  }

  reset(): void {
    this.value = "";
  }

  // Get the string representation of the Color
  toString(): string {
    return this.value;
  }

  write(writer: BinaryWriter): void {
    const data = new TextEncoder().encode(this.value); // Convert string to Uint8Array
    writer.writeUvarint(data.length); // Write the length of the string
    writer.write(data); // Write the string data
  }

  read(reader: BinaryReader): void {
	const strLen = reader.readUvarint(); // Read the length of the string
    const buf = reader.readBytes(strLen); // Read the string data
    this.value = new TextDecoder().decode(buf); // Convert Uint8Array to string
  }

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.BYTESLICE, 36);
		return
	}
}


// NamespaceName refers to a component or views namespace declaration. Besides the universe space, this is almost relevant for the backend, however it defines variables at the frontend, thus it may open some optimizations.
export class NamespaceName implements Writeable, Readable {
 
  public value: string; 

  constructor(value: string = "") {
    this.value = value;
  }

  isZero(): boolean {
    return this.value === "";
  }

  reset(): void {
    this.value = "";
  }

  // Get the string representation of the Color
  toString(): string {
    return this.value;
  }

  write(writer: BinaryWriter): void {
    const data = new TextEncoder().encode(this.value); // Convert string to Uint8Array
    writer.writeUvarint(data.length); // Write the length of the string
    writer.write(data); // Write the string data
  }

  read(reader: BinaryReader): void {
	const strLen = reader.readUvarint(); // Read the length of the string
    const buf = reader.readBytes(strLen); // Read the string data
    this.value = new TextDecoder().decode(buf); // Convert Uint8Array to string
  }

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.BYTESLICE, 37);
		return
	}
}


// NamedColors represents a map of names with associated color values.
export class NamedColors implements Writeable, Readable  {
	public value: Map<Str,Color>;
	
	constructor(value: Map<Str,Color> = new Map<Str,Color>()) {
	 
      this.value = value;
    }

  isZero(): boolean {
	return !this.value || this.value.size === 0;
  }

  reset(): void {
	this.value = new Map<Str,Color>();
  }


  write(writer: BinaryWriter): void {
	writer.writeUvarint(this.value.size); // Write the length of the map
	for (const [key, value] of this.value) {
      // write key
	  key.writeTypeHeader(writer); 
	  key.write(writer); 

      // write value
	  value.writeTypeHeader(writer); 
	  value.write(writer); 
	}
  }

	  
  read(reader: BinaryReader): void {
	const count = reader.readUvarint(); 
	const values = new Map<Str,Color>();

	for (let i = 0; i < count; i++) {
	  const key = unmarshal(reader);
      const val = unmarshal(reader);

	  values.set(key as Str, val as Color); 
	}

	this.value = values;
  }	
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 38);
		return
	}
}


// A Theme aggregates colors (for distinct) namespaces and lengths. Usually, this represents the light or dark mode.
export class Theme implements Writeable, Readable  {
		public colors: NamespacedColors;

		public lengths: NamedLengths;

	constructor(colors: NamespacedColors = new NamespacedColors(), lengths: NamedLengths = new NamedLengths(), ) {
		this.colors = colors;
		this.lengths = lengths;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.colors.read(reader);
					break
				}
				case 2: {
					this.lengths.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.colors.isZero(),!this.lengths.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			this.colors.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.ARRAY, 2);
			this.lengths.write(writer);
		}
	}

	isZero(): boolean {
		return this.colors.isZero() && this.lengths.isZero()
	}

	reset(): void {
		this.colors.reset()
		this.lengths.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 39);
		return
	}
}


// NamespacedColors represents a map of namespaces with associated color values.
export class NamespacedColors implements Writeable, Readable  {
	public value: Map<NamespaceName,NamedColors>;
	
	constructor(value: Map<NamespaceName,NamedColors> = new Map<NamespaceName,NamedColors>()) {
	 
      this.value = value;
    }

  isZero(): boolean {
	return !this.value || this.value.size === 0;
  }

  reset(): void {
	this.value = new Map<NamespaceName,NamedColors>();
  }


  write(writer: BinaryWriter): void {
	writer.writeUvarint(this.value.size); // Write the length of the map
	for (const [key, value] of this.value) {
      // write key
	  key.writeTypeHeader(writer); 
	  key.write(writer); 

      // write value
	  value.writeTypeHeader(writer); 
	  value.write(writer); 
	}
  }

	  
  read(reader: BinaryReader): void {
	const count = reader.readUvarint(); 
	const values = new Map<NamespaceName,NamedColors>();

	for (let i = 0; i < count; i++) {
	  const key = unmarshal(reader);
      const val = unmarshal(reader);

	  values.set(key as NamespaceName, val as NamedColors); 
	}

	this.value = values;
  }	
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 40);
		return
	}
}


// NamedLengths represents a map of names with associated length values.
export class NamedLengths implements Writeable, Readable  {
	public value: Map<Str,Length>;
	
	constructor(value: Map<Str,Length> = new Map<Str,Length>()) {
	 
      this.value = value;
    }

  isZero(): boolean {
	return !this.value || this.value.size === 0;
  }

  reset(): void {
	this.value = new Map<Str,Length>();
  }


  write(writer: BinaryWriter): void {
	writer.writeUvarint(this.value.size); // Write the length of the map
	for (const [key, value] of this.value) {
      // write key
	  key.writeTypeHeader(writer); 
	  key.write(writer); 

      // write value
	  value.writeTypeHeader(writer); 
	  value.write(writer); 
	}
  }

	  
  read(reader: BinaryReader): void {
	const count = reader.readUvarint(); 
	const values = new Map<Str,Length>();

	for (let i = 0; i < count; i++) {
	  const key = unmarshal(reader);
      const val = unmarshal(reader);

	  values.set(key as Str, val as Length); 
	}

	this.value = values;
  }	
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 41);
		return
	}
}


// Themes represents light or dark mode colors.
export class Themes implements Writeable, Readable  {
		public light: Theme;

		public dark: Theme;

	constructor(light: Theme = new Theme(), dark: Theme = new Theme(), ) {
		this.light = light;
		this.dark = dark;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.light.read(reader);
					break
				}
				case 2: {
					this.dark.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.light.isZero(),!this.dark.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.RECORD, 1);
			this.light.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.RECORD, 2);
			this.dark.write(writer);
		}
	}

	isZero(): boolean {
		return this.light.isZero() && this.dark.isZero()
	}

	reset(): void {
		this.light.reset()
		this.dark.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 42);
		return
	}
}


export class DatePickerStyle implements Writeable, Readable {
 
	public value: number; // Using number to handle uint64 (precision limits apply)
	
	constructor(value: number = 0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0;
	}
	
	reset(): void {
		this.value = 0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readUvarint();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.UVARINT, 43);
		return
	}
}

// companion enum containing all defined constants for DatePickerStyle
export enum DatePickerStyleValues {
		DatePickerSingleDate = 0,
		DatePickerDateRange = 1,
}



// Day represents a day in month in the range 1-31.
export class Day implements Writeable, Readable {
 
	public value: number; // Using number to handle uint64 (precision limits apply)
	
	constructor(value: number = 0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0;
	}
	
	reset(): void {
		this.value = 0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readUvarint();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.UVARINT, 44);
		return
	}
}


// Date represents a location-free representation of a day/month/year tuple.
export class DateData implements Writeable, Readable  {
		public day: Day;

		public month: Month;

		public year: Year;

	constructor(day: Day = new Day(), month: Month = new Month(), year: Year = new Year(), ) {
		this.day = day;
		this.month = month;
		this.year = year;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.day.read(reader);
					break
				}
				case 2: {
					this.month.read(reader);
					break
				}
				case 3: {
					this.year.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.day.isZero(),!this.month.isZero(),!this.year.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			this.day.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			this.month.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			this.year.write(writer);
		}
	}

	isZero(): boolean {
		return this.day.isZero() && this.month.isZero() && this.year.isZero()
	}

	reset(): void {
		this.day.reset()
		this.month.reset()
		this.year.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 45);
		return
	}
}


// Month represents a month in the range 1-12.
export class Month implements Writeable, Readable {
 
	public value: number; // Using number to handle uint64 (precision limits apply)
	
	constructor(value: number = 0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0;
	}
	
	reset(): void {
		this.value = 0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readUvarint();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.UVARINT, 46);
		return
	}
}


// Year represents a year in the gregorian calendar.
export class Year implements Writeable, Readable {
 
	public value: number; // Using number to handle uint64 (precision limits apply)
	
	constructor(value: number = 0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0;
	}
	
	reset(): void {
		this.value = 0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readUvarint();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.UVARINT, 47);
		return
	}
}


export class DatePicker implements Writeable, Readable , Component  {
		public label: Str;

		public supportingText: Str;

	// ErrorText is shown instead of SupportingText, even if they are (today) independent
	public errorText: Str;

	// Style determines if the picker shall use the range or single mode. Default is single selection
	public style: DatePickerStyle;

	// Value is the initial single value or start value of the picker.
	public value: DateData;

	// InputValue is the picked single value or end value of the picker.
	public inputValue: Ptr;

	// EndValue is the initial end value of the picker.
	public endValue: DateData;

	// EndInputValue is the picked end value of the picker.
	public endInputValue: Ptr;

		public frame: Frame;

		public invisible: Bool;

		public disabled: Bool;

	constructor(label: Str = new Str(), supportingText: Str = new Str(), errorText: Str = new Str(), style: DatePickerStyle = new DatePickerStyle(), value: DateData = new DateData(), inputValue: Ptr = new Ptr(), endValue: DateData = new DateData(), endInputValue: Ptr = new Ptr(), frame: Frame = new Frame(), invisible: Bool = new Bool(), disabled: Bool = new Bool(), ) {
		this.label = label;
		this.supportingText = supportingText;
		this.errorText = errorText;
		this.style = style;
		this.value = value;
		this.inputValue = inputValue;
		this.endValue = endValue;
		this.endInputValue = endInputValue;
		this.frame = frame;
		this.invisible = invisible;
		this.disabled = disabled;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.label.read(reader);
					break
				}
				case 2: {
					this.supportingText.read(reader);
					break
				}
				case 3: {
					this.errorText.read(reader);
					break
				}
				case 4: {
					this.style.read(reader);
					break
				}
				case 5: {
					this.value.read(reader);
					break
				}
				case 6: {
					this.inputValue.read(reader);
					break
				}
				case 7: {
					this.endValue.read(reader);
					break
				}
				case 8: {
					this.endInputValue.read(reader);
					break
				}
				case 9: {
					this.frame.read(reader);
					break
				}
				case 10: {
					this.invisible.read(reader);
					break
				}
				case 11: {
					this.disabled.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.label.isZero(),!this.supportingText.isZero(),!this.errorText.isZero(),!this.style.isZero(),!this.value.isZero(),!this.inputValue.isZero(),!this.endValue.isZero(),!this.endInputValue.isZero(),!this.frame.isZero(),!this.invisible.isZero(),!this.disabled.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			this.label.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			this.supportingText.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			this.errorText.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			this.style.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.RECORD, 5);
			this.value.write(writer);
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.UVARINT, 6);
			this.inputValue.write(writer);
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.RECORD, 7);
			this.endValue.write(writer);
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.UVARINT, 8);
			this.endInputValue.write(writer);
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.RECORD, 9);
			this.frame.write(writer);
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.UVARINT, 10);
			this.invisible.write(writer);
		}
		if (fields[11]) {
			writer.writeFieldHeader(Shapes.UVARINT, 11);
			this.disabled.write(writer);
		}
	}

	isZero(): boolean {
		return this.label.isZero() && this.supportingText.isZero() && this.errorText.isZero() && this.style.isZero() && this.value.isZero() && this.inputValue.isZero() && this.endValue.isZero() && this.endInputValue.isZero() && this.frame.isZero() && this.invisible.isZero() && this.disabled.isZero()
	}

	reset(): void {
		this.label.reset()
		this.supportingText.reset()
		this.errorText.reset()
		this.style.reset()
		this.value.reset()
		this.inputValue.reset()
		this.endValue.reset()
		this.endInputValue.reset()
		this.frame.reset()
		this.invisible.reset()
		this.disabled.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 48);
		return
	}
	isComponent(): void{}
}


export class Divider implements Writeable, Readable , Component  {
		public frame: Frame;

		public border: Border;

		public padding: Padding;

	constructor(frame: Frame = new Frame(), border: Border = new Border(), padding: Padding = new Padding(), ) {
		this.frame = frame;
		this.border = border;
		this.padding = padding;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.frame.read(reader);
					break
				}
				case 2: {
					this.border.read(reader);
					break
				}
				case 3: {
					this.padding.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.frame.isZero(),!this.border.isZero(),!this.padding.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.RECORD, 1);
			this.frame.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.RECORD, 2);
			this.border.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.RECORD, 3);
			this.padding.write(writer);
		}
	}

	isZero(): boolean {
		return this.frame.isZero() && this.border.isZero() && this.padding.isZero()
	}

	reset(): void {
		this.frame.reset()
		this.border.reset()
		this.padding.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 49);
		return
	}
	isComponent(): void{}
}


export class RID implements Writeable, Readable {
 
	public value: number; // Using number to handle uint64 (precision limits apply)
	
	constructor(value: number = 0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0;
	}
	
	reset(): void {
		this.value = 0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readUvarint();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.UVARINT, 50);
		return
	}
}

// companion enum containing all defined constants for RID
export enum RIDValues {
		NormalFontStyle = 0,
		ItalicFontStyle = 1,
}



export class FontWeight implements Writeable, Readable {
 
	public value: number; // Using number to handle uint64 (precision limits apply)
	
	constructor(value: number = 0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0;
	}
	
	reset(): void {
		this.value = 0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readUvarint();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.UVARINT, 51);
		return
	}
}

// companion enum containing all defined constants for FontWeight
export enum FontWeightValues {
		NormalFontWeight = 400,
		BoldFontWeight = 700,
}



export class Font implements Writeable, Readable  {
	// Name of the font or family name as fallback. Extra fallback declarations are unspecified and must be comma separated.
	public name: Str;

		public size: Length;

		public style: FontStyle;

		public weight: FontWeight;

	constructor(name: Str = new Str(), size: Length = new Length(), style: FontStyle = new FontStyle(), weight: FontWeight = new FontWeight(), ) {
		this.name = name;
		this.size = size;
		this.style = style;
		this.weight = weight;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.name.read(reader);
					break
				}
				case 2: {
					this.size.read(reader);
					break
				}
				case 3: {
					this.style.read(reader);
					break
				}
				case 4: {
					this.weight.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.name.isZero(),!this.size.isZero(),!this.style.isZero(),!this.weight.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			this.name.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			this.size.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			this.style.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			this.weight.write(writer);
		}
	}

	isZero(): boolean {
		return this.name.isZero() && this.size.isZero() && this.style.isZero() && this.weight.isZero()
	}

	reset(): void {
		this.name.reset()
		this.size.reset()
		this.style.reset()
		this.weight.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 52);
		return
	}
}


// A Grid must support up to 12 Columns and a reasonable "unlimited" amount of rows.
export class Grid implements Writeable, Readable , Component  {
		public cells: GridCells;

		public rows: Uint;

		public columns: Uint;

		public rowGap: Length;

		public colGap: Length;

		public frame: Frame;

		public backgroundColor: Color;

		public padding: Padding;

		public border: Border;

		public accessibilityLabel: Str;

		public font: Font;

		public colWidths: Lengths;

		public invisible: Bool;

	constructor(cells: GridCells = new GridCells(), rows: Uint = new Uint(), columns: Uint = new Uint(), rowGap: Length = new Length(), colGap: Length = new Length(), frame: Frame = new Frame(), backgroundColor: Color = new Color(), padding: Padding = new Padding(), border: Border = new Border(), accessibilityLabel: Str = new Str(), font: Font = new Font(), colWidths: Lengths = new Lengths(), invisible: Bool = new Bool(), ) {
		this.cells = cells;
		this.rows = rows;
		this.columns = columns;
		this.rowGap = rowGap;
		this.colGap = colGap;
		this.frame = frame;
		this.backgroundColor = backgroundColor;
		this.padding = padding;
		this.border = border;
		this.accessibilityLabel = accessibilityLabel;
		this.font = font;
		this.colWidths = colWidths;
		this.invisible = invisible;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.cells.read(reader);
					break
				}
				case 2: {
					this.rows.read(reader);
					break
				}
				case 3: {
					this.columns.read(reader);
					break
				}
				case 4: {
					this.rowGap.read(reader);
					break
				}
				case 5: {
					this.colGap.read(reader);
					break
				}
				case 6: {
					this.frame.read(reader);
					break
				}
				case 7: {
					this.backgroundColor.read(reader);
					break
				}
				case 8: {
					this.padding.read(reader);
					break
				}
				case 9: {
					this.border.read(reader);
					break
				}
				case 10: {
					this.accessibilityLabel.read(reader);
					break
				}
				case 11: {
					this.font.read(reader);
					break
				}
				case 12: {
					this.colWidths.read(reader);
					break
				}
				case 13: {
					this.invisible.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.cells.isZero(),!this.rows.isZero(),!this.columns.isZero(),!this.rowGap.isZero(),!this.colGap.isZero(),!this.frame.isZero(),!this.backgroundColor.isZero(),!this.padding.isZero(),!this.border.isZero(),!this.accessibilityLabel.isZero(),!this.font.isZero(),!this.colWidths.isZero(),!this.invisible.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			this.cells.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			this.rows.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			this.columns.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			this.rowGap.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			this.colGap.write(writer);
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.RECORD, 6);
			this.frame.write(writer);
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 7);
			this.backgroundColor.write(writer);
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.RECORD, 8);
			this.padding.write(writer);
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.RECORD, 9);
			this.border.write(writer);
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 10);
			this.accessibilityLabel.write(writer);
		}
		if (fields[11]) {
			writer.writeFieldHeader(Shapes.RECORD, 11);
			this.font.write(writer);
		}
		if (fields[12]) {
			writer.writeFieldHeader(Shapes.ARRAY, 12);
			this.colWidths.write(writer);
		}
		if (fields[13]) {
			writer.writeFieldHeader(Shapes.UVARINT, 13);
			this.invisible.write(writer);
		}
	}

	isZero(): boolean {
		return this.cells.isZero() && this.rows.isZero() && this.columns.isZero() && this.rowGap.isZero() && this.colGap.isZero() && this.frame.isZero() && this.backgroundColor.isZero() && this.padding.isZero() && this.border.isZero() && this.accessibilityLabel.isZero() && this.font.isZero() && this.colWidths.isZero() && this.invisible.isZero()
	}

	reset(): void {
		this.cells.reset()
		this.rows.reset()
		this.columns.reset()
		this.rowGap.reset()
		this.colGap.reset()
		this.frame.reset()
		this.backgroundColor.reset()
		this.padding.reset()
		this.border.reset()
		this.accessibilityLabel.reset()
		this.font.reset()
		this.colWidths.reset()
		this.invisible.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 53);
		return
	}
	isComponent(): void{}
}


// Uint represents just a user defined unsigned integer value. This is how nprotoc works.
export class Uint implements Writeable, Readable {
 
	public value: number; // Using number to handle uint64 (precision limits apply)
	
	constructor(value: number = 0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0;
	}
	
	reset(): void {
		this.value = 0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readUvarint();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.UVARINT, 54);
		return
	}
}


// GridCells is just a bunch of GridCells.
export class GridCells implements Writeable, Readable  {
	public value: GridCell[];
	
	constructor(value: GridCell[] = []) {
 
      this.value = value;
    }

  isZero(): boolean {
	return !this.value || this.value.length === 0;
  }

  reset(): void {
	this.value = [];
  }


  write(writer: BinaryWriter): void {
	writer.writeUvarint(this.value.length); // Write the length of the array
	for (const c of this.value) {
	  c.writeTypeHeader(writer); // Write the type header for each component
	  c.write(writer); // Write the component data
	}
  }

	  
  read(reader: BinaryReader): void {
	const count = reader.readUvarint(); // Read the length of the array
	const values: GridCell[] = [];

	for (let i = 0; i < count; i++) {
	  const obj = unmarshal(reader); // Read and unmarshal each component
	  values.push(obj as GridCell); // Cast and add to the array
	}

	this.value = values;
  }	
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 55);
		return
	}
}


// Lengths is just a bunch of length values.
export class Lengths implements Writeable, Readable  {
	public value: Length[];
	
	constructor(value: Length[] = []) {
 
      this.value = value;
    }

  isZero(): boolean {
	return !this.value || this.value.length === 0;
  }

  reset(): void {
	this.value = [];
  }


  write(writer: BinaryWriter): void {
	writer.writeUvarint(this.value.length); // Write the length of the array
	for (const c of this.value) {
	  c.writeTypeHeader(writer); // Write the type header for each component
	  c.write(writer); // Write the component data
	}
  }

	  
  read(reader: BinaryReader): void {
	const count = reader.readUvarint(); // Read the length of the array
	const values: Length[] = [];

	for (let i = 0; i < count; i++) {
	  const obj = unmarshal(reader); // Read and unmarshal each component
	  values.push(obj as Length); // Cast and add to the array
	}

	this.value = values;
  }	
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 56);
		return
	}
}


// GridCell is undefined, if explicit row start/col start etc. is set and span values.
export class GridCell implements Writeable, Readable  {
		public body?: Component;

		public colStart: Uint;

		public colEnd: Uint;

		public rowStart: Uint;

		public rowEnd: Uint;

		public colSpan: Uint;

		public rowSpan: Uint;

		public padding: Padding;

		public alignment: Alignment;

	constructor(body = undefined, colStart: Uint = new Uint(), colEnd: Uint = new Uint(), rowStart: Uint = new Uint(), rowEnd: Uint = new Uint(), colSpan: Uint = new Uint(), rowSpan: Uint = new Uint(), padding: Padding = new Padding(), alignment: Alignment = new Alignment(), ) {
		this.body = body;
		this.colStart = colStart;
		this.colEnd = colEnd;
		this.rowStart = rowStart;
		this.rowEnd = rowEnd;
		this.colSpan = colSpan;
		this.rowSpan = rowSpan;
		this.padding = padding;
		this.alignment = alignment;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
					  throw new Error(`unexpected length: ` + len);
					}
					this.body = unmarshal(reader) as Component;
					break
				}
				case 2: {
					this.colStart.read(reader);
					break
				}
				case 3: {
					this.colEnd.read(reader);
					break
				}
				case 4: {
					this.rowStart.read(reader);
					break
				}
				case 5: {
					this.rowEnd.read(reader);
					break
				}
				case 6: {
					this.colSpan.read(reader);
					break
				}
				case 7: {
					this.rowSpan.read(reader);
					break
				}
				case 8: {
					this.padding.read(reader);
					break
				}
				case 9: {
					this.alignment.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,this.body!== undefined && !this.body.isZero(),!this.colStart.isZero(),!this.colEnd.isZero(),!this.rowStart.isZero(),!this.rowEnd.isZero(),!this.colSpan.isZero(),!this.rowSpan.isZero(),!this.padding.isZero(),!this.alignment.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			writer.writeByte(1);
			this.body!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			this.colStart.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			this.colEnd.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			this.rowStart.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.UVARINT, 5);
			this.rowEnd.write(writer);
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.UVARINT, 6);
			this.colSpan.write(writer);
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.UVARINT, 7);
			this.rowSpan.write(writer);
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.RECORD, 8);
			this.padding.write(writer);
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.UVARINT, 9);
			this.alignment.write(writer);
		}
	}

	isZero(): boolean {
		return (this.body=== undefined || this.body.isZero()) && this.colStart.isZero() && this.colEnd.isZero() && this.rowStart.isZero() && this.rowEnd.isZero() && this.colSpan.isZero() && this.rowSpan.isZero() && this.padding.isZero() && this.alignment.isZero()
	}

	reset(): void {
		this.body = undefined
		this.colStart.reset()
		this.colEnd.reset()
		this.rowStart.reset()
		this.rowEnd.reset()
		this.colSpan.reset()
		this.rowSpan.reset()
		this.padding.reset()
		this.alignment.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 57);
		return
	}
}


// An HStack aligns children elements in a horizontal row.
//  - the intrinsic component dimensions are the sum of all sizes of the contained children
//  - the parent can define a custom width and height
//  - if the container is larger than the contained views, it must center vertical or horizontal
//  - the inner gap between components should be around 2dp (this decides the backend)
export class HStack implements Writeable, Readable , Component  {
		public children: Components;

		public gap: Length;

		public frame: Frame;

	// Zero value of Alignment is Center (=c) must be applied.
	public alignment: Alignment;

		public backgroundColor: Color;

		public padding: Padding;

	// see also https://www.w3.org/WAI/tutorials/images/decision-tree/
	public accessibilityLabel: Str;

		public border: Border;

		public font: Font;

		public action: Ptr;

		public hoveredBackgroundColor: Color;

		public pressedBackgroundColor: Color;

		public focusedBackgroundColor: Color;

		public hoveredBorder: Border;

		public pressedBorder: Border;

		public focusedBorder: Border;

		public wrap: Bool;

		public stylePreset: StylePreset;

		public position: Position;

		public disabled: Bool;

		public invisible: Bool;

	constructor(children: Components = new Components(), gap: Length = new Length(), frame: Frame = new Frame(), alignment: Alignment = new Alignment(), backgroundColor: Color = new Color(), padding: Padding = new Padding(), accessibilityLabel: Str = new Str(), border: Border = new Border(), font: Font = new Font(), action: Ptr = new Ptr(), hoveredBackgroundColor: Color = new Color(), pressedBackgroundColor: Color = new Color(), focusedBackgroundColor: Color = new Color(), hoveredBorder: Border = new Border(), pressedBorder: Border = new Border(), focusedBorder: Border = new Border(), wrap: Bool = new Bool(), stylePreset: StylePreset = new StylePreset(), position: Position = new Position(), disabled: Bool = new Bool(), invisible: Bool = new Bool(), ) {
		this.children = children;
		this.gap = gap;
		this.frame = frame;
		this.alignment = alignment;
		this.backgroundColor = backgroundColor;
		this.padding = padding;
		this.accessibilityLabel = accessibilityLabel;
		this.border = border;
		this.font = font;
		this.action = action;
		this.hoveredBackgroundColor = hoveredBackgroundColor;
		this.pressedBackgroundColor = pressedBackgroundColor;
		this.focusedBackgroundColor = focusedBackgroundColor;
		this.hoveredBorder = hoveredBorder;
		this.pressedBorder = pressedBorder;
		this.focusedBorder = focusedBorder;
		this.wrap = wrap;
		this.stylePreset = stylePreset;
		this.position = position;
		this.disabled = disabled;
		this.invisible = invisible;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.children.read(reader);
					break
				}
				case 2: {
					this.gap.read(reader);
					break
				}
				case 3: {
					this.frame.read(reader);
					break
				}
				case 4: {
					this.alignment.read(reader);
					break
				}
				case 5: {
					this.backgroundColor.read(reader);
					break
				}
				case 6: {
					this.padding.read(reader);
					break
				}
				case 7: {
					this.accessibilityLabel.read(reader);
					break
				}
				case 8: {
					this.border.read(reader);
					break
				}
				case 9: {
					this.font.read(reader);
					break
				}
				case 10: {
					this.action.read(reader);
					break
				}
				case 11: {
					this.hoveredBackgroundColor.read(reader);
					break
				}
				case 12: {
					this.pressedBackgroundColor.read(reader);
					break
				}
				case 13: {
					this.focusedBackgroundColor.read(reader);
					break
				}
				case 14: {
					this.hoveredBorder.read(reader);
					break
				}
				case 15: {
					this.pressedBorder.read(reader);
					break
				}
				case 16: {
					this.focusedBorder.read(reader);
					break
				}
				case 17: {
					this.wrap.read(reader);
					break
				}
				case 18: {
					this.stylePreset.read(reader);
					break
				}
				case 19: {
					this.position.read(reader);
					break
				}
				case 20: {
					this.disabled.read(reader);
					break
				}
				case 21: {
					this.invisible.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.children.isZero(),!this.gap.isZero(),!this.frame.isZero(),!this.alignment.isZero(),!this.backgroundColor.isZero(),!this.padding.isZero(),!this.accessibilityLabel.isZero(),!this.border.isZero(),!this.font.isZero(),!this.action.isZero(),!this.hoveredBackgroundColor.isZero(),!this.pressedBackgroundColor.isZero(),!this.focusedBackgroundColor.isZero(),!this.hoveredBorder.isZero(),!this.pressedBorder.isZero(),!this.focusedBorder.isZero(),!this.wrap.isZero(),!this.stylePreset.isZero(),!this.position.isZero(),!this.disabled.isZero(),!this.invisible.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			this.children.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			this.gap.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.RECORD, 3);
			this.frame.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			this.alignment.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			this.backgroundColor.write(writer);
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.RECORD, 6);
			this.padding.write(writer);
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 7);
			this.accessibilityLabel.write(writer);
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.RECORD, 8);
			this.border.write(writer);
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.RECORD, 9);
			this.font.write(writer);
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.UVARINT, 10);
			this.action.write(writer);
		}
		if (fields[11]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 11);
			this.hoveredBackgroundColor.write(writer);
		}
		if (fields[12]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 12);
			this.pressedBackgroundColor.write(writer);
		}
		if (fields[13]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 13);
			this.focusedBackgroundColor.write(writer);
		}
		if (fields[14]) {
			writer.writeFieldHeader(Shapes.RECORD, 14);
			this.hoveredBorder.write(writer);
		}
		if (fields[15]) {
			writer.writeFieldHeader(Shapes.RECORD, 15);
			this.pressedBorder.write(writer);
		}
		if (fields[16]) {
			writer.writeFieldHeader(Shapes.RECORD, 16);
			this.focusedBorder.write(writer);
		}
		if (fields[17]) {
			writer.writeFieldHeader(Shapes.UVARINT, 17);
			this.wrap.write(writer);
		}
		if (fields[18]) {
			writer.writeFieldHeader(Shapes.UVARINT, 18);
			this.stylePreset.write(writer);
		}
		if (fields[19]) {
			writer.writeFieldHeader(Shapes.RECORD, 19);
			this.position.write(writer);
		}
		if (fields[20]) {
			writer.writeFieldHeader(Shapes.UVARINT, 20);
			this.disabled.write(writer);
		}
		if (fields[21]) {
			writer.writeFieldHeader(Shapes.UVARINT, 21);
			this.invisible.write(writer);
		}
	}

	isZero(): boolean {
		return this.children.isZero() && this.gap.isZero() && this.frame.isZero() && this.alignment.isZero() && this.backgroundColor.isZero() && this.padding.isZero() && this.accessibilityLabel.isZero() && this.border.isZero() && this.font.isZero() && this.action.isZero() && this.hoveredBackgroundColor.isZero() && this.pressedBackgroundColor.isZero() && this.focusedBackgroundColor.isZero() && this.hoveredBorder.isZero() && this.pressedBorder.isZero() && this.focusedBorder.isZero() && this.wrap.isZero() && this.stylePreset.isZero() && this.position.isZero() && this.disabled.isZero() && this.invisible.isZero()
	}

	reset(): void {
		this.children.reset()
		this.gap.reset()
		this.frame.reset()
		this.alignment.reset()
		this.backgroundColor.reset()
		this.padding.reset()
		this.accessibilityLabel.reset()
		this.border.reset()
		this.font.reset()
		this.action.reset()
		this.hoveredBackgroundColor.reset()
		this.pressedBackgroundColor.reset()
		this.focusedBackgroundColor.reset()
		this.hoveredBorder.reset()
		this.pressedBorder.reset()
		this.focusedBorder.reset()
		this.wrap.reset()
		this.stylePreset.reset()
		this.position.reset()
		this.disabled.reset()
		this.invisible.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 58);
		return
	}
	isComponent(): void{}
}


// StylePreset allows to apply a build-in style to this component. This reduces over-the-wire boilerplate and
// also defines a stereotype, so that the applied component behavior may be indeed a bit different, because
// a native component may be used, e.g. for a native button. The order of appliance is first the preset and
// then customized properties on top.
// 
export class StylePreset implements Writeable, Readable {
 
	public value: number; // Using number to handle uint64 (precision limits apply)
	
	constructor(value: number = 0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0;
	}
	
	reset(): void {
		this.value = 0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readUvarint();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.UVARINT, 59);
		return
	}
}

// companion enum containing all defined constants for StylePreset
export enum StylePresetValues {
	// Default is that no style preset is applied.
	StyleNone = 0,
		StyleButtonPrimary = 1,
		StyleButtonSecondary = 2,
		StyleButtonTertiary = 3,
}



export class Position implements Writeable, Readable  {
		public kind: PositionType;

		public left: Length;

		public top: Length;

		public right: Length;

		public bottom: Length;

	constructor(kind: PositionType = new PositionType(), left: Length = new Length(), top: Length = new Length(), right: Length = new Length(), bottom: Length = new Length(), ) {
		this.kind = kind;
		this.left = left;
		this.top = top;
		this.right = right;
		this.bottom = bottom;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.kind.read(reader);
					break
				}
				case 2: {
					this.left.read(reader);
					break
				}
				case 3: {
					this.top.read(reader);
					break
				}
				case 4: {
					this.right.read(reader);
					break
				}
				case 5: {
					this.bottom.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.kind.isZero(),!this.left.isZero(),!this.top.isZero(),!this.right.isZero(),!this.bottom.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			this.kind.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			this.left.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			this.top.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			this.right.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			this.bottom.write(writer);
		}
	}

	isZero(): boolean {
		return this.kind.isZero() && this.left.isZero() && this.top.isZero() && this.right.isZero() && this.bottom.isZero()
	}

	reset(): void {
		this.kind.reset()
		this.left.reset()
		this.top.reset()
		this.right.reset()
		this.bottom.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 60);
		return
	}
}


export class PositionType implements Writeable, Readable {
 
	public value: number; // Using number to handle uint64 (precision limits apply)
	
	constructor(value: number = 0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0;
	}
	
	reset(): void {
		this.value = 0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readUvarint();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.UVARINT, 61);
		return
	}
}

// companion enum containing all defined constants for PositionType
export enum PositionTypeValues {
	// PositionDefault is the default and any explicit position value have no effect.
//  See also https://developer.mozilla.org/de/docs/Web/CSS/position#static.
	PositionDefault = 0,
	// PositionOffset is like PositionDefault but moves the element by applying the given position values after
//  layouting. See also https://developer.mozilla.org/de/docs/Web/CSS/position#relative.
	PositionOffset = 1,
	// PositionAbsolute removes the element from the layout and places it using the given values in an absolute way
//  within any of its parent layouted as PositionOffset. If no parent with PositionOffset is found, the viewport
//  is used. See also https://developer.mozilla.org/de/docs/Web/CSS/position#absolute.
	PositionAbsolute = 2,
	// PositionFixed removes the element from the layout and places it at a fixed position according to the viewport
//  independent of the scroll position. See also https://developer.mozilla.org/de/docs/Web/CSS/position#absolute.
	PositionFixed = 3,
	// PositionSticky is here for completion, and it is unclear which rules to follow on mobile clients.
//  See also https://developer.mozilla.org/de/docs/Web/CSS/position#absolute.
	PositionSticky = 4,
}



export class Img implements Writeable, Readable , Component  {
		public uri: URI;

		public accessibilityLabel: Str;

		public border: Border;

		public frame: Frame;

		public padding: Padding;

		public sVG: SVG;

		public fillColor: Color;

		public strokeColor: Color;

		public invisible: Bool;

	constructor(uri: URI = new URI(), accessibilityLabel: Str = new Str(), border: Border = new Border(), frame: Frame = new Frame(), padding: Padding = new Padding(), sVG: SVG = new SVG(), fillColor: Color = new Color(), strokeColor: Color = new Color(), invisible: Bool = new Bool(), ) {
		this.uri = uri;
		this.accessibilityLabel = accessibilityLabel;
		this.border = border;
		this.frame = frame;
		this.padding = padding;
		this.sVG = sVG;
		this.fillColor = fillColor;
		this.strokeColor = strokeColor;
		this.invisible = invisible;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.uri.read(reader);
					break
				}
				case 2: {
					this.accessibilityLabel.read(reader);
					break
				}
				case 3: {
					this.border.read(reader);
					break
				}
				case 4: {
					this.frame.read(reader);
					break
				}
				case 5: {
					this.padding.read(reader);
					break
				}
				case 6: {
					this.sVG.read(reader);
					break
				}
				case 7: {
					this.fillColor.read(reader);
					break
				}
				case 8: {
					this.strokeColor.read(reader);
					break
				}
				case 9: {
					this.invisible.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.uri.isZero(),!this.accessibilityLabel.isZero(),!this.border.isZero(),!this.frame.isZero(),!this.padding.isZero(),!this.sVG.isZero(),!this.fillColor.isZero(),!this.strokeColor.isZero(),!this.invisible.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			this.uri.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			this.accessibilityLabel.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.RECORD, 3);
			this.border.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.RECORD, 4);
			this.frame.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.RECORD, 5);
			this.padding.write(writer);
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 6);
			this.sVG.write(writer);
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 7);
			this.fillColor.write(writer);
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 8);
			this.strokeColor.write(writer);
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.UVARINT, 9);
			this.invisible.write(writer);
		}
	}

	isZero(): boolean {
		return this.uri.isZero() && this.accessibilityLabel.isZero() && this.border.isZero() && this.frame.isZero() && this.padding.isZero() && this.sVG.isZero() && this.fillColor.isZero() && this.strokeColor.isZero() && this.invisible.isZero()
	}

	reset(): void {
		this.uri.reset()
		this.accessibilityLabel.reset()
		this.border.reset()
		this.frame.reset()
		this.padding.reset()
		this.sVG.reset()
		this.fillColor.reset()
		this.strokeColor.reset()
		this.invisible.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 62);
		return
	}
	isComponent(): void{}
}


// SVG contains the valid embeddable source of Scalable Vector Graphics.
export class SVG implements Writeable, Readable {
 
  public value: string; 

  constructor(value: string = "") {
    this.value = value;
  }

  isZero(): boolean {
    return this.value === "";
  }

  reset(): void {
    this.value = "";
  }

  // Get the string representation of the Color
  toString(): string {
    return this.value;
  }

  write(writer: BinaryWriter): void {
    const data = new TextEncoder().encode(this.value); // Convert string to Uint8Array
    writer.writeUvarint(data.length); // Write the length of the string
    writer.write(data); // Write the string data
  }

  read(reader: BinaryReader): void {
	const strLen = reader.readUvarint(); // Read the length of the string
    const buf = reader.readBytes(strLen); // Read the string data
    this.value = new TextDecoder().decode(buf); // Convert Uint8Array to string
  }

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.BYTESLICE, 63);
		return
	}
}


// Strings is just a bunch of string values.
export class Strings implements Writeable, Readable  {
	public value: Str[];
	
	constructor(value: Str[] = []) {
 
      this.value = value;
    }

  isZero(): boolean {
	return !this.value || this.value.length === 0;
  }

  reset(): void {
	this.value = [];
  }


  write(writer: BinaryWriter): void {
	writer.writeUvarint(this.value.length); // Write the length of the array
	for (const c of this.value) {
	  c.writeTypeHeader(writer); // Write the type header for each component
	  c.write(writer); // Write the component data
	}
  }

	  
  read(reader: BinaryReader): void {
	const count = reader.readUvarint(); // Read the length of the array
	const values: Str[] = [];

	for (let i = 0; i < count; i++) {
	  const obj = unmarshal(reader); // Read and unmarshal each component
	  values.push(obj as Str); // Cast and add to the array
	}

	this.value = values;
  }	
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 64);
		return
	}
}


// FileImportRequested asks the frontend to let the user pick some files.
// Depending on the actual backend configuration, this may cause
// a regular http multipart upload or some FFI calls providing data streams
// or accessor URIs.
export class FileImportRequested implements Writeable, Readable , NagoEvent  {
		public iD: Str;

		public scopeID: Str;

		public multiple: Bool;

		public maxBytes: Uint;

		public allowedMimeTypes: Strings;

	constructor(iD: Str = new Str(), scopeID: Str = new Str(), multiple: Bool = new Bool(), maxBytes: Uint = new Uint(), allowedMimeTypes: Strings = new Strings(), ) {
		this.iD = iD;
		this.scopeID = scopeID;
		this.multiple = multiple;
		this.maxBytes = maxBytes;
		this.allowedMimeTypes = allowedMimeTypes;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.iD.read(reader);
					break
				}
				case 2: {
					this.scopeID.read(reader);
					break
				}
				case 3: {
					this.multiple.read(reader);
					break
				}
				case 4: {
					this.maxBytes.read(reader);
					break
				}
				case 5: {
					this.allowedMimeTypes.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.iD.isZero(),!this.scopeID.isZero(),!this.multiple.isZero(),!this.maxBytes.isZero(),!this.allowedMimeTypes.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			this.iD.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			this.scopeID.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			this.multiple.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			this.maxBytes.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.ARRAY, 5);
			this.allowedMimeTypes.write(writer);
		}
	}

	isZero(): boolean {
		return this.iD.isZero() && this.scopeID.isZero() && this.multiple.isZero() && this.maxBytes.isZero() && this.allowedMimeTypes.isZero()
	}

	reset(): void {
		this.iD.reset()
		this.scopeID.reset()
		this.multiple.reset()
		this.maxBytes.reset()
		this.allowedMimeTypes.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 65);
		return
	}
	isNagoEvent(): void{}
}


export class KeyboardOptions implements Writeable, Readable  {
		public capitalization: Bool;

		public autoCorrectEnabled: Bool;

		public keyboardType: KeyboardType;

	constructor(capitalization: Bool = new Bool(), autoCorrectEnabled: Bool = new Bool(), keyboardType: KeyboardType = new KeyboardType(), ) {
		this.capitalization = capitalization;
		this.autoCorrectEnabled = autoCorrectEnabled;
		this.keyboardType = keyboardType;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.capitalization.read(reader);
					break
				}
				case 2: {
					this.autoCorrectEnabled.read(reader);
					break
				}
				case 3: {
					this.keyboardType.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.capitalization.isZero(),!this.autoCorrectEnabled.isZero(),!this.keyboardType.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			this.capitalization.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			this.autoCorrectEnabled.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			this.keyboardType.write(writer);
		}
	}

	isZero(): boolean {
		return this.capitalization.isZero() && this.autoCorrectEnabled.isZero() && this.keyboardType.isZero()
	}

	reset(): void {
		this.capitalization.reset()
		this.autoCorrectEnabled.reset()
		this.keyboardType.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 66);
		return
	}
}


export class KeyboardType implements Writeable, Readable {
 
	public value: number; // Using number to handle uint64 (precision limits apply)
	
	constructor(value: number = 0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0;
	}
	
	reset(): void {
		this.value = 0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readUvarint();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.UVARINT, 67);
		return
	}
}

// companion enum containing all defined constants for KeyboardType
export enum KeyboardTypeValues {
		KeyboardDefault = 0,
		KeyboardAscii = 1,
		KeyboardInteger = 2,
		KeyboardFloat = 3,
		KeyboardEMail = 4,
		KeyboardPhone = 5,
		KeyboardSearch = 6,
		KeyboardURL = 7,
}



export class ModalType implements Writeable, Readable {
 
	public value: number; // Using number to handle uint64 (precision limits apply)
	
	constructor(value: number = 0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0;
	}
	
	reset(): void {
		this.value = 0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readUvarint();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.UVARINT, 68);
		return
	}
}

// companion enum containing all defined constants for ModalType
export enum ModalTypeValues {
		ModalTypeDialog = 0,
		ModalTypeOverlay = 1,
}



// A Modal can be declared at any place in the composed view tree. However, these dialogs are teleported into
// the modal space in tree declaration order. A Modal is layouted above all other regular content and if ModalTypeDialog
// will catch focus and disable controls of the views behind. Its bounds are at most the maximum possible screen size.
export class Modal implements Writeable, Readable , Component  {
		public content?: Component;

	// OnDismissRequest is called, if the user wants to dismiss the dialog, e.g. by clicking outside or pressing escape. You can then decide to disable you dialog, or not.
	public onDismissRequest: Ptr;

		public modalType: ModalType;

		public top: Length;

		public left: Length;

		public right: Length;

		public bottom: Length;

	constructor(content = undefined, onDismissRequest: Ptr = new Ptr(), modalType: ModalType = new ModalType(), top: Length = new Length(), left: Length = new Length(), right: Length = new Length(), bottom: Length = new Length(), ) {
		this.content = content;
		this.onDismissRequest = onDismissRequest;
		this.modalType = modalType;
		this.top = top;
		this.left = left;
		this.right = right;
		this.bottom = bottom;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
					  throw new Error(`unexpected length: ` + len);
					}
					this.content = unmarshal(reader) as Component;
					break
				}
				case 2: {
					this.onDismissRequest.read(reader);
					break
				}
				case 3: {
					this.modalType.read(reader);
					break
				}
				case 4: {
					this.top.read(reader);
					break
				}
				case 5: {
					this.left.read(reader);
					break
				}
				case 6: {
					this.right.read(reader);
					break
				}
				case 7: {
					this.bottom.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,this.content!== undefined && !this.content.isZero(),!this.onDismissRequest.isZero(),!this.modalType.isZero(),!this.top.isZero(),!this.left.isZero(),!this.right.isZero(),!this.bottom.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			writer.writeByte(1);
			this.content!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			this.onDismissRequest.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			this.modalType.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			this.top.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			this.left.write(writer);
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 6);
			this.right.write(writer);
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 7);
			this.bottom.write(writer);
		}
	}

	isZero(): boolean {
		return (this.content=== undefined || this.content.isZero()) && this.onDismissRequest.isZero() && this.modalType.isZero() && this.top.isZero() && this.left.isZero() && this.right.isZero() && this.bottom.isZero()
	}

	reset(): void {
		this.content = undefined
		this.onDismissRequest.reset()
		this.modalType.reset()
		this.top.reset()
		this.left.reset()
		this.right.reset()
		this.bottom.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 69);
		return
	}
	isComponent(): void{}
}


// ThemeRequested is usually emitted by the backend, so that the frontend will switch (and remember) the required theme state.
export class ThemeRequested implements Writeable, Readable , NagoEvent  {
	// Theme contains the name of the theme to apply. Usually light or dark, however we may want to provide more or go even arbitrary.
	public theme: ThemeID;

	constructor(theme: ThemeID = new ThemeID(), ) {
		this.theme = theme;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.theme.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.theme.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			this.theme.write(writer);
		}
	}

	isZero(): boolean {
		return this.theme.isZero()
	}

	reset(): void {
		this.theme.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 70);
		return
	}
	isNagoEvent(): void{}
}


// NavigationForwardToRequested is an Event triggered by the backend which requests a forward navigation action within the frontend.
// A frontend must put the new component to create by the factory on top of the current component within the scope.
// The frontend is free keep multiple components alive at the same time, however it must ensure that the UX is sane.
export class NavigationForwardToRequested implements Writeable, Readable , NagoEvent  {
		public rootView: RootViewID;

		public values: RootViewParameters;

	constructor(rootView: RootViewID = new RootViewID(), values: RootViewParameters = new RootViewParameters(), ) {
		this.rootView = rootView;
		this.values = values;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.rootView.read(reader);
					break
				}
				case 2: {
					this.values.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.rootView.isZero(),!this.values.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			this.rootView.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.ARRAY, 2);
			this.values.write(writer);
		}
	}

	isZero(): boolean {
		return this.rootView.isZero() && this.values.isZero()
	}

	reset(): void {
		this.rootView.reset()
		this.values.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 71);
		return
	}
	isNagoEvent(): void{}
}


// NavigationResetRequested removes the entire history in the scope and pushes the target on top.
export class NavigationResetRequested implements Writeable, Readable , NagoEvent  {
		public rootView: RootViewID;

		public values: RootViewParameters;

	constructor(rootView: RootViewID = new RootViewID(), values: RootViewParameters = new RootViewParameters(), ) {
		this.rootView = rootView;
		this.values = values;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.rootView.read(reader);
					break
				}
				case 2: {
					this.values.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.rootView.isZero(),!this.values.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			this.rootView.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.ARRAY, 2);
			this.values.write(writer);
		}
	}

	isZero(): boolean {
		return this.rootView.isZero() && this.values.isZero()
	}

	reset(): void {
		this.rootView.reset()
		this.values.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 72);
		return
	}
	isNagoEvent(): void{}
}


// NavigationBackRequested steps back causing a likely destruction of the most top component. The frontend may decide to ignore that, if the stack would be empty/undefined otherwise.
export class NavigationBackRequested implements Writeable, Readable , NagoEvent  {
	constructor() {
	}

	read(r: BinaryReader): void {r.readByte();}
	write(w: BinaryWriter): void {w.writeByte(0);}
	isZero(): boolean {return true;}
	reset(): void {}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 73);
		return
	}
	isNagoEvent(): void{}
}


export class NavigationReloadRequested implements Writeable, Readable , NagoEvent  {
	constructor() {
	}

	read(r: BinaryReader): void {r.readByte();}
	write(w: BinaryWriter): void {w.writeByte(0);}
	isZero(): boolean {return true;}
	reset(): void {}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 74);
		return
	}
	isNagoEvent(): void{}
}


// ThemeID refers to a specific theme. E.g. dark or light
export class ThemeID implements Writeable, Readable {
 
  public value: string; 

  constructor(value: string = "") {
    this.value = value;
  }

  isZero(): boolean {
    return this.value === "";
  }

  reset(): void {
    this.value = "";
  }

  // Get the string representation of the Color
  toString(): string {
    return this.value;
  }

  write(writer: BinaryWriter): void {
    const data = new TextEncoder().encode(this.value); // Convert string to Uint8Array
    writer.writeUvarint(data.length); // Write the length of the string
    writer.write(data); // Write the string data
  }

  read(reader: BinaryReader): void {
	const strLen = reader.readUvarint(); // Read the length of the string
    const buf = reader.readBytes(strLen); // Read the string data
    this.value = new TextDecoder().decode(buf); // Convert Uint8Array to string
  }

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.BYTESLICE, 75);
		return
	}
}


// OpenRequested is usually emitted by the backend, so that the frontend will trigger a kind of popen or shellexecute.
export class OpenRequested implements Writeable, Readable , NagoEvent  {
	// Resource may be anything, e.g. a path or uuid or URI.
	public resource: Str;

	// Options are simple string key-value pairs which further specifies the open call.
	public options: RootViewParameters;

	constructor(resource: Str = new Str(), options: RootViewParameters = new RootViewParameters(), ) {
		this.resource = resource;
		this.options = options;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.resource.read(reader);
					break
				}
				case 2: {
					this.options.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.resource.isZero(),!this.options.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			this.resource.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.ARRAY, 2);
			this.options.write(writer);
		}
	}

	isZero(): boolean {
		return this.resource.isZero() && this.options.isZero()
	}

	reset(): void {
		this.resource.reset()
		this.options.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 76);
		return
	}
	isNagoEvent(): void{}
}


// WindowTitle is an invisible component which teleports its Value into the current active window navigation title. The last evaluated title in the hierarchy wins.
export class WindowTitle implements Writeable, Readable , Component  {
		public value: Str;

	constructor(value: Str = new Str(), ) {
		this.value = value;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.value.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.value.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			this.value.write(writer);
		}
	}

	isZero(): boolean {
		return this.value.isZero()
	}

	reset(): void {
		this.value.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 77);
		return
	}
	isComponent(): void{}
}


// Duration represents a duration in nanoseconds
export class Duration implements Writeable, Readable {
 
	public value: number; // Using number to handle uint64 (precision limits apply)
	
	constructor(value: number = 0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0;
	}
	
	reset(): void {
		this.value = 0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readUvarint();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.UVARINT, 78);
		return
	}
}


export class PasswordField implements Writeable, Readable , Component  {
		public label: Str;

		public supportingText: Str;

	// ErrorText is shown instead of SupportingText, even if they are (today) independent
	public errorText: Str;

	// Value contains the text, which shall be shown.
	public value: Str;

		public frame: Frame;

	// InputValue is a binding to a state, into which the frontend will the user entered text. This is the pointer a State.
	public inputValue: Ptr;

	// Style to apply. Use TextFieldReduced in forms where many textfields cause too much visual noise and you need to reduce it. By default, the TextFieldOutlined is applied.
	public style: TextFieldStyle;

	// DebounceTime is in nanoseconds. A zero or omitted value means to enable debounce default logic.
	public debounceTime: Duration;

	// Lines enforces a single line if <= 0, otherwise it shows the amount of text lines within a text area.
	public lines: Uint;

		public disabled: Bool;

		public disableAutocomplete: Bool;

	// DisableDebounce must be set to true, to disable the default debouncer logic. This will cause a render roundtrip for each keystroke, so be careful not to break the server or cause UX issues due to UI latencies.
	public disableDebounce: Bool;

		public invisible: Bool;

	// If Revealed the password is shown
	public revealed: Bool;

	constructor(label: Str = new Str(), supportingText: Str = new Str(), errorText: Str = new Str(), value: Str = new Str(), frame: Frame = new Frame(), inputValue: Ptr = new Ptr(), style: TextFieldStyle = new TextFieldStyle(), debounceTime: Duration = new Duration(), lines: Uint = new Uint(), disabled: Bool = new Bool(), disableAutocomplete: Bool = new Bool(), disableDebounce: Bool = new Bool(), invisible: Bool = new Bool(), revealed: Bool = new Bool(), ) {
		this.label = label;
		this.supportingText = supportingText;
		this.errorText = errorText;
		this.value = value;
		this.frame = frame;
		this.inputValue = inputValue;
		this.style = style;
		this.debounceTime = debounceTime;
		this.lines = lines;
		this.disabled = disabled;
		this.disableAutocomplete = disableAutocomplete;
		this.disableDebounce = disableDebounce;
		this.invisible = invisible;
		this.revealed = revealed;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.label.read(reader);
					break
				}
				case 2: {
					this.supportingText.read(reader);
					break
				}
				case 3: {
					this.errorText.read(reader);
					break
				}
				case 4: {
					this.value.read(reader);
					break
				}
				case 5: {
					this.frame.read(reader);
					break
				}
				case 6: {
					this.inputValue.read(reader);
					break
				}
				case 7: {
					this.style.read(reader);
					break
				}
				case 8: {
					this.debounceTime.read(reader);
					break
				}
				case 9: {
					this.lines.read(reader);
					break
				}
				case 10: {
					this.disabled.read(reader);
					break
				}
				case 11: {
					this.disableAutocomplete.read(reader);
					break
				}
				case 12: {
					this.disableDebounce.read(reader);
					break
				}
				case 13: {
					this.invisible.read(reader);
					break
				}
				case 14: {
					this.revealed.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.label.isZero(),!this.supportingText.isZero(),!this.errorText.isZero(),!this.value.isZero(),!this.frame.isZero(),!this.inputValue.isZero(),!this.style.isZero(),!this.debounceTime.isZero(),!this.lines.isZero(),!this.disabled.isZero(),!this.disableAutocomplete.isZero(),!this.disableDebounce.isZero(),!this.invisible.isZero(),!this.revealed.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			this.label.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			this.supportingText.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			this.errorText.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			this.value.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.RECORD, 5);
			this.frame.write(writer);
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.UVARINT, 6);
			this.inputValue.write(writer);
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.UVARINT, 7);
			this.style.write(writer);
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.UVARINT, 8);
			this.debounceTime.write(writer);
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.UVARINT, 9);
			this.lines.write(writer);
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.UVARINT, 10);
			this.disabled.write(writer);
		}
		if (fields[11]) {
			writer.writeFieldHeader(Shapes.UVARINT, 11);
			this.disableAutocomplete.write(writer);
		}
		if (fields[12]) {
			writer.writeFieldHeader(Shapes.UVARINT, 12);
			this.disableDebounce.write(writer);
		}
		if (fields[13]) {
			writer.writeFieldHeader(Shapes.UVARINT, 13);
			this.invisible.write(writer);
		}
		if (fields[14]) {
			writer.writeFieldHeader(Shapes.UVARINT, 14);
			this.revealed.write(writer);
		}
	}

	isZero(): boolean {
		return this.label.isZero() && this.supportingText.isZero() && this.errorText.isZero() && this.value.isZero() && this.frame.isZero() && this.inputValue.isZero() && this.style.isZero() && this.debounceTime.isZero() && this.lines.isZero() && this.disabled.isZero() && this.disableAutocomplete.isZero() && this.disableDebounce.isZero() && this.invisible.isZero() && this.revealed.isZero()
	}

	reset(): void {
		this.label.reset()
		this.supportingText.reset()
		this.errorText.reset()
		this.value.reset()
		this.frame.reset()
		this.inputValue.reset()
		this.style.reset()
		this.debounceTime.reset()
		this.lines.reset()
		this.disabled.reset()
		this.disableAutocomplete.reset()
		this.disableDebounce.reset()
		this.invisible.reset()
		this.revealed.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 79);
		return
	}
	isComponent(): void{}
}


export class TextFieldStyle implements Writeable, Readable {
 
	public value: number; // Using number to handle uint64 (precision limits apply)
	
	constructor(value: number = 0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0;
	}
	
	reset(): void {
		this.value = 0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readUvarint();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.UVARINT, 80);
		return
	}
}

// companion enum containing all defined constants for TextFieldStyle
export enum TextFieldStyleValues {
	// TextFieldOutlined is fine for smaller forms and helps to identify where to put text in the form.
	TextFieldOutlined = 0,
	// TextFieldReduced has no outlines and thus less visual disruption in larger forms.
	TextFieldReduced = 1,
	// TextFieldBasic removes as much as decorations as possible. There may be limitations based on the platform. Note, that an implementation is allowed to ignore leading, trailing, supporting and errorText for this mode. It may serve as a building-block for custom fields.
	TextFieldBasic = 2,
}



// Ping is usually send by the frontend to the backend to keep the websocket alive for all intermediate proxies or other underlying channel implementations.
export class Ping implements Writeable, Readable , NagoEvent  {
	constructor() {
	}

	read(r: BinaryReader): void {r.readByte();}
	write(w: BinaryWriter): void {w.writeByte(0);}
	isZero(): boolean {return true;}
	reset(): void {}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 81);
		return
	}
	isNagoEvent(): void{}
}


// Radiobutton represents a user interface element which spans a visible area to click or tap from the user. Usually a radiobutton belongs to a group, where only a single element can be picked. Thus, it is quite similar to a Spinner/Select/Combobox.
export class Radiobutton implements Writeable, Readable , Component  {
	// InputValue is where updated value of the checked states are written.
	public inputValue: Ptr;

	// Value is the initial checked value.
	public value: Bool;

		public disabled: Bool;

		public invisible: Bool;

	constructor(inputValue: Ptr = new Ptr(), value: Bool = new Bool(), disabled: Bool = new Bool(), invisible: Bool = new Bool(), ) {
		this.inputValue = inputValue;
		this.value = value;
		this.disabled = disabled;
		this.invisible = invisible;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.inputValue.read(reader);
					break
				}
				case 2: {
					this.value.read(reader);
					break
				}
				case 3: {
					this.disabled.read(reader);
					break
				}
				case 4: {
					this.invisible.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.inputValue.isZero(),!this.value.isZero(),!this.disabled.isZero(),!this.invisible.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			this.inputValue.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			this.value.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			this.disabled.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			this.invisible.write(writer);
		}
	}

	isZero(): boolean {
		return this.inputValue.isZero() && this.value.isZero() && this.disabled.isZero() && this.invisible.isZero()
	}

	reset(): void {
		this.inputValue.reset()
		this.value.reset()
		this.disabled.reset()
		this.invisible.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 82);
		return
	}
	isComponent(): void{}
}


export class ScaffoldAlignment implements Writeable, Readable {
 
	public value: number; // Using number to handle uint64 (precision limits apply)
	
	constructor(value: number = 0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0;
	}
	
	reset(): void {
		this.value = 0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readUvarint();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.UVARINT, 83);
		return
	}
}

// companion enum containing all defined constants for ScaffoldAlignment
export enum ScaffoldAlignmentValues {
		ScaffoldAlignmentTop = 0,
		ScaffoldAlignmentLeading = 1,
}



export class ScaffoldMenuEntries implements Writeable, Readable  {
	public value: ScaffoldMenuEntry[];
	
	constructor(value: ScaffoldMenuEntry[] = []) {
 
      this.value = value;
    }

  isZero(): boolean {
	return !this.value || this.value.length === 0;
  }

  reset(): void {
	this.value = [];
  }


  write(writer: BinaryWriter): void {
	writer.writeUvarint(this.value.length); // Write the length of the array
	for (const c of this.value) {
	  c.writeTypeHeader(writer); // Write the type header for each component
	  c.write(writer); // Write the component data
	}
  }

	  
  read(reader: BinaryReader): void {
	const count = reader.readUvarint(); // Read the length of the array
	const values: ScaffoldMenuEntry[] = [];

	for (let i = 0; i < count; i++) {
	  const obj = unmarshal(reader); // Read and unmarshal each component
	  values.push(obj as ScaffoldMenuEntry); // Cast and add to the array
	}

	this.value = values;
  }	
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 84);
		return
	}
}


export class Scaffold implements Writeable, Readable , Component  {
		public body?: Component;

		public logo?: Component;

		public menu: ScaffoldMenuEntries;

		public alignment: ScaffoldAlignment;

	constructor(body = undefined, logo = undefined, menu: ScaffoldMenuEntries = new ScaffoldMenuEntries(), alignment: ScaffoldAlignment = new ScaffoldAlignment(), ) {
		this.body = body;
		this.logo = logo;
		this.menu = menu;
		this.alignment = alignment;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
					  throw new Error(`unexpected length: ` + len);
					}
					this.body = unmarshal(reader) as Component;
					break
				}
				case 2: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
					  throw new Error(`unexpected length: ` + len);
					}
					this.logo = unmarshal(reader) as Component;
					break
				}
				case 3: {
					this.menu.read(reader);
					break
				}
				case 4: {
					this.alignment.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,this.body!== undefined && !this.body.isZero(),this.logo!== undefined && !this.logo.isZero(),!this.menu.isZero(),!this.alignment.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			writer.writeByte(1);
			this.body!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 2);
			writer.writeByte(1);
			this.logo!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.ARRAY, 3);
			this.menu.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			this.alignment.write(writer);
		}
	}

	isZero(): boolean {
		return (this.body=== undefined || this.body.isZero()) && (this.logo=== undefined || this.logo.isZero()) && this.menu.isZero() && this.alignment.isZero()
	}

	reset(): void {
		this.body = undefined
		this.logo = undefined
		this.menu.reset()
		this.alignment.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 85);
		return
	}
	isComponent(): void{}
}


export class ScaffoldMenuEntry implements Writeable, Readable  {
		public icon?: Component;

		public iconActive?: Component;

		public title: Str;

		public action: Ptr;

		public rootView: RootViewID;

		public menu: ScaffoldMenuEntries;

		public badge: Str;

		public expanded: Bool;

	constructor(icon = undefined, iconActive = undefined, title: Str = new Str(), action: Ptr = new Ptr(), rootView: RootViewID = new RootViewID(), menu: ScaffoldMenuEntries = new ScaffoldMenuEntries(), badge: Str = new Str(), expanded: Bool = new Bool(), ) {
		this.icon = icon;
		this.iconActive = iconActive;
		this.title = title;
		this.action = action;
		this.rootView = rootView;
		this.menu = menu;
		this.badge = badge;
		this.expanded = expanded;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
					  throw new Error(`unexpected length: ` + len);
					}
					this.icon = unmarshal(reader) as Component;
					break
				}
				case 2: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
					  throw new Error(`unexpected length: ` + len);
					}
					this.iconActive = unmarshal(reader) as Component;
					break
				}
				case 3: {
					this.title.read(reader);
					break
				}
				case 4: {
					this.action.read(reader);
					break
				}
				case 5: {
					this.rootView.read(reader);
					break
				}
				case 6: {
					this.menu.read(reader);
					break
				}
				case 7: {
					this.badge.read(reader);
					break
				}
				case 8: {
					this.expanded.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,this.icon!== undefined && !this.icon.isZero(),this.iconActive!== undefined && !this.iconActive.isZero(),!this.title.isZero(),!this.action.isZero(),!this.rootView.isZero(),!this.menu.isZero(),!this.badge.isZero(),!this.expanded.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			writer.writeByte(1);
			this.icon!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 2);
			writer.writeByte(1);
			this.iconActive!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			this.title.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			this.action.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			this.rootView.write(writer);
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.ARRAY, 6);
			this.menu.write(writer);
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 7);
			this.badge.write(writer);
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.UVARINT, 8);
			this.expanded.write(writer);
		}
	}

	isZero(): boolean {
		return (this.icon=== undefined || this.icon.isZero()) && (this.iconActive=== undefined || this.iconActive.isZero()) && this.title.isZero() && this.action.isZero() && this.rootView.isZero() && this.menu.isZero() && this.badge.isZero() && this.expanded.isZero()
	}

	reset(): void {
		this.icon = undefined
		this.iconActive = undefined
		this.title.reset()
		this.action.reset()
		this.rootView.reset()
		this.menu.reset()
		this.badge.reset()
		this.expanded.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 86);
		return
	}
}


export class ScopeID implements Writeable, Readable {
 
  public value: string; 

  constructor(value: string = "") {
    this.value = value;
  }

  isZero(): boolean {
    return this.value === "";
  }

  reset(): void {
    this.value = "";
  }

  // Get the string representation of the Color
  toString(): string {
    return this.value;
  }

  write(writer: BinaryWriter): void {
    const data = new TextEncoder().encode(this.value); // Convert string to Uint8Array
    writer.writeUvarint(data.length); // Write the length of the string
    writer.write(data); // Write the string data
  }

  read(reader: BinaryReader): void {
	const strLen = reader.readUvarint(); // Read the length of the string
    const buf = reader.readBytes(strLen); // Read the string data
    this.value = new TextDecoder().decode(buf); // Convert Uint8Array to string
  }

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.BYTESLICE, 87);
		return
	}
}


// ScopeDestructionRequested can be emitted by a frontend to deallocate a scope, its states and root view at the backend side. This is usually only possible, if you have a kind of destruction event in the frontend.
export class ScopeDestructionRequested implements Writeable, Readable , NagoEvent  {
		public rID: RID;

	constructor(rID: RID = new RID(), ) {
		this.rID = rID;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.rID.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.rID.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			this.rID.write(writer);
		}
	}

	isZero(): boolean {
		return this.rID.isZero()
	}

	reset(): void {
		this.rID.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 88);
		return
	}
	isNagoEvent(): void{}
}


export class ScrollViewAxis implements Writeable, Readable {
 
	public value: number; // Using number to handle uint64 (precision limits apply)
	
	constructor(value: number = 0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0;
	}
	
	reset(): void {
		this.value = 0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readUvarint();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.UVARINT, 89);
		return
	}
}

// companion enum containing all defined constants for ScrollViewAxis
export enum ScrollViewAxisValues {
		ScrollViewAxisVertical = 0,
		ScrollViewAxisHorizontal = 1,
}



// A ScrollView can either be horizontal or vertical.
export class ScrollView implements Writeable, Readable , Component  {
		public content?: Component;

		public border: Border;

		public frame: Frame;

		public padding: Padding;

		public backgroundColor: Color;

		public axis: ScrollViewAxis;

		public invisible: Bool;

	constructor(content = undefined, border: Border = new Border(), frame: Frame = new Frame(), padding: Padding = new Padding(), backgroundColor: Color = new Color(), axis: ScrollViewAxis = new ScrollViewAxis(), invisible: Bool = new Bool(), ) {
		this.content = content;
		this.border = border;
		this.frame = frame;
		this.padding = padding;
		this.backgroundColor = backgroundColor;
		this.axis = axis;
		this.invisible = invisible;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
					  throw new Error(`unexpected length: ` + len);
					}
					this.content = unmarshal(reader) as Component;
					break
				}
				case 2: {
					this.border.read(reader);
					break
				}
				case 3: {
					this.frame.read(reader);
					break
				}
				case 4: {
					this.padding.read(reader);
					break
				}
				case 5: {
					this.backgroundColor.read(reader);
					break
				}
				case 6: {
					this.axis.read(reader);
					break
				}
				case 7: {
					this.invisible.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,this.content!== undefined && !this.content.isZero(),!this.border.isZero(),!this.frame.isZero(),!this.padding.isZero(),!this.backgroundColor.isZero(),!this.axis.isZero(),!this.invisible.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			writer.writeByte(1);
			this.content!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.RECORD, 2);
			this.border.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.RECORD, 3);
			this.frame.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.RECORD, 4);
			this.padding.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			this.backgroundColor.write(writer);
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.UVARINT, 6);
			this.axis.write(writer);
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.UVARINT, 7);
			this.invisible.write(writer);
		}
	}

	isZero(): boolean {
		return (this.content=== undefined || this.content.isZero()) && this.border.isZero() && this.frame.isZero() && this.padding.isZero() && this.backgroundColor.isZero() && this.axis.isZero() && this.invisible.isZero()
	}

	reset(): void {
		this.content = undefined
		this.border.reset()
		this.frame.reset()
		this.padding.reset()
		this.backgroundColor.reset()
		this.axis.reset()
		this.invisible.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 90);
		return
	}
	isComponent(): void{}
}


// A Resource represents a blob with a name and a resource accessor URI.
export class Resource implements Writeable, Readable  {
	// Name must not be a path, just the human readable (and not unique) file name.
	public name: Str;

	// URI is likely an unreadable link to resolve the actual data. It may incorporate additional security tokens and may have a limited lifetime and its scheme is undefined.
	public uRI: URI;

	// MimeType is optional and is a hint about the anticipated content.
	public mimeType: Str;

	constructor(name: Str = new Str(), uRI: URI = new URI(), mimeType: Str = new Str(), ) {
		this.name = name;
		this.uRI = uRI;
		this.mimeType = mimeType;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.name.read(reader);
					break
				}
				case 2: {
					this.uRI.read(reader);
					break
				}
				case 3: {
					this.mimeType.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.name.isZero(),!this.uRI.isZero(),!this.mimeType.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			this.name.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			this.uRI.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			this.mimeType.write(writer);
		}
	}

	isZero(): boolean {
		return this.name.isZero() && this.uRI.isZero() && this.mimeType.isZero()
	}

	reset(): void {
		this.name.reset()
		this.uRI.reset()
		this.mimeType.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 91);
		return
	}
}


export class Resources implements Writeable, Readable  {
	public value: Resource[];
	
	constructor(value: Resource[] = []) {
 
      this.value = value;
    }

  isZero(): boolean {
	return !this.value || this.value.length === 0;
  }

  reset(): void {
	this.value = [];
  }


  write(writer: BinaryWriter): void {
	writer.writeUvarint(this.value.length); // Write the length of the array
	for (const c of this.value) {
	  c.writeTypeHeader(writer); // Write the type header for each component
	  c.write(writer); // Write the component data
	}
  }

	  
  read(reader: BinaryReader): void {
	const count = reader.readUvarint(); // Read the length of the array
	const values: Resource[] = [];

	for (let i = 0; i < count; i++) {
	  const obj = unmarshal(reader); // Read and unmarshal each component
	  values.push(obj as Resource); // Cast and add to the array
	}

	this.value = values;
  }	
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 92);
		return
	}
}


// SendMultipleRequested is an event for the frontend from the backend
// to send the according resources into the system environment.
// A Webbrowser may issue a regular download. A backend should not issue multiple downloads at once but instead
// pack multiple files into a zip file because the browser support for something like a multipart download
// is just broken today. An Android App may trigger the according Intent and opens a picker
// to select the receiving app.
export class SendMultipleRequested implements Writeable, Readable , NagoEvent  {
		public resources: Resources;

	constructor(resources: Resources = new Resources(), ) {
		this.resources = resources;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.resources.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.resources.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			this.resources.write(writer);
		}
	}

	isZero(): boolean {
		return this.resources.isZero()
	}

	reset(): void {
		this.resources.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 93);
		return
	}
	isNagoEvent(): void{}
}


// SessionAssigned must not be used by browser clients directly. A http channel implementation must issue this by itself due to security concerns like http-only cookies. Native client (mobile or desktop) should use this event instead.
export class SessionAssigned implements Writeable, Readable , NagoEvent  {
		public sessionID: Str;

	constructor(sessionID: Str = new Str(), ) {
		this.sessionID = sessionID;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.sessionID.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.sessionID.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			this.sessionID.write(writer);
		}
	}

	isZero(): boolean {
		return this.sessionID.isZero()
	}

	reset(): void {
		this.sessionID.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 94);
		return
	}
	isNagoEvent(): void{}
}


// Spacer grows or shrinks within a HStack or VStack. In other layouts, the behavior is unspecified.
export class Spacer implements Writeable, Readable , Component  {
		public frame: Frame;

		public border: Border;

		public backgroundColor: Color;

	constructor(frame: Frame = new Frame(), border: Border = new Border(), backgroundColor: Color = new Color(), ) {
		this.frame = frame;
		this.border = border;
		this.backgroundColor = backgroundColor;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.frame.read(reader);
					break
				}
				case 2: {
					this.border.read(reader);
					break
				}
				case 3: {
					this.backgroundColor.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.frame.isZero(),!this.border.isZero(),!this.backgroundColor.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.RECORD, 1);
			this.frame.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.RECORD, 2);
			this.border.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			this.backgroundColor.write(writer);
		}
	}

	isZero(): boolean {
		return this.frame.isZero() && this.border.isZero() && this.backgroundColor.isZero()
	}

	reset(): void {
		this.frame.reset()
		this.border.reset()
		this.backgroundColor.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 95);
		return
	}
	isComponent(): void{}
}


// Table represents a pre-styled table with limited styling capabilities. Use Grid for maximum flexibility.
export class Table implements Writeable, Readable , Component  {
		public header: TableHeader;

		public rows: TableRows;

		public frame: Frame;

		public backgroundColor: Color;

		public border: Border;

		public defaultCellPadding: Padding;

		public rowDividerColor: Color;

		public headerDividerColor: Color;

	constructor(header: TableHeader = new TableHeader(), rows: TableRows = new TableRows(), frame: Frame = new Frame(), backgroundColor: Color = new Color(), border: Border = new Border(), defaultCellPadding: Padding = new Padding(), rowDividerColor: Color = new Color(), headerDividerColor: Color = new Color(), ) {
		this.header = header;
		this.rows = rows;
		this.frame = frame;
		this.backgroundColor = backgroundColor;
		this.border = border;
		this.defaultCellPadding = defaultCellPadding;
		this.rowDividerColor = rowDividerColor;
		this.headerDividerColor = headerDividerColor;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.header.read(reader);
					break
				}
				case 2: {
					this.rows.read(reader);
					break
				}
				case 3: {
					this.frame.read(reader);
					break
				}
				case 4: {
					this.backgroundColor.read(reader);
					break
				}
				case 5: {
					this.border.read(reader);
					break
				}
				case 6: {
					this.defaultCellPadding.read(reader);
					break
				}
				case 7: {
					this.rowDividerColor.read(reader);
					break
				}
				case 8: {
					this.headerDividerColor.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.header.isZero(),!this.rows.isZero(),!this.frame.isZero(),!this.backgroundColor.isZero(),!this.border.isZero(),!this.defaultCellPadding.isZero(),!this.rowDividerColor.isZero(),!this.headerDividerColor.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.RECORD, 1);
			this.header.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.ARRAY, 2);
			this.rows.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.RECORD, 3);
			this.frame.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			this.backgroundColor.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.RECORD, 5);
			this.border.write(writer);
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.RECORD, 6);
			this.defaultCellPadding.write(writer);
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 7);
			this.rowDividerColor.write(writer);
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 8);
			this.headerDividerColor.write(writer);
		}
	}

	isZero(): boolean {
		return this.header.isZero() && this.rows.isZero() && this.frame.isZero() && this.backgroundColor.isZero() && this.border.isZero() && this.defaultCellPadding.isZero() && this.rowDividerColor.isZero() && this.headerDividerColor.isZero()
	}

	reset(): void {
		this.header.reset()
		this.rows.reset()
		this.frame.reset()
		this.backgroundColor.reset()
		this.border.reset()
		this.defaultCellPadding.reset()
		this.rowDividerColor.reset()
		this.headerDividerColor.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 96);
		return
	}
	isComponent(): void{}
}


export class TableCell implements Writeable, Readable  {
		public content?: Component;

	// Values higher than 65534 are clipped.
	public rowSpan: Uint;

	// Values higher than 1000 are clipped.
	public colSpan: Uint;

		public alignment: Alignment;

		public backgroundColor: Color;

		public hoveredBackgroundColor: Color;

		public padding: Padding;

		public border: Border;

		public action: Ptr;

		public hovered: Bool;

	constructor(content = undefined, rowSpan: Uint = new Uint(), colSpan: Uint = new Uint(), alignment: Alignment = new Alignment(), backgroundColor: Color = new Color(), hoveredBackgroundColor: Color = new Color(), padding: Padding = new Padding(), border: Border = new Border(), action: Ptr = new Ptr(), hovered: Bool = new Bool(), ) {
		this.content = content;
		this.rowSpan = rowSpan;
		this.colSpan = colSpan;
		this.alignment = alignment;
		this.backgroundColor = backgroundColor;
		this.hoveredBackgroundColor = hoveredBackgroundColor;
		this.padding = padding;
		this.border = border;
		this.action = action;
		this.hovered = hovered;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
					  throw new Error(`unexpected length: ` + len);
					}
					this.content = unmarshal(reader) as Component;
					break
				}
				case 2: {
					this.rowSpan.read(reader);
					break
				}
				case 3: {
					this.colSpan.read(reader);
					break
				}
				case 4: {
					this.alignment.read(reader);
					break
				}
				case 5: {
					this.backgroundColor.read(reader);
					break
				}
				case 6: {
					this.hoveredBackgroundColor.read(reader);
					break
				}
				case 7: {
					this.padding.read(reader);
					break
				}
				case 8: {
					this.border.read(reader);
					break
				}
				case 9: {
					this.action.read(reader);
					break
				}
				case 10: {
					this.hovered.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,this.content!== undefined && !this.content.isZero(),!this.rowSpan.isZero(),!this.colSpan.isZero(),!this.alignment.isZero(),!this.backgroundColor.isZero(),!this.hoveredBackgroundColor.isZero(),!this.padding.isZero(),!this.border.isZero(),!this.action.isZero(),!this.hovered.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			writer.writeByte(1);
			this.content!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			this.rowSpan.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			this.colSpan.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			this.alignment.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			this.backgroundColor.write(writer);
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 6);
			this.hoveredBackgroundColor.write(writer);
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.RECORD, 7);
			this.padding.write(writer);
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.RECORD, 8);
			this.border.write(writer);
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.UVARINT, 9);
			this.action.write(writer);
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.UVARINT, 10);
			this.hovered.write(writer);
		}
	}

	isZero(): boolean {
		return (this.content=== undefined || this.content.isZero()) && this.rowSpan.isZero() && this.colSpan.isZero() && this.alignment.isZero() && this.backgroundColor.isZero() && this.hoveredBackgroundColor.isZero() && this.padding.isZero() && this.border.isZero() && this.action.isZero() && this.hovered.isZero()
	}

	reset(): void {
		this.content = undefined
		this.rowSpan.reset()
		this.colSpan.reset()
		this.alignment.reset()
		this.backgroundColor.reset()
		this.hoveredBackgroundColor.reset()
		this.padding.reset()
		this.border.reset()
		this.action.reset()
		this.hovered.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 97);
		return
	}
}


export class TableColumn implements Writeable, Readable  {
		public content?: Component;

	// Values higher than 1000 are clipped.
	public colSpan: Uint;

		public width: Length;

		public alignment: Alignment;

		public cellBackgroundColor: Color;

		public cellAction: Ptr;

		public cellPadding: Padding;

		public cellBorder: Border;

		public cellHoveredBackgroundColor: Color;

		public cellHovered: Bool;

	constructor(content = undefined, colSpan: Uint = new Uint(), width: Length = new Length(), alignment: Alignment = new Alignment(), cellBackgroundColor: Color = new Color(), cellAction: Ptr = new Ptr(), cellPadding: Padding = new Padding(), cellBorder: Border = new Border(), cellHoveredBackgroundColor: Color = new Color(), cellHovered: Bool = new Bool(), ) {
		this.content = content;
		this.colSpan = colSpan;
		this.width = width;
		this.alignment = alignment;
		this.cellBackgroundColor = cellBackgroundColor;
		this.cellAction = cellAction;
		this.cellPadding = cellPadding;
		this.cellBorder = cellBorder;
		this.cellHoveredBackgroundColor = cellHoveredBackgroundColor;
		this.cellHovered = cellHovered;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
					  throw new Error(`unexpected length: ` + len);
					}
					this.content = unmarshal(reader) as Component;
					break
				}
				case 2: {
					this.colSpan.read(reader);
					break
				}
				case 3: {
					this.width.read(reader);
					break
				}
				case 4: {
					this.alignment.read(reader);
					break
				}
				case 5: {
					this.cellBackgroundColor.read(reader);
					break
				}
				case 6: {
					this.cellAction.read(reader);
					break
				}
				case 7: {
					this.cellPadding.read(reader);
					break
				}
				case 8: {
					this.cellBorder.read(reader);
					break
				}
				case 9: {
					this.cellHoveredBackgroundColor.read(reader);
					break
				}
				case 10: {
					this.cellHovered.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,this.content!== undefined && !this.content.isZero(),!this.colSpan.isZero(),!this.width.isZero(),!this.alignment.isZero(),!this.cellBackgroundColor.isZero(),!this.cellAction.isZero(),!this.cellPadding.isZero(),!this.cellBorder.isZero(),!this.cellHoveredBackgroundColor.isZero(),!this.cellHovered.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			writer.writeByte(1);
			this.content!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			this.colSpan.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			this.width.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			this.alignment.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			this.cellBackgroundColor.write(writer);
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.UVARINT, 6);
			this.cellAction.write(writer);
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.RECORD, 7);
			this.cellPadding.write(writer);
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.RECORD, 8);
			this.cellBorder.write(writer);
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 9);
			this.cellHoveredBackgroundColor.write(writer);
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.UVARINT, 10);
			this.cellHovered.write(writer);
		}
	}

	isZero(): boolean {
		return (this.content=== undefined || this.content.isZero()) && this.colSpan.isZero() && this.width.isZero() && this.alignment.isZero() && this.cellBackgroundColor.isZero() && this.cellAction.isZero() && this.cellPadding.isZero() && this.cellBorder.isZero() && this.cellHoveredBackgroundColor.isZero() && this.cellHovered.isZero()
	}

	reset(): void {
		this.content = undefined
		this.colSpan.reset()
		this.width.reset()
		this.alignment.reset()
		this.cellBackgroundColor.reset()
		this.cellAction.reset()
		this.cellPadding.reset()
		this.cellBorder.reset()
		this.cellHoveredBackgroundColor.reset()
		this.cellHovered.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 98);
		return
	}
}


export class TableRow implements Writeable, Readable  {
		public cells: TableCells;

		public height: Length;

		public backgroundColor: Color;

		public hoveredBackgroundColor: Color;

		public action: Ptr;

		public hovered: Bool;

	constructor(cells: TableCells = new TableCells(), height: Length = new Length(), backgroundColor: Color = new Color(), hoveredBackgroundColor: Color = new Color(), action: Ptr = new Ptr(), hovered: Bool = new Bool(), ) {
		this.cells = cells;
		this.height = height;
		this.backgroundColor = backgroundColor;
		this.hoveredBackgroundColor = hoveredBackgroundColor;
		this.action = action;
		this.hovered = hovered;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.cells.read(reader);
					break
				}
				case 2: {
					this.height.read(reader);
					break
				}
				case 3: {
					this.backgroundColor.read(reader);
					break
				}
				case 4: {
					this.hoveredBackgroundColor.read(reader);
					break
				}
				case 5: {
					this.action.read(reader);
					break
				}
				case 6: {
					this.hovered.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.cells.isZero(),!this.height.isZero(),!this.backgroundColor.isZero(),!this.hoveredBackgroundColor.isZero(),!this.action.isZero(),!this.hovered.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			this.cells.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			this.height.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			this.backgroundColor.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			this.hoveredBackgroundColor.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.UVARINT, 5);
			this.action.write(writer);
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.UVARINT, 6);
			this.hovered.write(writer);
		}
	}

	isZero(): boolean {
		return this.cells.isZero() && this.height.isZero() && this.backgroundColor.isZero() && this.hoveredBackgroundColor.isZero() && this.action.isZero() && this.hovered.isZero()
	}

	reset(): void {
		this.cells.reset()
		this.height.reset()
		this.backgroundColor.reset()
		this.hoveredBackgroundColor.reset()
		this.action.reset()
		this.hovered.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 99);
		return
	}
}


// TableHeader aggregates the optional header properties and defines columns from left to right. We are not assigning cells to columns by id, to lower the protocol overhead.
export class TableHeader implements Writeable, Readable  {
		public columns: TableColumns;

	constructor(columns: TableColumns = new TableColumns(), ) {
		this.columns = columns;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.columns.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.columns.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			this.columns.write(writer);
		}
	}

	isZero(): boolean {
		return this.columns.isZero()
	}

	reset(): void {
		this.columns.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 100);
		return
	}
}


export class TableRows implements Writeable, Readable  {
	public value: TableRow[];
	
	constructor(value: TableRow[] = []) {
 
      this.value = value;
    }

  isZero(): boolean {
	return !this.value || this.value.length === 0;
  }

  reset(): void {
	this.value = [];
  }


  write(writer: BinaryWriter): void {
	writer.writeUvarint(this.value.length); // Write the length of the array
	for (const c of this.value) {
	  c.writeTypeHeader(writer); // Write the type header for each component
	  c.write(writer); // Write the component data
	}
  }

	  
  read(reader: BinaryReader): void {
	const count = reader.readUvarint(); // Read the length of the array
	const values: TableRow[] = [];

	for (let i = 0; i < count; i++) {
	  const obj = unmarshal(reader); // Read and unmarshal each component
	  values.push(obj as TableRow); // Cast and add to the array
	}

	this.value = values;
  }	
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 101);
		return
	}
}


export class TableCells implements Writeable, Readable  {
	public value: TableCell[];
	
	constructor(value: TableCell[] = []) {
 
      this.value = value;
    }

  isZero(): boolean {
	return !this.value || this.value.length === 0;
  }

  reset(): void {
	this.value = [];
  }


  write(writer: BinaryWriter): void {
	writer.writeUvarint(this.value.length); // Write the length of the array
	for (const c of this.value) {
	  c.writeTypeHeader(writer); // Write the type header for each component
	  c.write(writer); // Write the component data
	}
  }

	  
  read(reader: BinaryReader): void {
	const count = reader.readUvarint(); // Read the length of the array
	const values: TableCell[] = [];

	for (let i = 0; i < count; i++) {
	  const obj = unmarshal(reader); // Read and unmarshal each component
	  values.push(obj as TableCell); // Cast and add to the array
	}

	this.value = values;
  }	
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 102);
		return
	}
}


export class TableColumns implements Writeable, Readable  {
	public value: TableColumn[];
	
	constructor(value: TableColumn[] = []) {
 
      this.value = value;
    }

  isZero(): boolean {
	return !this.value || this.value.length === 0;
  }

  reset(): void {
	this.value = [];
  }


  write(writer: BinaryWriter): void {
	writer.writeUvarint(this.value.length); // Write the length of the array
	for (const c of this.value) {
	  c.writeTypeHeader(writer); // Write the type header for each component
	  c.write(writer); // Write the component data
	}
  }

	  
  read(reader: BinaryReader): void {
	const count = reader.readUvarint(); // Read the length of the array
	const values: TableColumn[] = [];

	for (let i = 0; i < count; i++) {
	  const obj = unmarshal(reader); // Read and unmarshal each component
	  values.push(obj as TableColumn); // Cast and add to the array
	}

	this.value = values;
  }	
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 103);
		return
	}
}


export class TextView implements Writeable, Readable , Component  {
		public value: Str;

	// Color denotes the text color. Leave empty, for the context sensitiv default theme color.
	public color: Color;

	// BackgroundColor denotes the color of the text background. Leave empty, for the context sensitiv default theme color.
	public backgroundColor: Color;

		public onClick: Ptr;

		public onHoverStart: Ptr;

		public onHoverEnd: Ptr;

		public border: Border;

		public padding: Padding;

		public frame: Frame;

		public accessibilityLabel: Str;

		public font: Font;

		public action: Ptr;

		public textAlignment: TextAlignment;

		public hoveredBackgroundColor: Color;

		public pressedBackgroundColor: Color;

		public focusedBackgroundColor: Color;

		public hoveredBorder: Border;

		public pressedBorder: Border;

		public focusedBorder: Border;

		public lineBreak: Bool;

		public invisible: Bool;

	constructor(value: Str = new Str(), color: Color = new Color(), backgroundColor: Color = new Color(), onClick: Ptr = new Ptr(), onHoverStart: Ptr = new Ptr(), onHoverEnd: Ptr = new Ptr(), border: Border = new Border(), padding: Padding = new Padding(), frame: Frame = new Frame(), accessibilityLabel: Str = new Str(), font: Font = new Font(), action: Ptr = new Ptr(), textAlignment: TextAlignment = new TextAlignment(), hoveredBackgroundColor: Color = new Color(), pressedBackgroundColor: Color = new Color(), focusedBackgroundColor: Color = new Color(), hoveredBorder: Border = new Border(), pressedBorder: Border = new Border(), focusedBorder: Border = new Border(), lineBreak: Bool = new Bool(), invisible: Bool = new Bool(), ) {
		this.value = value;
		this.color = color;
		this.backgroundColor = backgroundColor;
		this.onClick = onClick;
		this.onHoverStart = onHoverStart;
		this.onHoverEnd = onHoverEnd;
		this.border = border;
		this.padding = padding;
		this.frame = frame;
		this.accessibilityLabel = accessibilityLabel;
		this.font = font;
		this.action = action;
		this.textAlignment = textAlignment;
		this.hoveredBackgroundColor = hoveredBackgroundColor;
		this.pressedBackgroundColor = pressedBackgroundColor;
		this.focusedBackgroundColor = focusedBackgroundColor;
		this.hoveredBorder = hoveredBorder;
		this.pressedBorder = pressedBorder;
		this.focusedBorder = focusedBorder;
		this.lineBreak = lineBreak;
		this.invisible = invisible;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.value.read(reader);
					break
				}
				case 2: {
					this.color.read(reader);
					break
				}
				case 3: {
					this.backgroundColor.read(reader);
					break
				}
				case 4: {
					this.onClick.read(reader);
					break
				}
				case 5: {
					this.onHoverStart.read(reader);
					break
				}
				case 6: {
					this.onHoverEnd.read(reader);
					break
				}
				case 7: {
					this.border.read(reader);
					break
				}
				case 8: {
					this.padding.read(reader);
					break
				}
				case 9: {
					this.frame.read(reader);
					break
				}
				case 10: {
					this.accessibilityLabel.read(reader);
					break
				}
				case 11: {
					this.font.read(reader);
					break
				}
				case 12: {
					this.action.read(reader);
					break
				}
				case 13: {
					this.textAlignment.read(reader);
					break
				}
				case 14: {
					this.hoveredBackgroundColor.read(reader);
					break
				}
				case 15: {
					this.pressedBackgroundColor.read(reader);
					break
				}
				case 16: {
					this.focusedBackgroundColor.read(reader);
					break
				}
				case 17: {
					this.hoveredBorder.read(reader);
					break
				}
				case 18: {
					this.pressedBorder.read(reader);
					break
				}
				case 19: {
					this.focusedBorder.read(reader);
					break
				}
				case 20: {
					this.lineBreak.read(reader);
					break
				}
				case 21: {
					this.invisible.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.value.isZero(),!this.color.isZero(),!this.backgroundColor.isZero(),!this.onClick.isZero(),!this.onHoverStart.isZero(),!this.onHoverEnd.isZero(),!this.border.isZero(),!this.padding.isZero(),!this.frame.isZero(),!this.accessibilityLabel.isZero(),!this.font.isZero(),!this.action.isZero(),!this.textAlignment.isZero(),!this.hoveredBackgroundColor.isZero(),!this.pressedBackgroundColor.isZero(),!this.focusedBackgroundColor.isZero(),!this.hoveredBorder.isZero(),!this.pressedBorder.isZero(),!this.focusedBorder.isZero(),!this.lineBreak.isZero(),!this.invisible.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			this.value.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			this.color.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			this.backgroundColor.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			this.onClick.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.UVARINT, 5);
			this.onHoverStart.write(writer);
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.UVARINT, 6);
			this.onHoverEnd.write(writer);
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.RECORD, 7);
			this.border.write(writer);
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.RECORD, 8);
			this.padding.write(writer);
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.RECORD, 9);
			this.frame.write(writer);
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 10);
			this.accessibilityLabel.write(writer);
		}
		if (fields[11]) {
			writer.writeFieldHeader(Shapes.RECORD, 11);
			this.font.write(writer);
		}
		if (fields[12]) {
			writer.writeFieldHeader(Shapes.UVARINT, 12);
			this.action.write(writer);
		}
		if (fields[13]) {
			writer.writeFieldHeader(Shapes.UVARINT, 13);
			this.textAlignment.write(writer);
		}
		if (fields[14]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 14);
			this.hoveredBackgroundColor.write(writer);
		}
		if (fields[15]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 15);
			this.pressedBackgroundColor.write(writer);
		}
		if (fields[16]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 16);
			this.focusedBackgroundColor.write(writer);
		}
		if (fields[17]) {
			writer.writeFieldHeader(Shapes.RECORD, 17);
			this.hoveredBorder.write(writer);
		}
		if (fields[18]) {
			writer.writeFieldHeader(Shapes.RECORD, 18);
			this.pressedBorder.write(writer);
		}
		if (fields[19]) {
			writer.writeFieldHeader(Shapes.RECORD, 19);
			this.focusedBorder.write(writer);
		}
		if (fields[20]) {
			writer.writeFieldHeader(Shapes.UVARINT, 20);
			this.lineBreak.write(writer);
		}
		if (fields[21]) {
			writer.writeFieldHeader(Shapes.UVARINT, 21);
			this.invisible.write(writer);
		}
	}

	isZero(): boolean {
		return this.value.isZero() && this.color.isZero() && this.backgroundColor.isZero() && this.onClick.isZero() && this.onHoverStart.isZero() && this.onHoverEnd.isZero() && this.border.isZero() && this.padding.isZero() && this.frame.isZero() && this.accessibilityLabel.isZero() && this.font.isZero() && this.action.isZero() && this.textAlignment.isZero() && this.hoveredBackgroundColor.isZero() && this.pressedBackgroundColor.isZero() && this.focusedBackgroundColor.isZero() && this.hoveredBorder.isZero() && this.pressedBorder.isZero() && this.focusedBorder.isZero() && this.lineBreak.isZero() && this.invisible.isZero()
	}

	reset(): void {
		this.value.reset()
		this.color.reset()
		this.backgroundColor.reset()
		this.onClick.reset()
		this.onHoverStart.reset()
		this.onHoverEnd.reset()
		this.border.reset()
		this.padding.reset()
		this.frame.reset()
		this.accessibilityLabel.reset()
		this.font.reset()
		this.action.reset()
		this.textAlignment.reset()
		this.hoveredBackgroundColor.reset()
		this.pressedBackgroundColor.reset()
		this.focusedBackgroundColor.reset()
		this.hoveredBorder.reset()
		this.pressedBorder.reset()
		this.focusedBorder.reset()
		this.lineBreak.reset()
		this.invisible.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 104);
		return
	}
	isComponent(): void{}
}


export class TextAlignment implements Writeable, Readable {
 
	public value: number; // Using number to handle uint64 (precision limits apply)
	
	constructor(value: number = 0) {
		this.value = value;
	}
	
	isZero(): boolean {
		return this.value === 0;
	}
	
	reset(): void {
		this.value = 0;
	}
	
	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value);
	}
	
	read(reader: BinaryReader): void {
		this.value = reader.readUvarint();
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.UVARINT, 105);
		return
	}
}

// companion enum containing all defined constants for TextAlignment
export enum TextAlignmentValues {
		TextAlignInherit = 0,
		TextAlignStart = 1,
		TextAlignEnd = 2,
		TextAlignCenter = 3,
		TextAlignJustify = 4,
}



export class TextField implements Writeable, Readable , Component  {
		public label: Str;

		public supportingText: Str;

	// ErrorText is shown instead of SupportingText, even if they are (today) independent
	public errorText: Str;

	// Value contains the text, which shall be shown.
	public value: Str;

		public frame: Frame;

	// InputValue is a binding to a state, into which the frontend will the user entered text. This is the pointer a State.
	public inputValue: Ptr;

	// Style to apply. Use TextFieldReduced in forms where many textfields cause too much visual noise and you need to reduce it. By default, the TextFieldOutlined is applied.
	public style: TextFieldStyle;

	// Leading shows the given component usually at the left (or right if RTL). This can be used for additional symbols like a magnifying glass for searching.
	public leading?: Component;

	// Trailing show the given component usually at the right (or left if RTL mode). If set, the clear (or x button) must not be shown, to reduce distraction. This can be used for an Info button or a text showing a value unit.
	public trailing?: Component;

	// DebounceTime is in nanoseconds. A zero or omitted value means to enable debounce default logic.
	public debounceTime: Duration;

	// Lines enforces a single line if <= 0, otherwise it shows the amount of text lines within a text area.
	public lines: Uint;

		public keyboardOptions: KeyboardOptions;

		public disabled: Bool;

		public disableAutocomplete: Bool;

	// DisableDebounce must be set to true, to disable the default debouncer logic. This will cause a render roundtrip for each keystroke, so be careful not to break the server or cause UX issues due to UI latencies.
	public disableDebounce: Bool;

		public invisible: Bool;

	// If Revealed the password is shown
	public revealed: Bool;

	constructor(label: Str = new Str(), supportingText: Str = new Str(), errorText: Str = new Str(), value: Str = new Str(), frame: Frame = new Frame(), inputValue: Ptr = new Ptr(), style: TextFieldStyle = new TextFieldStyle(), leading = undefined, trailing = undefined, debounceTime: Duration = new Duration(), lines: Uint = new Uint(), keyboardOptions: KeyboardOptions = new KeyboardOptions(), disabled: Bool = new Bool(), disableAutocomplete: Bool = new Bool(), disableDebounce: Bool = new Bool(), invisible: Bool = new Bool(), revealed: Bool = new Bool(), ) {
		this.label = label;
		this.supportingText = supportingText;
		this.errorText = errorText;
		this.value = value;
		this.frame = frame;
		this.inputValue = inputValue;
		this.style = style;
		this.leading = leading;
		this.trailing = trailing;
		this.debounceTime = debounceTime;
		this.lines = lines;
		this.keyboardOptions = keyboardOptions;
		this.disabled = disabled;
		this.disableAutocomplete = disableAutocomplete;
		this.disableDebounce = disableDebounce;
		this.invisible = invisible;
		this.revealed = revealed;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.label.read(reader);
					break
				}
				case 2: {
					this.supportingText.read(reader);
					break
				}
				case 3: {
					this.errorText.read(reader);
					break
				}
				case 4: {
					this.value.read(reader);
					break
				}
				case 5: {
					this.frame.read(reader);
					break
				}
				case 6: {
					this.inputValue.read(reader);
					break
				}
				case 7: {
					this.style.read(reader);
					break
				}
				case 8: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
					  throw new Error(`unexpected length: ` + len);
					}
					this.leading = unmarshal(reader) as Component;
					break
				}
				case 9: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
					  throw new Error(`unexpected length: ` + len);
					}
					this.trailing = unmarshal(reader) as Component;
					break
				}
				case 10: {
					this.debounceTime.read(reader);
					break
				}
				case 11: {
					this.lines.read(reader);
					break
				}
				case 12: {
					this.keyboardOptions.read(reader);
					break
				}
				case 13: {
					this.disabled.read(reader);
					break
				}
				case 14: {
					this.disableAutocomplete.read(reader);
					break
				}
				case 15: {
					this.disableDebounce.read(reader);
					break
				}
				case 16: {
					this.invisible.read(reader);
					break
				}
				case 17: {
					this.revealed.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.label.isZero(),!this.supportingText.isZero(),!this.errorText.isZero(),!this.value.isZero(),!this.frame.isZero(),!this.inputValue.isZero(),!this.style.isZero(),this.leading!== undefined && !this.leading.isZero(),this.trailing!== undefined && !this.trailing.isZero(),!this.debounceTime.isZero(),!this.lines.isZero(),!this.keyboardOptions.isZero(),!this.disabled.isZero(),!this.disableAutocomplete.isZero(),!this.disableDebounce.isZero(),!this.invisible.isZero(),!this.revealed.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			this.label.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			this.supportingText.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			this.errorText.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			this.value.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.RECORD, 5);
			this.frame.write(writer);
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.UVARINT, 6);
			this.inputValue.write(writer);
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.UVARINT, 7);
			this.style.write(writer);
		}
		if (fields[8]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 8);
			writer.writeByte(1);
			this.leading!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[9]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 9);
			writer.writeByte(1);
			this.trailing!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.UVARINT, 10);
			this.debounceTime.write(writer);
		}
		if (fields[11]) {
			writer.writeFieldHeader(Shapes.UVARINT, 11);
			this.lines.write(writer);
		}
		if (fields[12]) {
			writer.writeFieldHeader(Shapes.RECORD, 12);
			this.keyboardOptions.write(writer);
		}
		if (fields[13]) {
			writer.writeFieldHeader(Shapes.UVARINT, 13);
			this.disabled.write(writer);
		}
		if (fields[14]) {
			writer.writeFieldHeader(Shapes.UVARINT, 14);
			this.disableAutocomplete.write(writer);
		}
		if (fields[15]) {
			writer.writeFieldHeader(Shapes.UVARINT, 15);
			this.disableDebounce.write(writer);
		}
		if (fields[16]) {
			writer.writeFieldHeader(Shapes.UVARINT, 16);
			this.invisible.write(writer);
		}
		if (fields[17]) {
			writer.writeFieldHeader(Shapes.UVARINT, 17);
			this.revealed.write(writer);
		}
	}

	isZero(): boolean {
		return this.label.isZero() && this.supportingText.isZero() && this.errorText.isZero() && this.value.isZero() && this.frame.isZero() && this.inputValue.isZero() && this.style.isZero() && (this.leading=== undefined || this.leading.isZero()) && (this.trailing=== undefined || this.trailing.isZero()) && this.debounceTime.isZero() && this.lines.isZero() && this.keyboardOptions.isZero() && this.disabled.isZero() && this.disableAutocomplete.isZero() && this.disableDebounce.isZero() && this.invisible.isZero() && this.revealed.isZero()
	}

	reset(): void {
		this.label.reset()
		this.supportingText.reset()
		this.errorText.reset()
		this.value.reset()
		this.frame.reset()
		this.inputValue.reset()
		this.style.reset()
		this.leading = undefined
		this.trailing = undefined
		this.debounceTime.reset()
		this.lines.reset()
		this.keyboardOptions.reset()
		this.disabled.reset()
		this.disableAutocomplete.reset()
		this.disableDebounce.reset()
		this.invisible.reset()
		this.revealed.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 106);
		return
	}
	isComponent(): void{}
}


// Toggle is just a kind of checkbox without a label. However, a toggle shall be used for immediate activation functions. In contrast to that, use a checkbox for form things without an immediate effect.
export class Toggle implements Writeable, Readable , Component  {
	// InputValue is where updated value of the checked states are written.
	public inputValue: Ptr;

		public value: Bool;

		public disabled: Bool;

		public invisible: Bool;

	constructor(inputValue: Ptr = new Ptr(), value: Bool = new Bool(), disabled: Bool = new Bool(), invisible: Bool = new Bool(), ) {
		this.inputValue = inputValue;
		this.value = value;
		this.disabled = disabled;
		this.invisible = invisible;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.inputValue.read(reader);
					break
				}
				case 2: {
					this.value.read(reader);
					break
				}
				case 3: {
					this.disabled.read(reader);
					break
				}
				case 4: {
					this.invisible.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.inputValue.isZero(),!this.value.isZero(),!this.disabled.isZero(),!this.invisible.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			this.inputValue.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			this.value.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			this.disabled.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			this.invisible.write(writer);
		}
	}

	isZero(): boolean {
		return this.inputValue.isZero() && this.value.isZero() && this.disabled.isZero() && this.invisible.isZero()
	}

	reset(): void {
		this.inputValue.reset()
		this.value.reset()
		this.disabled.reset()
		this.invisible.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 107);
		return
	}
	isComponent(): void{}
}


// A TextLayout places its content like a native Text would layout its words, using the same rules for word wrap
// and alignments. This allows to style inline-components individually. SwiftUI can do this using + on
// Text and Images. Jetpack has the concept of annotated strings.
export class TextLayout implements Writeable, Readable , Component  {
		public children: Components;

		public border: Border;

		public frame: Frame;

		public backgroundColor: Color;

		public padding: Padding;

		public accessibilityLabel: Str;

		public font: Font;

		public action: Ptr;

		public textAlignment: TextAlignment;

		public invisible: Bool;

	constructor(children: Components = new Components(), border: Border = new Border(), frame: Frame = new Frame(), backgroundColor: Color = new Color(), padding: Padding = new Padding(), accessibilityLabel: Str = new Str(), font: Font = new Font(), action: Ptr = new Ptr(), textAlignment: TextAlignment = new TextAlignment(), invisible: Bool = new Bool(), ) {
		this.children = children;
		this.border = border;
		this.frame = frame;
		this.backgroundColor = backgroundColor;
		this.padding = padding;
		this.accessibilityLabel = accessibilityLabel;
		this.font = font;
		this.action = action;
		this.textAlignment = textAlignment;
		this.invisible = invisible;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.children.read(reader);
					break
				}
				case 2: {
					this.border.read(reader);
					break
				}
				case 3: {
					this.frame.read(reader);
					break
				}
				case 4: {
					this.backgroundColor.read(reader);
					break
				}
				case 5: {
					this.padding.read(reader);
					break
				}
				case 6: {
					this.accessibilityLabel.read(reader);
					break
				}
				case 7: {
					this.font.read(reader);
					break
				}
				case 8: {
					this.action.read(reader);
					break
				}
				case 9: {
					this.textAlignment.read(reader);
					break
				}
				case 10: {
					this.invisible.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.children.isZero(),!this.border.isZero(),!this.frame.isZero(),!this.backgroundColor.isZero(),!this.padding.isZero(),!this.accessibilityLabel.isZero(),!this.font.isZero(),!this.action.isZero(),!this.textAlignment.isZero(),!this.invisible.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			this.children.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.RECORD, 2);
			this.border.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.RECORD, 3);
			this.frame.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			this.backgroundColor.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.RECORD, 5);
			this.padding.write(writer);
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 6);
			this.accessibilityLabel.write(writer);
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.RECORD, 7);
			this.font.write(writer);
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.UVARINT, 8);
			this.action.write(writer);
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.UVARINT, 9);
			this.textAlignment.write(writer);
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.UVARINT, 10);
			this.invisible.write(writer);
		}
	}

	isZero(): boolean {
		return this.children.isZero() && this.border.isZero() && this.frame.isZero() && this.backgroundColor.isZero() && this.padding.isZero() && this.accessibilityLabel.isZero() && this.font.isZero() && this.action.isZero() && this.textAlignment.isZero() && this.invisible.isZero()
	}

	reset(): void {
		this.children.reset()
		this.border.reset()
		this.frame.reset()
		this.backgroundColor.reset()
		this.padding.reset()
		this.accessibilityLabel.reset()
		this.font.reset()
		this.action.reset()
		this.textAlignment.reset()
		this.invisible.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 108);
		return
	}
	isComponent(): void{}
}


// An VStack aligns children elements in a vertical column.
//  - the intrinsic component dimensions are the sum of all sizes of the contained children
//  - the parent can define a custom width and height
//  - if the container is larger than the contained views, it must center vertical or horizontal
//  - the inner gap between components should be around 2dp
export class VStack implements Writeable, Readable , Component  {
		public children: Components;

		public gap: Length;

		public frame: Frame;

	// Zero value of Alignment is Center (=c) must be applied.
	public alignment: Alignment;

		public backgroundColor: Color;

		public padding: Padding;

	// see also https://www.w3.org/WAI/tutorials/images/decision-tree/
	public accessibilityLabel: Str;

		public border: Border;

		public font: Font;

		public action: Ptr;

		public hoveredBackgroundColor: Color;

		public pressedBackgroundColor: Color;

		public focusedBackgroundColor: Color;

		public hoveredBorder: Border;

		public pressedBorder: Border;

		public focusedBorder: Border;

		public stylePreset: StylePreset;

		public position: Position;

		public disabled: Bool;

		public invisible: Bool;

	constructor(children: Components = new Components(), gap: Length = new Length(), frame: Frame = new Frame(), alignment: Alignment = new Alignment(), backgroundColor: Color = new Color(), padding: Padding = new Padding(), accessibilityLabel: Str = new Str(), border: Border = new Border(), font: Font = new Font(), action: Ptr = new Ptr(), hoveredBackgroundColor: Color = new Color(), pressedBackgroundColor: Color = new Color(), focusedBackgroundColor: Color = new Color(), hoveredBorder: Border = new Border(), pressedBorder: Border = new Border(), focusedBorder: Border = new Border(), stylePreset: StylePreset = new StylePreset(), position: Position = new Position(), disabled: Bool = new Bool(), invisible: Bool = new Bool(), ) {
		this.children = children;
		this.gap = gap;
		this.frame = frame;
		this.alignment = alignment;
		this.backgroundColor = backgroundColor;
		this.padding = padding;
		this.accessibilityLabel = accessibilityLabel;
		this.border = border;
		this.font = font;
		this.action = action;
		this.hoveredBackgroundColor = hoveredBackgroundColor;
		this.pressedBackgroundColor = pressedBackgroundColor;
		this.focusedBackgroundColor = focusedBackgroundColor;
		this.hoveredBorder = hoveredBorder;
		this.pressedBorder = pressedBorder;
		this.focusedBorder = focusedBorder;
		this.stylePreset = stylePreset;
		this.position = position;
		this.disabled = disabled;
		this.invisible = invisible;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.children.read(reader);
					break
				}
				case 2: {
					this.gap.read(reader);
					break
				}
				case 3: {
					this.frame.read(reader);
					break
				}
				case 4: {
					this.alignment.read(reader);
					break
				}
				case 5: {
					this.backgroundColor.read(reader);
					break
				}
				case 6: {
					this.padding.read(reader);
					break
				}
				case 7: {
					this.accessibilityLabel.read(reader);
					break
				}
				case 8: {
					this.border.read(reader);
					break
				}
				case 9: {
					this.font.read(reader);
					break
				}
				case 10: {
					this.action.read(reader);
					break
				}
				case 11: {
					this.hoveredBackgroundColor.read(reader);
					break
				}
				case 12: {
					this.pressedBackgroundColor.read(reader);
					break
				}
				case 13: {
					this.focusedBackgroundColor.read(reader);
					break
				}
				case 14: {
					this.hoveredBorder.read(reader);
					break
				}
				case 15: {
					this.pressedBorder.read(reader);
					break
				}
				case 16: {
					this.focusedBorder.read(reader);
					break
				}
				case 17: {
					this.stylePreset.read(reader);
					break
				}
				case 18: {
					this.position.read(reader);
					break
				}
				case 19: {
					this.disabled.read(reader);
					break
				}
				case 20: {
					this.invisible.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.children.isZero(),!this.gap.isZero(),!this.frame.isZero(),!this.alignment.isZero(),!this.backgroundColor.isZero(),!this.padding.isZero(),!this.accessibilityLabel.isZero(),!this.border.isZero(),!this.font.isZero(),!this.action.isZero(),!this.hoveredBackgroundColor.isZero(),!this.pressedBackgroundColor.isZero(),!this.focusedBackgroundColor.isZero(),!this.hoveredBorder.isZero(),!this.pressedBorder.isZero(),!this.focusedBorder.isZero(),!this.stylePreset.isZero(),!this.position.isZero(),!this.disabled.isZero(),!this.invisible.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			this.children.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			this.gap.write(writer);
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.RECORD, 3);
			this.frame.write(writer);
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			this.alignment.write(writer);
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			this.backgroundColor.write(writer);
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.RECORD, 6);
			this.padding.write(writer);
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 7);
			this.accessibilityLabel.write(writer);
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.RECORD, 8);
			this.border.write(writer);
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.RECORD, 9);
			this.font.write(writer);
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.UVARINT, 10);
			this.action.write(writer);
		}
		if (fields[11]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 11);
			this.hoveredBackgroundColor.write(writer);
		}
		if (fields[12]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 12);
			this.pressedBackgroundColor.write(writer);
		}
		if (fields[13]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 13);
			this.focusedBackgroundColor.write(writer);
		}
		if (fields[14]) {
			writer.writeFieldHeader(Shapes.RECORD, 14);
			this.hoveredBorder.write(writer);
		}
		if (fields[15]) {
			writer.writeFieldHeader(Shapes.RECORD, 15);
			this.pressedBorder.write(writer);
		}
		if (fields[16]) {
			writer.writeFieldHeader(Shapes.RECORD, 16);
			this.focusedBorder.write(writer);
		}
		if (fields[17]) {
			writer.writeFieldHeader(Shapes.UVARINT, 17);
			this.stylePreset.write(writer);
		}
		if (fields[18]) {
			writer.writeFieldHeader(Shapes.RECORD, 18);
			this.position.write(writer);
		}
		if (fields[19]) {
			writer.writeFieldHeader(Shapes.UVARINT, 19);
			this.disabled.write(writer);
		}
		if (fields[20]) {
			writer.writeFieldHeader(Shapes.UVARINT, 20);
			this.invisible.write(writer);
		}
	}

	isZero(): boolean {
		return this.children.isZero() && this.gap.isZero() && this.frame.isZero() && this.alignment.isZero() && this.backgroundColor.isZero() && this.padding.isZero() && this.accessibilityLabel.isZero() && this.border.isZero() && this.font.isZero() && this.action.isZero() && this.hoveredBackgroundColor.isZero() && this.pressedBackgroundColor.isZero() && this.focusedBackgroundColor.isZero() && this.hoveredBorder.isZero() && this.pressedBorder.isZero() && this.focusedBorder.isZero() && this.stylePreset.isZero() && this.position.isZero() && this.disabled.isZero() && this.invisible.isZero()
	}

	reset(): void {
		this.children.reset()
		this.gap.reset()
		this.frame.reset()
		this.alignment.reset()
		this.backgroundColor.reset()
		this.padding.reset()
		this.accessibilityLabel.reset()
		this.border.reset()
		this.font.reset()
		this.action.reset()
		this.hoveredBackgroundColor.reset()
		this.pressedBackgroundColor.reset()
		this.focusedBackgroundColor.reset()
		this.hoveredBorder.reset()
		this.pressedBorder.reset()
		this.focusedBorder.reset()
		this.stylePreset.reset()
		this.position.reset()
		this.disabled.reset()
		this.invisible.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 109);
		return
	}
	isComponent(): void{}
}


export class WebView implements Writeable, Readable , Component  {
		public uRI: URI;

		public frame: Frame;

	constructor(uRI: URI = new URI(), frame: Frame = new Frame(), ) {
		this.uRI = uRI;
		this.frame = frame;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.uRI.read(reader);
					break
				}
				case 2: {
					this.frame.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.uRI.isZero(),!this.frame.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			this.uRI.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.RECORD, 2);
			this.frame.write(writer);
		}
	}

	isZero(): boolean {
		return this.uRI.isZero() && this.frame.isZero()
	}

	reset(): void {
		this.uRI.reset()
		this.frame.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 110);
		return
	}
	isComponent(): void{}
}


// WindowInfoChanged is raised by the frontend whenever the window metrics changed in a significant way. It is not guaranteed that every pixel change will trigger such an event. However, a frontend must guarantee to send such an event if the WindowSizeClass is changed.
export class WindowInfoChanged implements Writeable, Readable , NagoEvent  {
		public windowInfo: WindowInfo;

		public rID: RID;

	constructor(windowInfo: WindowInfo = new WindowInfo(), rID: RID = new RID(), ) {
		this.windowInfo = windowInfo;
		this.rID = rID;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.windowInfo.read(reader);
					break
				}
				case 2: {
					this.rID.read(reader);
					break
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false,!this.windowInfo.isZero(),!this.rID.isZero(),];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.RECORD, 1);
			this.windowInfo.write(writer);
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			this.rID.write(writer);
		}
	}

	isZero(): boolean {
		return this.windowInfo.isZero() && this.rID.isZero()
	}

	reset(): void {
		this.windowInfo.reset()
		this.rID.reset()
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 111);
		return
	}
	isNagoEvent(): void{}
}

// Function to marshal a Writeable object into a BinaryWriter
export function marshal(dst: BinaryWriter, src: Writeable): void {
	src.writeTypeHeader(dst);
	src.write(dst);
}

// Function to unmarshal data from a BinaryReader into a Readable object
export function unmarshal(src: BinaryReader): Readable {
	const { typeId } = src.readTypeHeader();
	switch (typeId) {
		case 1: {
			const v = new Box();
			v.read(src);
			return v;
		}
		case 2: {
			const v = new Ptr();
			v.read(src);
			return v;
		}
		case 3: {
			const v = new UpdateStateValueRequested();
			v.read(src);
			return v;
		}
		case 4: {
			const v = new FunctionCallRequested();
			v.read(src);
			return v;
		}
		case 5: {
			const v = new Alignment();
			v.read(src);
			return v;
		}
		case 6: {
			const v = new Color();
			v.read(src);
			return v;
		}
		case 7: {
			const v = new Shadow();
			v.read(src);
			return v;
		}
		case 8: {
			const v = new Length();
			v.read(src);
			return v;
		}
		case 9: {
			const v = new Border();
			v.read(src);
			return v;
		}
		case 10: {
			const v = new Frame();
			v.read(src);
			return v;
		}
		case 11: {
			const v = new Padding();
			v.read(src);
			return v;
		}
		case 12: {
			const v = new AlignedComponent();
			v.read(src);
			return v;
		}
		case 13: {
			const v = new Components();
			v.read(src);
			return v;
		}
		case 14: {
			const v = new AlignedComponents();
			v.read(src);
			return v;
		}
		case 15: {
			const v = new Checkbox();
			v.read(src);
			return v;
		}
		case 16: {
			const v = new Bool();
			v.read(src);
			return v;
		}
		case 17: {
			const v = new ErrorOccurred();
			v.read(src);
			return v;
		}
		case 18: {
			const v = new Locale();
			v.read(src);
			return v;
		}
		case 19: {
			const v = new FontStyle();
			v.read(src);
			return v;
		}
		case 20: {
			const v = new RootViewID();
			v.read(src);
			return v;
		}
		case 21: {
			const v = new RootViewParameters();
			v.read(src);
			return v;
		}
		case 22: {
			const v = new Str();
			v.read(src);
			return v;
		}
		case 23: {
			const v = new RootViewRenderingRequested();
			v.read(src);
			return v;
		}
		case 24: {
			const v = new RootViewDestructionRequested();
			v.read(src);
			return v;
		}
		case 25: {
			const v = new RootViewInvalidated();
			v.read(src);
			return v;
		}
		case 26: {
			const v = new ErrorRootViewAllocationRequired();
			v.read(src);
			return v;
		}
		case 27: {
			const v = new RootViewAllocationRequested();
			v.read(src);
			return v;
		}
		case 28: {
			const v = new WindowSizeClass();
			v.read(src);
			return v;
		}
		case 29: {
			const v = new ScopeConfigurationChangeRequested();
			v.read(src);
			return v;
		}
		case 30: {
			const v = new ColorScheme();
			v.read(src);
			return v;
		}
		case 31: {
			const v = new WindowInfo();
			v.read(src);
			return v;
		}
		case 32: {
			const v = new DP();
			v.read(src);
			return v;
		}
		case 33: {
			const v = new Density();
			v.read(src);
			return v;
		}
		case 34: {
			const v = new ScopeConfigurationChanged();
			v.read(src);
			return v;
		}
		case 35: {
			const v = new Locales();
			v.read(src);
			return v;
		}
		case 36: {
			const v = new URI();
			v.read(src);
			return v;
		}
		case 37: {
			const v = new NamespaceName();
			v.read(src);
			return v;
		}
		case 38: {
			const v = new NamedColors();
			v.read(src);
			return v;
		}
		case 39: {
			const v = new Theme();
			v.read(src);
			return v;
		}
		case 40: {
			const v = new NamespacedColors();
			v.read(src);
			return v;
		}
		case 41: {
			const v = new NamedLengths();
			v.read(src);
			return v;
		}
		case 42: {
			const v = new Themes();
			v.read(src);
			return v;
		}
		case 43: {
			const v = new DatePickerStyle();
			v.read(src);
			return v;
		}
		case 44: {
			const v = new Day();
			v.read(src);
			return v;
		}
		case 45: {
			const v = new DateData();
			v.read(src);
			return v;
		}
		case 46: {
			const v = new Month();
			v.read(src);
			return v;
		}
		case 47: {
			const v = new Year();
			v.read(src);
			return v;
		}
		case 48: {
			const v = new DatePicker();
			v.read(src);
			return v;
		}
		case 49: {
			const v = new Divider();
			v.read(src);
			return v;
		}
		case 50: {
			const v = new RID();
			v.read(src);
			return v;
		}
		case 51: {
			const v = new FontWeight();
			v.read(src);
			return v;
		}
		case 52: {
			const v = new Font();
			v.read(src);
			return v;
		}
		case 53: {
			const v = new Grid();
			v.read(src);
			return v;
		}
		case 54: {
			const v = new Uint();
			v.read(src);
			return v;
		}
		case 55: {
			const v = new GridCells();
			v.read(src);
			return v;
		}
		case 56: {
			const v = new Lengths();
			v.read(src);
			return v;
		}
		case 57: {
			const v = new GridCell();
			v.read(src);
			return v;
		}
		case 58: {
			const v = new HStack();
			v.read(src);
			return v;
		}
		case 59: {
			const v = new StylePreset();
			v.read(src);
			return v;
		}
		case 60: {
			const v = new Position();
			v.read(src);
			return v;
		}
		case 61: {
			const v = new PositionType();
			v.read(src);
			return v;
		}
		case 62: {
			const v = new Img();
			v.read(src);
			return v;
		}
		case 63: {
			const v = new SVG();
			v.read(src);
			return v;
		}
		case 64: {
			const v = new Strings();
			v.read(src);
			return v;
		}
		case 65: {
			const v = new FileImportRequested();
			v.read(src);
			return v;
		}
		case 66: {
			const v = new KeyboardOptions();
			v.read(src);
			return v;
		}
		case 67: {
			const v = new KeyboardType();
			v.read(src);
			return v;
		}
		case 68: {
			const v = new ModalType();
			v.read(src);
			return v;
		}
		case 69: {
			const v = new Modal();
			v.read(src);
			return v;
		}
		case 70: {
			const v = new ThemeRequested();
			v.read(src);
			return v;
		}
		case 71: {
			const v = new NavigationForwardToRequested();
			v.read(src);
			return v;
		}
		case 72: {
			const v = new NavigationResetRequested();
			v.read(src);
			return v;
		}
		case 73: {
			const v = new NavigationBackRequested();
			v.read(src);
			return v;
		}
		case 74: {
			const v = new NavigationReloadRequested();
			v.read(src);
			return v;
		}
		case 75: {
			const v = new ThemeID();
			v.read(src);
			return v;
		}
		case 76: {
			const v = new OpenRequested();
			v.read(src);
			return v;
		}
		case 77: {
			const v = new WindowTitle();
			v.read(src);
			return v;
		}
		case 78: {
			const v = new Duration();
			v.read(src);
			return v;
		}
		case 79: {
			const v = new PasswordField();
			v.read(src);
			return v;
		}
		case 80: {
			const v = new TextFieldStyle();
			v.read(src);
			return v;
		}
		case 81: {
			const v = new Ping();
			v.read(src);
			return v;
		}
		case 82: {
			const v = new Radiobutton();
			v.read(src);
			return v;
		}
		case 83: {
			const v = new ScaffoldAlignment();
			v.read(src);
			return v;
		}
		case 84: {
			const v = new ScaffoldMenuEntries();
			v.read(src);
			return v;
		}
		case 85: {
			const v = new Scaffold();
			v.read(src);
			return v;
		}
		case 86: {
			const v = new ScaffoldMenuEntry();
			v.read(src);
			return v;
		}
		case 87: {
			const v = new ScopeID();
			v.read(src);
			return v;
		}
		case 88: {
			const v = new ScopeDestructionRequested();
			v.read(src);
			return v;
		}
		case 89: {
			const v = new ScrollViewAxis();
			v.read(src);
			return v;
		}
		case 90: {
			const v = new ScrollView();
			v.read(src);
			return v;
		}
		case 91: {
			const v = new Resource();
			v.read(src);
			return v;
		}
		case 92: {
			const v = new Resources();
			v.read(src);
			return v;
		}
		case 93: {
			const v = new SendMultipleRequested();
			v.read(src);
			return v;
		}
		case 94: {
			const v = new SessionAssigned();
			v.read(src);
			return v;
		}
		case 95: {
			const v = new Spacer();
			v.read(src);
			return v;
		}
		case 96: {
			const v = new Table();
			v.read(src);
			return v;
		}
		case 97: {
			const v = new TableCell();
			v.read(src);
			return v;
		}
		case 98: {
			const v = new TableColumn();
			v.read(src);
			return v;
		}
		case 99: {
			const v = new TableRow();
			v.read(src);
			return v;
		}
		case 100: {
			const v = new TableHeader();
			v.read(src);
			return v;
		}
		case 101: {
			const v = new TableRows();
			v.read(src);
			return v;
		}
		case 102: {
			const v = new TableCells();
			v.read(src);
			return v;
		}
		case 103: {
			const v = new TableColumns();
			v.read(src);
			return v;
		}
		case 104: {
			const v = new TextView();
			v.read(src);
			return v;
		}
		case 105: {
			const v = new TextAlignment();
			v.read(src);
			return v;
		}
		case 106: {
			const v = new TextField();
			v.read(src);
			return v;
		}
		case 107: {
			const v = new Toggle();
			v.read(src);
			return v;
		}
		case 108: {
			const v = new TextLayout();
			v.read(src);
			return v;
		}
		case 109: {
			const v = new VStack();
			v.read(src);
			return v;
		}
		case 110: {
			const v = new WebView();
			v.read(src);
			return v;
		}
		case 111: {
			const v = new WindowInfoChanged();
			v.read(src);
			return v;
		}
	}
	throw new Error(`Unknown type ID: ${typeId}`);
}

