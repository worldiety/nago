// Code generated by NAGO nprotoc DO NOT EDIT.

/**
 * Copyright (c) 2025 worldiety GmbH
 *
 * This file is part of the NAGO Low-Code Platform.
 * Licensed under the terms specified in the LICENSE file.
 *
 * SPDX-License-Identifier: Custom-License
 */

export class BinaryWriter {
	private buffer: Uint8Array;
	private view: DataView;
	private offset: number = 0;
	private tmp: Uint8Array;

	constructor(size: number = 1024) {
		this.buffer = new Uint8Array(size);
		this.tmp = new Uint8Array(8);
		this.view = new DataView(this.buffer.buffer);
	}

	private ensureCapacity(additionalBytes: number) {
		if (this.offset + additionalBytes > this.buffer.length) {
			let nextSize = Math.max(additionalBytes + this.offset * 2, this.buffer.length * 2);
			const newBuffer = new Uint8Array(nextSize);
			newBuffer.set(this.buffer);
			this.buffer = newBuffer;
			this.view = new DataView(this.buffer.buffer);
		}
	}

	write(p: Uint8Array) {
		this.ensureCapacity(p.length);
		this.buffer.set(p, this.offset);
		this.offset += p.length;
	}

	writeBool(b: boolean) {
		this.ensureCapacity(1);
		this.buffer[this.offset++] = b ? 1 : 0;
	}

	writeVarint(value: number) {
		this.ensureCapacity(10); // Maximum varint size is 10 bytes
		let v = value;
		while (v > 127) {
			this.buffer[this.offset++] = (v & 0x7f) | 0x80;
			v >>>= 7;
		}
		this.buffer[this.offset++] = v;
	}

	writeUvarint(value: number) {
		this.writeVarint(value >>> 0);
	}

	writeByte(b: number) {
		this.ensureCapacity(1);
		this.buffer[this.offset++] = b;
	}

	writeFieldHeader(shape: Shape, id: FieldId) {
		this.writeByte((shape << 5) | (id & 0b00011111));
	}

	writeTypeHeader(shape: Shape, id: TypeId) {
		this.writeFieldHeader(shape, 0);
		this.writeUvarint(id);
	}

	writeSlice(data: Uint8Array) {
		this.writeUvarint(data.length);
		this.write(data);
	}

	getBuffer(): Uint8Array {
		return this.buffer.slice(0, this.offset);
	}

	writeFloat64(value: number): void {
		const buffer = new ArrayBuffer(8);
		const float64Bits = new DataView(buffer);
		float64Bits.setFloat64(0, value, true);
		this.tmp.set(new Uint8Array(buffer));
		this.write(this.tmp);
	}
}

export class BinaryReader {
	private buffer: Uint8Array;
	private view: DataView;
	private offset: number = 0;

	constructor(buffer: Uint8Array) {
		this.buffer = buffer;
		this.view = new DataView(buffer.buffer);
	}

	readByte(): number {
		if (this.offset >= this.buffer.length) throw new Error('Out of bounds');
		return this.buffer[this.offset++];
	}

	// Reads a specific number of bytes from the buffer
	readBytes(length: number): Uint8Array {
		if (this.offset + length > this.buffer.length) {
			throw new Error('Attempt to read beyond buffer length');
		}

		const bytes = this.buffer.slice(this.offset, this.offset + length);
		this.offset += length;
		return bytes;
	}

	readFieldHeader(): FieldHeader {
		const value = this.readByte();
		return {
			shape: (value >> 5) & 0b00000111,
			fieldId: value & 0b00011111,
		};
	}

	readTypeHeader(): { shape: Shape; typeId: TypeId } {
		const header = this.readFieldHeader();
		if (header.fieldId !== 0) {
			throw new Error('Expected type header, got field header');
		}
		const typeId = this.readUvarint();
		return { shape: header.shape, typeId };
	}

	readUvarint(): number {
		let result = 0;
		let shift = 0;
		while (true) {
			const byte = this.readByte();
			result |= (byte & 0x7f) << shift;
			if ((byte & 0x80) === 0) break;
			shift += 7;
			if (shift > 35) throw new Error('Varint too long');
		}
		return result;
	}

	readVarint(): number {
		const uvalue = this.readUvarint();
		return (uvalue >>> 1) ^ -(uvalue & 1);
	}

	readFloat64(): number {
		let tmp = this.readBytes(8);
		const buffer = tmp.buffer;
		const view = new DataView(buffer);
		return view.getFloat64(0, true);
	}
}

// Types and Enums

export type Shape = number;
export type FieldId = number;
export type TypeId = number;

export enum Shapes {
	ENVELOPE = 0,
	UVARINT,
	VARINT,
	BYTESLICE,
	RECORD,
	F32,
	F64,
	ARRAY,
}

export interface FieldHeader {
	shape: Shape;
	fieldId: FieldId;
}

// Interface for writable objects
export interface Writeable {
	write(writer: BinaryWriter): void;

	writeTypeHeader(dst: BinaryWriter): void;
}

// Interface for readable objects
export interface Readable {
	read(reader: BinaryReader): void;

	isZero(): boolean;
}

function writeString(writer: BinaryWriter, value: string): void {
	const data = new TextEncoder().encode(value); // Convert string to Uint8Array
	writer.writeUvarint(data.length); // Write the length of the string
	writer.write(data); // Write the string data
}

function readString(reader: BinaryReader): string {
	const strLen = reader.readUvarint(); // Read the length of the string
	const buf = reader.readBytes(strLen); // Read the string data
	return new TextDecoder().decode(buf); // Convert Uint8Array to string
}

function writeInt(writer: BinaryWriter, value: number): void {
	writer.writeUvarint(value);
}

function readInt(reader: BinaryReader): number {
	return reader.readUvarint();
}

function writeSint(writer: BinaryWriter, value: number): void {
	writer.writeVarint(value);
}

function readSint(reader: BinaryReader): number {
	return reader.readVarint();
}

function writeBool(writer: BinaryWriter, value: boolean): void {
	writer.writeUvarint(value ? 1 : 0);
}

function readBool(reader: BinaryReader): boolean {
	return reader.readUvarint() === 1;
}

function writeFloat(writer: BinaryWriter, value: number): void {
	writer.writeFloat64(value);
}

function readFloat(reader: BinaryReader): number {
	return reader.readFloat64();
}

// CallArgs is the sum type of all declared type safe async method invocations including their arguments. See also [RetArgs] for the async result.
export interface CallArgs extends Writeable, Readable {
	// a marker method to indicate the enum / union type membership
	isCallArgs(): void;
}

// CallRet is the sum type of all declared type safe async method invocations results. See also [CallArgs] for the async invocation calls.
export interface CallRet extends Writeable, Readable {
	// a marker method to indicate the enum / union type membership
	isCallRet(): void;
}

// Component is the building primitive for any widget, behavior or ui element in NAGO.
export interface Component extends Writeable, Readable {
	// a marker method to indicate the enum / union type membership
	isComponent(): void;
}

// NagoEvent is the union type of all allowed NAGO protocol events. Everything which goes through a NAGO channel must be an Event at the root level.
export interface NagoEvent extends Writeable, Readable {
	// a marker method to indicate the enum / union type membership
	isNagoEvent(): void;
}

// A Box aligns children elements in absolute within its bounds.
//  - there is no intrinsic component dimension, so you have to set it by hand
//  - z-order is defined as defined children order, thus later children are put on top of others
//  - it is undefined behavior, to define multiple children with the same alignment. So this must not be rendered.
export class Box implements Writeable, Readable, Component {
	public children?: AlignedComponents;

	public frame?: Frame;

	public backgroundColor?: Color;

	public padding?: Padding;

	public border?: Border;

	constructor(
		children: AlignedComponents | undefined = undefined,
		frame: Frame | undefined = undefined,
		backgroundColor: Color | undefined = undefined,
		padding: Padding | undefined = undefined,
		border: Border | undefined = undefined
	) {
		this.children = children;
		this.frame = frame;
		this.backgroundColor = backgroundColor;
		this.padding = padding;
		this.border = border;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.children = new AlignedComponents();
					this.children.read(reader);
					break;
				}
				case 2: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				case 3: {
					this.backgroundColor = readString(reader);
					break;
				}
				case 4: {
					this.padding = new Padding();
					this.padding.read(reader);
					break;
				}
				case 5: {
					this.border = new Border();
					this.border.read(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.children !== undefined && !this.children.isZero(),
			this.frame !== undefined && !this.frame.isZero(),
			this.backgroundColor !== undefined,
			this.padding !== undefined && !this.padding.isZero(),
			this.border !== undefined && !this.border.isZero(),
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			this.children!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.RECORD, 2);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			writeString(writer, this.backgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.RECORD, 4);
			this.padding!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.RECORD, 5);
			this.border!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			(this.children === undefined || this.children.isZero()) &&
			(this.frame === undefined || this.frame.isZero()) &&
			this.backgroundColor === undefined &&
			(this.padding === undefined || this.padding.isZero()) &&
			(this.border === undefined || this.border.isZero())
		);
	}

	reset(): void {
		this.children = undefined;
		this.frame = undefined;
		this.backgroundColor = undefined;
		this.padding = undefined;
		this.border = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 1);
		return;
	}
	isComponent(): void {}
}

// Ptr represents an allocated instance within the backend which is unique in the associated scope.
export type Ptr = number;
function writeTypeHeaderPtr(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 2);
	return;
}
// companion enum containing all defined constants for Ptr
export enum PtrValues {
	// Null represents the zero value and a nil or null pointer address.
	Null = 0,
}

// UpdateStateValueRequested is raised from the frontend to update a state value hold by the backend. It can also immediately invoke a function callback in the same cycle.
export class UpdateStateValueRequested implements Writeable, Readable, NagoEvent {
	// The StatePointer must not be zero.
	public statePointer?: Ptr;

	// A FunctionPointer is invoked, if not zero.
	public functionPointer?: Ptr;

	public rID?: RID;

	public value?: Str;

	constructor(
		statePointer: Ptr | undefined = undefined,
		functionPointer: Ptr | undefined = undefined,
		rID: RID | undefined = undefined,
		value: Str | undefined = undefined
	) {
		this.statePointer = statePointer;
		this.functionPointer = functionPointer;
		this.rID = rID;
		this.value = value;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.statePointer = readInt(reader);
					break;
				}
				case 2: {
					this.functionPointer = readInt(reader);
					break;
				}
				case 3: {
					this.rID = readInt(reader);
					break;
				}
				case 4: {
					this.value = readString(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.statePointer !== undefined,
			this.functionPointer !== undefined,
			this.rID !== undefined,
			this.value !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			writeInt(writer, this.statePointer!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			writeInt(writer, this.functionPointer!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			writeInt(writer, this.rID!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			writeString(writer, this.value!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.statePointer === undefined &&
			this.functionPointer === undefined &&
			this.rID === undefined &&
			this.value === undefined
		);
	}

	reset(): void {
		this.statePointer = undefined;
		this.functionPointer = undefined;
		this.rID = undefined;
		this.value = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 3);
		return;
	}
	isNagoEvent(): void {}
}

// FunctionCallRequested tells the backend that the given pointer in the associated scope shall be invoked for a side effect.
export class FunctionCallRequested implements Writeable, Readable, NagoEvent {
	// Ptr denotes the remote pointer of the function.
	public ptr?: Ptr;

	// RID is used to trace a request-response cycle.
	public rID?: RID;

	constructor(ptr: Ptr | undefined = undefined, rID: RID | undefined = undefined) {
		this.ptr = ptr;
		this.rID = rID;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.ptr = readInt(reader);
					break;
				}
				case 2: {
					this.rID = readInt(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.ptr !== undefined, this.rID !== undefined];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			writeInt(writer, this.ptr!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			writeInt(writer, this.rID!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.ptr === undefined && this.rID === undefined;
	}

	reset(): void {
		this.ptr = undefined;
		this.rID = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 4);
		return;
	}
	isNagoEvent(): void {}
}

// Alignment is specified as follows:
//
// 	┌─TopLeading───────────Top─────────TopTrailing─┐
// 	│                                              │
// 	│                                              │
// 	│                                              │
// 	│                                              │
// 	│                                              │
// 	│                                              │
// 	│                                              │
// 	│ Leading            Center            Trailing│
// 	│                                              │
// 	│                                              │
// 	│                                              │
// 	│                                              │
// 	│                                              │
// 	│                                              │
// 	│                                              │
// 	└BottomLeading───────Bottom──────BottomTrailing┘
//
// An empty Alignment must be interpreted as Center (="c").
export type Alignment = number;
function writeTypeHeaderAlignment(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 5);
	return;
}
// companion enum containing all defined constants for Alignment
export enum AlignmentValues {
	Center = 0,
	Top = 1,
	Bottom = 2,
	Leading = 3,
	Trailing = 4,
	TopLeading = 5,
	TopTrailing = 6,
	BottomLeading = 7,
	BottomTrailing = 8,
	Stretch = 9,
}

// Color specifies either a hex color like #rrggbb or #rrggbbaa or an internal custom color name.
export type Color = string;
function writeTypeHeaderColor(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.BYTESLICE, 6);
	return;
}

// Shadow defines a shadow effect around the border of an element. The x and y coordinates are relative to the element.
export class Shadow implements Writeable, Readable {
	// Color of the shadow.
	public color?: Color;

	// Radius for spread and blur length of the shadow.
	public radius?: Length;

	// X is the horizontal offset of the shadow relative to the element.
	public x?: Length;

	// Y is the vertical offset of the shadow relative to the element.
	public y?: Length;

	constructor(
		color: Color | undefined = undefined,
		radius: Length | undefined = undefined,
		x: Length | undefined = undefined,
		y: Length | undefined = undefined
	) {
		this.color = color;
		this.radius = radius;
		this.x = x;
		this.y = y;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.color = readString(reader);
					break;
				}
				case 2: {
					this.radius = readString(reader);
					break;
				}
				case 3: {
					this.x = readString(reader);
					break;
				}
				case 4: {
					this.y = readString(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.color !== undefined,
			this.radius !== undefined,
			this.x !== undefined,
			this.y !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.color!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.radius!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			writeString(writer, this.x!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			writeString(writer, this.y!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.color === undefined && this.radius === undefined && this.x === undefined && this.y === undefined;
	}

	reset(): void {
		this.color = undefined;
		this.radius = undefined;
		this.x = undefined;
		this.y = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 7);
		return;
	}
}

// Length is actually a complex sum type of varying content. It may contain absolute values like dp, rem or relative like 90%. It may also include css calculations or even variable names. Retrospective, we should represent each type individually, however that was not reasonable, when the requirements and hand written protocol implementations were created and now it is to late.
export type Length = string;
function writeTypeHeaderLength(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.BYTESLICE, 8);
	return;
}

// Border adds the defined border and dimension to the component. Note, that a border will change the dimension.
export class Border implements Writeable, Readable {
	public topLeftRadius?: Length;

	public topRightRadius?: Length;

	public bottomLeftRadius?: Length;

	public bottomRightRadius?: Length;

	public leftWidth?: Length;

	public topWidth?: Length;

	public rightWidth?: Length;

	public bottomWidth?: Length;

	public leftColor?: Color;

	public topColor?: Color;

	public rightColor?: Color;

	public bottomColor?: Color;

	public boxShadow?: Shadow;

	constructor(
		topLeftRadius: Length | undefined = undefined,
		topRightRadius: Length | undefined = undefined,
		bottomLeftRadius: Length | undefined = undefined,
		bottomRightRadius: Length | undefined = undefined,
		leftWidth: Length | undefined = undefined,
		topWidth: Length | undefined = undefined,
		rightWidth: Length | undefined = undefined,
		bottomWidth: Length | undefined = undefined,
		leftColor: Color | undefined = undefined,
		topColor: Color | undefined = undefined,
		rightColor: Color | undefined = undefined,
		bottomColor: Color | undefined = undefined,
		boxShadow: Shadow | undefined = undefined
	) {
		this.topLeftRadius = topLeftRadius;
		this.topRightRadius = topRightRadius;
		this.bottomLeftRadius = bottomLeftRadius;
		this.bottomRightRadius = bottomRightRadius;
		this.leftWidth = leftWidth;
		this.topWidth = topWidth;
		this.rightWidth = rightWidth;
		this.bottomWidth = bottomWidth;
		this.leftColor = leftColor;
		this.topColor = topColor;
		this.rightColor = rightColor;
		this.bottomColor = bottomColor;
		this.boxShadow = boxShadow;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.topLeftRadius = readString(reader);
					break;
				}
				case 2: {
					this.topRightRadius = readString(reader);
					break;
				}
				case 3: {
					this.bottomLeftRadius = readString(reader);
					break;
				}
				case 4: {
					this.bottomRightRadius = readString(reader);
					break;
				}
				case 5: {
					this.leftWidth = readString(reader);
					break;
				}
				case 6: {
					this.topWidth = readString(reader);
					break;
				}
				case 7: {
					this.rightWidth = readString(reader);
					break;
				}
				case 8: {
					this.bottomWidth = readString(reader);
					break;
				}
				case 9: {
					this.leftColor = readString(reader);
					break;
				}
				case 10: {
					this.topColor = readString(reader);
					break;
				}
				case 11: {
					this.rightColor = readString(reader);
					break;
				}
				case 12: {
					this.bottomColor = readString(reader);
					break;
				}
				case 13: {
					this.boxShadow = new Shadow();
					this.boxShadow.read(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.topLeftRadius !== undefined,
			this.topRightRadius !== undefined,
			this.bottomLeftRadius !== undefined,
			this.bottomRightRadius !== undefined,
			this.leftWidth !== undefined,
			this.topWidth !== undefined,
			this.rightWidth !== undefined,
			this.bottomWidth !== undefined,
			this.leftColor !== undefined,
			this.topColor !== undefined,
			this.rightColor !== undefined,
			this.bottomColor !== undefined,
			this.boxShadow !== undefined && !this.boxShadow.isZero(),
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.topLeftRadius!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.topRightRadius!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			writeString(writer, this.bottomLeftRadius!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			writeString(writer, this.bottomRightRadius!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			writeString(writer, this.leftWidth!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 6);
			writeString(writer, this.topWidth!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 7);
			writeString(writer, this.rightWidth!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 8);
			writeString(writer, this.bottomWidth!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 9);
			writeString(writer, this.leftColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 10);
			writeString(writer, this.topColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[11]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 11);
			writeString(writer, this.rightColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[12]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 12);
			writeString(writer, this.bottomColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[13]) {
			writer.writeFieldHeader(Shapes.RECORD, 13);
			this.boxShadow!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.topLeftRadius === undefined &&
			this.topRightRadius === undefined &&
			this.bottomLeftRadius === undefined &&
			this.bottomRightRadius === undefined &&
			this.leftWidth === undefined &&
			this.topWidth === undefined &&
			this.rightWidth === undefined &&
			this.bottomWidth === undefined &&
			this.leftColor === undefined &&
			this.topColor === undefined &&
			this.rightColor === undefined &&
			this.bottomColor === undefined &&
			(this.boxShadow === undefined || this.boxShadow.isZero())
		);
	}

	reset(): void {
		this.topLeftRadius = undefined;
		this.topRightRadius = undefined;
		this.bottomLeftRadius = undefined;
		this.bottomRightRadius = undefined;
		this.leftWidth = undefined;
		this.topWidth = undefined;
		this.rightWidth = undefined;
		this.bottomWidth = undefined;
		this.leftColor = undefined;
		this.topColor = undefined;
		this.rightColor = undefined;
		this.bottomColor = undefined;
		this.boxShadow = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 9);
		return;
	}
}

// Frame defines the geometrics bounds of an element.
export class Frame implements Writeable, Readable {
	public minWidth?: Length;

	public maxWidth?: Length;

	public minHeight?: Length;

	public maxHeight?: Length;

	public width?: Length;

	public height?: Length;

	constructor(
		minWidth: Length | undefined = undefined,
		maxWidth: Length | undefined = undefined,
		minHeight: Length | undefined = undefined,
		maxHeight: Length | undefined = undefined,
		width: Length | undefined = undefined,
		height: Length | undefined = undefined
	) {
		this.minWidth = minWidth;
		this.maxWidth = maxWidth;
		this.minHeight = minHeight;
		this.maxHeight = maxHeight;
		this.width = width;
		this.height = height;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.minWidth = readString(reader);
					break;
				}
				case 2: {
					this.maxWidth = readString(reader);
					break;
				}
				case 3: {
					this.minHeight = readString(reader);
					break;
				}
				case 4: {
					this.maxHeight = readString(reader);
					break;
				}
				case 5: {
					this.width = readString(reader);
					break;
				}
				case 6: {
					this.height = readString(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.minWidth !== undefined,
			this.maxWidth !== undefined,
			this.minHeight !== undefined,
			this.maxHeight !== undefined,
			this.width !== undefined,
			this.height !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.minWidth!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.maxWidth!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			writeString(writer, this.minHeight!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			writeString(writer, this.maxHeight!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			writeString(writer, this.width!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 6);
			writeString(writer, this.height!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.minWidth === undefined &&
			this.maxWidth === undefined &&
			this.minHeight === undefined &&
			this.maxHeight === undefined &&
			this.width === undefined &&
			this.height === undefined
		);
	}

	reset(): void {
		this.minWidth = undefined;
		this.maxWidth = undefined;
		this.minHeight = undefined;
		this.maxHeight = undefined;
		this.width = undefined;
		this.height = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 10);
		return;
	}
}

// Padding defines additional room within an element.
export class Padding implements Writeable, Readable {
	public top?: Length;

	public left?: Length;

	public right?: Length;

	public bottom?: Length;

	constructor(
		top: Length | undefined = undefined,
		left: Length | undefined = undefined,
		right: Length | undefined = undefined,
		bottom: Length | undefined = undefined
	) {
		this.top = top;
		this.left = left;
		this.right = right;
		this.bottom = bottom;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.top = readString(reader);
					break;
				}
				case 2: {
					this.left = readString(reader);
					break;
				}
				case 3: {
					this.right = readString(reader);
					break;
				}
				case 4: {
					this.bottom = readString(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.top !== undefined,
			this.left !== undefined,
			this.right !== undefined,
			this.bottom !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.top!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.left!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			writeString(writer, this.right!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			writeString(writer, this.bottom!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.top === undefined && this.left === undefined && this.right === undefined && this.bottom === undefined
		);
	}

	reset(): void {
		this.top = undefined;
		this.left = undefined;
		this.right = undefined;
		this.bottom = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 11);
		return;
	}
}

// AlignedComponent defines a tupel of a component and an associated alignment.
export class AlignedComponent implements Writeable, Readable {
	public component?: Component;

	public alignment?: Alignment;

	constructor(component: Component | undefined = undefined, alignment: Alignment | undefined = undefined) {
		this.component = component;
		this.alignment = alignment;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
						throw new Error(`unexpected length: ` + len);
					}
					this.component = unmarshal(reader) as Component;
					break;
				}
				case 2: {
					this.alignment = readInt(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.component !== undefined && !this.component.isZero(), this.alignment !== undefined];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			writer.writeByte(1);
			this.component.writeTypeHeader(writer);
			this.component!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			writeInt(writer, this.alignment!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (this.component === undefined || this.component.isZero()) && this.alignment === undefined;
	}

	reset(): void {
		this.component = undefined;
		this.alignment = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 12);
		return;
	}
}

// Components is polymorphic array of various concrete Component instances.
export class Components implements Writeable, Readable {
	public value: Component[];

	constructor(value: Component[] = []) {
		this.value = value;
	}

	isZero(): boolean {
		return !this.value || this.value.length === 0;
	}

	reset(): void {
		this.value = [];
	}

	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value.length); // Write the length of the array
		for (const c of this.value) {
			c.writeTypeHeader(writer); // Write the type header for each component)
			c.write(writer); // Write the component data

			//c.writeTypeHeader(writer); // Write the type header for each component
			//c.write(writer); // Write the component data
		}
	}

	read(reader: BinaryReader): void {
		const count = reader.readUvarint(); // Read the length of the array
		const values: Component[] = [];

		for (let i = 0; i < count; i++) {
			const obj = unmarshal(reader); // Read and unmarshal each component
			values.push(obj as any as Component); // Cast and add to the array
		}

		this.value = values;
	}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 13);
		return;
	}
}

// AlignedComponents is an array of layouted tupels of components.
export class AlignedComponents implements Writeable, Readable {
	public value: AlignedComponent[];

	constructor(value: AlignedComponent[] = []) {
		this.value = value;
	}

	isZero(): boolean {
		return !this.value || this.value.length === 0;
	}

	reset(): void {
		this.value = [];
	}

	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value.length); // Write the length of the array
		for (const c of this.value) {
			c.writeTypeHeader(writer); // Write the type header for each component)
			c.write(writer); // Write the component data

			//c.writeTypeHeader(writer); // Write the type header for each component
			//c.write(writer); // Write the component data
		}
	}

	read(reader: BinaryReader): void {
		const count = reader.readUvarint(); // Read the length of the array
		const values: AlignedComponent[] = [];

		for (let i = 0; i < count; i++) {
			const obj = unmarshal(reader); // Read and unmarshal each component
			values.push(obj as any as AlignedComponent); // Cast and add to the array
		}

		this.value = values;
	}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 14);
		return;
	}
}

// Checkbox represents a user interface element which spans a visible area to click or tap from the user. Use it for controls, which do not cause an immediate effect. See also [Toggle].
export class Checkbox implements Writeable, Readable, Component {
	// InputValue is where updated value of the checked states are written.
	public inputValue?: Ptr;

	public value?: Bool;

	public disabled?: Bool;

	public invisible?: Bool;

	// Id represents an optional identifier to locate this component within the view tree. It must be either empty or unique within the entire tree instance.
	public id?: Str;

	constructor(
		inputValue: Ptr | undefined = undefined,
		value: Bool | undefined = undefined,
		disabled: Bool | undefined = undefined,
		invisible: Bool | undefined = undefined,
		id: Str | undefined = undefined
	) {
		this.inputValue = inputValue;
		this.value = value;
		this.disabled = disabled;
		this.invisible = invisible;
		this.id = id;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.inputValue = readInt(reader);
					break;
				}
				case 2: {
					this.value = readBool(reader);
					break;
				}
				case 3: {
					this.disabled = readBool(reader);
					break;
				}
				case 4: {
					this.invisible = readBool(reader);
					break;
				}
				case 5: {
					this.id = readString(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.inputValue !== undefined,
			this.value !== undefined,
			this.disabled !== undefined,
			this.invisible !== undefined,
			this.id !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			writeInt(writer, this.inputValue!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			writeBool(writer, this.value!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			writeBool(writer, this.disabled!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			writeBool(writer, this.invisible!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			writeString(writer, this.id!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.inputValue === undefined &&
			this.value === undefined &&
			this.disabled === undefined &&
			this.invisible === undefined &&
			this.id === undefined
		);
	}

	reset(): void {
		this.inputValue = undefined;
		this.value = undefined;
		this.disabled = undefined;
		this.invisible = undefined;
		this.id = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 15);
		return;
	}
	isComponent(): void {}
}

// Bool represents just a user defined boolean value. This is how nprotoc works.
export type Bool = boolean;
function writeTypeHeaderBool(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 16);
	return;
}

// ErrorOccurred is used, if some unforeseen error occurred. Usually the frontend did something wrong, e.g. in a life-cycle.
export class ErrorOccurred implements Writeable, Readable, NagoEvent {
	// Message of some generic error.
	public message?: Str;

	// RID is used to trace a request-response cycle.
	public rID?: RID;

	constructor(message: Str | undefined = undefined, rID: RID | undefined = undefined) {
		this.message = message;
		this.rID = rID;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.message = readString(reader);
					break;
				}
				case 2: {
					this.rID = readInt(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.message !== undefined, this.rID !== undefined];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.message!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			writeInt(writer, this.rID!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.message === undefined && this.rID === undefined;
	}

	reset(): void {
		this.message = undefined;
		this.rID = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 17);
		return;
	}
	isNagoEvent(): void {}
}

// Locale represents a BCP47 tag like de or de_DE.
export type Locale = string;
function writeTypeHeaderLocale(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.BYTESLICE, 18);
	return;
}

// RID represents a request id and may be used by the frontend to distinguish different generations of answers.
export type FontStyle = number;
function writeTypeHeaderFontStyle(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 19);
	return;
}
// companion enum containing all defined constants for FontStyle
export enum FontStyleValues {
	// A 0 represents something which was issued without any user interaction, which means by own-initiative.
	Unsolicited = 0,
	Normal = 1,
	Italic = 2,
}

// RootViewID is a unique address for a specific view factory, e.g. my/component/path. This is typically a page. Even though this looks like an URI, it is not. Especially, there are no path parameters or query parameters.
export type RootViewID = string;
function writeTypeHeaderRootViewID(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.BYTESLICE, 20);
	return;
}

// RootViewParameters is a map of string keys and values which is given to a root view which is about to be initialized.
export class RootViewParameters implements Writeable, Readable {
	public value: Map<Str, Str>;

	constructor(value: Map<Str, Str> = new Map<Str, Str>()) {
		this.value = value;
	}

	isZero(): boolean {
		return !this.value || this.value.size === 0;
	}

	reset(): void {
		this.value = new Map<Str, Str>();
	}

	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value.size); // Write the length of the map
		for (const [key, value] of this.value) {
			// write key
			//key.writeTypeHeader(writer);
			//key.write(writer);

			writeTypeHeaderStr(writer);
			writeString(writer, key);
			// write value
			writeTypeHeaderStr(writer);
			writeString(writer, value);
		}
	}

	read(reader: BinaryReader): void {
		const count = reader.readUvarint();
		const values = new Map<Str, Str>();

		for (let i = 0; i < count; i++) {
			const key = unmarshal(reader);
			const val = unmarshal(reader);

			values.set(key as any as Str, val as any as Str);
		}

		this.value = values;
	}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 21);
		return;
	}
}

// Str represents just a user defined string value. This is how nprotoc works.
export type Str = string;
function writeTypeHeaderStr(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.BYTESLICE, 22);
	return;
}

// RootViewRenderingRequested is issued by the frontend to force a rendering at the backend.
export class RootViewRenderingRequested implements Writeable, Readable, NagoEvent {
	public rID?: RID;

	constructor(rID: RID | undefined = undefined) {
		this.rID = rID;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.rID = readInt(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.rID !== undefined];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			writeInt(writer, this.rID!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.rID === undefined;
	}

	reset(): void {
		this.rID = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 23);
		return;
	}
	isNagoEvent(): void {}
}

// The RootViewDestructionRequested event destroys the currently allocated root view. If nothing is allocated, this is a no-op.
export class RootViewDestructionRequested implements Writeable, Readable, NagoEvent {
	// RID is used to generate a new component request and is returned in the according response.
	public rID?: RID;

	constructor(rID: RID | undefined = undefined) {
		this.rID = rID;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.rID = readInt(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.rID !== undefined];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			writeInt(writer, this.rID!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.rID === undefined;
	}

	reset(): void {
		this.rID = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 24);
		return;
	}
	isNagoEvent(): void {}
}

// The RootViewInvalidated event is always generated at the backend side, if a new representation of an allocated root view shall be shown.
export class RootViewInvalidated implements Writeable, Readable, NagoEvent {
	// RID may be 0, if it is an proactive rendering.
	public rID?: RID;

	// The Root component to display.
	public root?: Component;

	constructor(rID: RID | undefined = undefined, root: Component | undefined = undefined) {
		this.rID = rID;
		this.root = root;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.rID = readInt(reader);
					break;
				}
				case 2: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
						throw new Error(`unexpected length: ` + len);
					}
					this.root = unmarshal(reader) as Component;
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.rID !== undefined, this.root !== undefined && !this.root.isZero()];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			writeInt(writer, this.rID!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 2);
			writer.writeByte(1);
			this.root.writeTypeHeader(writer);
			this.root!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.rID === undefined && (this.root === undefined || this.root.isZero());
	}

	reset(): void {
		this.rID = undefined;
		this.root = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 25);
		return;
	}
	isNagoEvent(): void {}
}

// ErrorRootViewAllocationRequired indicates, that there is no root view and it must be allocated to continue. This may happen, e.g. if the server was restarted or redeployed or a timeout occurred and the scope or root view was collected.
export class ErrorRootViewAllocationRequired implements Writeable, Readable, NagoEvent {
	// RID is used to trace a request-response cycle.
	public rID?: RID;

	constructor(rID: RID | undefined = undefined) {
		this.rID = rID;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.rID = readInt(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.rID !== undefined];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			writeInt(writer, this.rID!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.rID === undefined;
	}

	reset(): void {
		this.rID = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 26);
		return;
	}
	isNagoEvent(): void {}
}

// NewComponentRequested allocates an addressable component explicitely in the backend within its channel scope.
// Adressable components are like pages in a classic server side rendering or like routing targets in single page apps.
// We do not call them _page_ anymore, because that has wrong assocations in the web world.
// Adressable components exist independently from each other and share no lifecycle with each other.
// However, a frontend can create as many component instances it wants.
// It does not matter, if these components are of the same type, addresses or entirely different.
// The backend responds with a component invalidation event.
// Factories of addressable components are always stateless.
// However, often it does not make sense without additional parameters, e.g. because a detail view needs to know which entity has to be displayed.
export class RootViewAllocationRequested implements Writeable, Readable, NagoEvent {
	// Locale of the frontend which is assumed as the users language. This may be the webbrowser primary locale which may be derived from the operating system.
	public locale?: Locale;

	// Factory denotes the registered root view identifier.
	public factory?: RootViewID;

	// RID is used to generate a new component request and is returned in the according response.
	public rID?: RID;

	// Values contains string encoded parameters for a component. This is like query parameters in the web world.
	public values?: RootViewParameters;

	constructor(
		locale: Locale | undefined = undefined,
		factory: RootViewID | undefined = undefined,
		rID: RID | undefined = undefined,
		values: RootViewParameters | undefined = undefined
	) {
		this.locale = locale;
		this.factory = factory;
		this.rID = rID;
		this.values = values;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.locale = readString(reader);
					break;
				}
				case 2: {
					this.factory = readString(reader);
					break;
				}
				case 3: {
					this.rID = readInt(reader);
					break;
				}
				case 4: {
					this.values = new RootViewParameters();
					this.values.read(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.locale !== undefined,
			this.factory !== undefined,
			this.rID !== undefined,
			this.values !== undefined && !this.values.isZero(),
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.locale!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.factory!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			writeInt(writer, this.rID!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.ARRAY, 4);
			this.values!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.locale === undefined &&
			this.factory === undefined &&
			this.rID === undefined &&
			(this.values === undefined || this.values.isZero())
		);
	}

	reset(): void {
		this.locale = undefined;
		this.factory = undefined;
		this.rID = undefined;
		this.values = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 27);
		return;
	}
	isNagoEvent(): void {}
}

// ColorScheme represents which kind of theme shall be rendered.WindowSizeClass represents media break points of the screen which an ora application is shown.
// The definition of a size class is disjunct and for all possible sizes, exact one size class will match.
// See also https://developer.android.com/develop/ui/views/layout/window-size-classes and
// https://tailwindcss.com/docs/responsive-design.
export type WindowSizeClass = number;
function writeTypeHeaderWindowSizeClass(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 28);
	return;
}
// companion enum containing all defined constants for WindowSizeClass
export enum WindowSizeClassValues {
	// SizeClassSmall are devices below 640 dp screen width.
	SizeClassSmall = 0,
	// SizeClassMedium are devices below 768dp screen width.
	SizeClassMedium = 1,
	// SizeClassLarge are devices below 1024dp screen width.
	SizeClassLarge = 2,
	// SizeClassXL are devices below 1280dp screen width.
	SizeClassXL = 3,
	// SizeClass2XL are devices below 1536dp screen width.
	SizeClass2XL = 4,
}

// A ScopeConfigurationRequested event can be issued at any time.ConfigurationRequested is issued by the frontend to get the applications general configuration.
// A backend developer has potentially defined a lot of configuration details about the application.
// For example, there may be a color theme, customized icons, image resources, an application name and the available set of navigations, launch intents or other meta information.
// It is expected, that this only happens once during initialization of the frontend process.
export class ScopeConfigurationChangeRequested implements Writeable, Readable, NagoEvent {
	// RID is used to generate a new component request and is returned in the according response.
	public rID?: RID;

	public acceptLanguage?: Locale;

	public windowInfo?: WindowInfo;

	constructor(
		rID: RID | undefined = undefined,
		acceptLanguage: Locale | undefined = undefined,
		windowInfo: WindowInfo | undefined = undefined
	) {
		this.rID = rID;
		this.acceptLanguage = acceptLanguage;
		this.windowInfo = windowInfo;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.rID = readInt(reader);
					break;
				}
				case 2: {
					this.acceptLanguage = readString(reader);
					break;
				}
				case 3: {
					this.windowInfo = new WindowInfo();
					this.windowInfo.read(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.rID !== undefined,
			this.acceptLanguage !== undefined,
			this.windowInfo !== undefined && !this.windowInfo.isZero(),
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			writeInt(writer, this.rID!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.acceptLanguage!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.RECORD, 3);
			this.windowInfo!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.rID === undefined &&
			this.acceptLanguage === undefined &&
			(this.windowInfo === undefined || this.windowInfo.isZero())
		);
	}

	reset(): void {
		this.rID = undefined;
		this.acceptLanguage = undefined;
		this.windowInfo = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 29);
		return;
	}
	isNagoEvent(): void {}
}

// ColorScheme represents which kind of theme shall be rendered.
export type ColorScheme = number;
function writeTypeHeaderColorScheme(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 30);
	return;
}
// companion enum containing all defined constants for ColorScheme
export enum ColorSchemeValues {
	// Light represents the light theme color mode.
	Light = 0,
	// Dark represents the dark theme color mode.
	Dark = 1,
}

// WindowInfo describes the area into which the frontend renders the ora view tree.
// A user can simply change the layout of the screen, e.g. by rotation the smartphone or
// changing the size of a browser window.
export class WindowInfo implements Writeable, Readable {
	public width?: DP;

	public height?: DP;

	public density?: Density;

	public sizeClass?: WindowSizeClass;

	// ColorScheme which the frontend wants to pick. This may reduce graphical glitches, if the backend creates images or webview resources for the frontend.
	public colorScheme?: ColorScheme;

	public userAgent?: Str;

	constructor(
		width: DP | undefined = undefined,
		height: DP | undefined = undefined,
		density: Density | undefined = undefined,
		sizeClass: WindowSizeClass | undefined = undefined,
		colorScheme: ColorScheme | undefined = undefined,
		userAgent: Str | undefined = undefined
	) {
		this.width = width;
		this.height = height;
		this.density = density;
		this.sizeClass = sizeClass;
		this.colorScheme = colorScheme;
		this.userAgent = userAgent;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.width = readFloat(reader);
					break;
				}
				case 2: {
					this.height = readFloat(reader);
					break;
				}
				case 3: {
					this.density = readFloat(reader);
					break;
				}
				case 4: {
					this.sizeClass = readInt(reader);
					break;
				}
				case 5: {
					this.colorScheme = readInt(reader);
					break;
				}
				case 6: {
					this.userAgent = readString(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.width !== undefined,
			this.height !== undefined,
			this.density !== undefined,
			this.sizeClass !== undefined,
			this.colorScheme !== undefined,
			this.userAgent !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.F64, 1);
			writeFloat(writer, this.width!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.F64, 2);
			writeFloat(writer, this.height!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.F64, 3);
			writeFloat(writer, this.density!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			writeInt(writer, this.sizeClass!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.UVARINT, 5);
			writeInt(writer, this.colorScheme!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 6);
			writeString(writer, this.userAgent!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.width === undefined &&
			this.height === undefined &&
			this.density === undefined &&
			this.sizeClass === undefined &&
			this.colorScheme === undefined &&
			this.userAgent === undefined
		);
	}

	reset(): void {
		this.width = undefined;
		this.height = undefined;
		this.density = undefined;
		this.sizeClass = undefined;
		this.colorScheme = undefined;
		this.userAgent = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 31);
		return;
	}
}

export type DP = number;
function writeTypeHeaderDP(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.F64, 32);
	return;
}

export type Density = number;
function writeTypeHeaderDensity(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.F64, 33);
	return;
}

// A ConfigurationDefined event is the response to a [ScopeConfigurationChangeRequested] event.
// According to the locale request, string and svg resources can be localized by the backend.
// The returned locale is the actually picked locale from the requested locale query string.
export class ScopeConfigurationChanged implements Writeable, Readable, NagoEvent {
	public applicationID?: Str;

	public applicationName?: Str;

	public applicationVersion?: Str;

	public availableLocales?: Locales;

	public appIcon?: URI;

	public activeLocale?: Locale;

	public themes?: Themes;

	public rID?: RID;

	public fonts?: Fonts;

	constructor(
		applicationID: Str | undefined = undefined,
		applicationName: Str | undefined = undefined,
		applicationVersion: Str | undefined = undefined,
		availableLocales: Locales | undefined = undefined,
		appIcon: URI | undefined = undefined,
		activeLocale: Locale | undefined = undefined,
		themes: Themes | undefined = undefined,
		rID: RID | undefined = undefined,
		fonts: Fonts | undefined = undefined
	) {
		this.applicationID = applicationID;
		this.applicationName = applicationName;
		this.applicationVersion = applicationVersion;
		this.availableLocales = availableLocales;
		this.appIcon = appIcon;
		this.activeLocale = activeLocale;
		this.themes = themes;
		this.rID = rID;
		this.fonts = fonts;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.applicationID = readString(reader);
					break;
				}
				case 2: {
					this.applicationName = readString(reader);
					break;
				}
				case 3: {
					this.applicationVersion = readString(reader);
					break;
				}
				case 4: {
					this.availableLocales = new Locales();
					this.availableLocales.read(reader);
					break;
				}
				case 5: {
					this.appIcon = readString(reader);
					break;
				}
				case 6: {
					this.activeLocale = readString(reader);
					break;
				}
				case 7: {
					this.themes = new Themes();
					this.themes.read(reader);
					break;
				}
				case 8: {
					this.rID = readInt(reader);
					break;
				}
				case 9: {
					this.fonts = new Fonts();
					this.fonts.read(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.applicationID !== undefined,
			this.applicationName !== undefined,
			this.applicationVersion !== undefined,
			this.availableLocales !== undefined && !this.availableLocales.isZero(),
			this.appIcon !== undefined,
			this.activeLocale !== undefined,
			this.themes !== undefined && !this.themes.isZero(),
			this.rID !== undefined,
			this.fonts !== undefined && !this.fonts.isZero(),
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.applicationID!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.applicationName!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			writeString(writer, this.applicationVersion!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.ARRAY, 4);
			this.availableLocales!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			writeString(writer, this.appIcon!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 6);
			writeString(writer, this.activeLocale!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.RECORD, 7);
			this.themes!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.UVARINT, 8);
			writeInt(writer, this.rID!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.RECORD, 9);
			this.fonts!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.applicationID === undefined &&
			this.applicationName === undefined &&
			this.applicationVersion === undefined &&
			(this.availableLocales === undefined || this.availableLocales.isZero()) &&
			this.appIcon === undefined &&
			this.activeLocale === undefined &&
			(this.themes === undefined || this.themes.isZero()) &&
			this.rID === undefined &&
			(this.fonts === undefined || this.fonts.isZero())
		);
	}

	reset(): void {
		this.applicationID = undefined;
		this.applicationName = undefined;
		this.applicationVersion = undefined;
		this.availableLocales = undefined;
		this.appIcon = undefined;
		this.activeLocale = undefined;
		this.themes = undefined;
		this.rID = undefined;
		this.fonts = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 34);
		return;
	}
	isNagoEvent(): void {}
}

// Locales is just a bunch of locales.
export class Locales implements Writeable, Readable {
	public value: Locale[];

	constructor(value: Locale[] = []) {
		this.value = value;
	}

	isZero(): boolean {
		return !this.value || this.value.length === 0;
	}

	reset(): void {
		this.value = [];
	}

	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value.length); // Write the length of the array
		for (const c of this.value) {
			writeTypeHeaderLocale(writer);
			writeString(writer, c);

			//c.writeTypeHeader(writer); // Write the type header for each component
			//c.write(writer); // Write the component data
		}
	}

	read(reader: BinaryReader): void {
		const count = reader.readUvarint(); // Read the length of the array
		const values: Locale[] = [];

		for (let i = 0; i < count; i++) {
			const obj = unmarshal(reader); // Read and unmarshal each component
			values.push(obj as any as Locale); // Cast and add to the array
		}

		this.value = values;
	}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 35);
		return;
	}
}

// URI is just a string which looks like an URI or URL
export type URI = string;
function writeTypeHeaderURI(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.BYTESLICE, 36);
	return;
}

// NamespaceName refers to a component or views namespace declaration. Besides the universe space, this is almost relevant for the backend, however it defines variables at the frontend, thus it may open some optimizations.
export type NamespaceName = string;
function writeTypeHeaderNamespaceName(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.BYTESLICE, 37);
	return;
}

// NamedColors represents a map of names with associated color values.
export class NamedColors implements Writeable, Readable {
	public value: Map<Str, Color>;

	constructor(value: Map<Str, Color> = new Map<Str, Color>()) {
		this.value = value;
	}

	isZero(): boolean {
		return !this.value || this.value.size === 0;
	}

	reset(): void {
		this.value = new Map<Str, Color>();
	}

	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value.size); // Write the length of the map
		for (const [key, value] of this.value) {
			// write key
			//key.writeTypeHeader(writer);
			//key.write(writer);

			writeTypeHeaderStr(writer);
			writeString(writer, key);
			// write value
			writeTypeHeaderColor(writer);
			writeString(writer, value);
		}
	}

	read(reader: BinaryReader): void {
		const count = reader.readUvarint();
		const values = new Map<Str, Color>();

		for (let i = 0; i < count; i++) {
			const key = unmarshal(reader);
			const val = unmarshal(reader);

			values.set(key as any as Str, val as any as Color);
		}

		this.value = values;
	}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 38);
		return;
	}
}

// A Theme aggregates colors (for distinct) namespaces and lengths. Usually, this represents the light or dark mode.
export class Theme implements Writeable, Readable {
	public colors?: NamespacedColors;

	public lengths?: NamedLengths;

	constructor(colors: NamespacedColors | undefined = undefined, lengths: NamedLengths | undefined = undefined) {
		this.colors = colors;
		this.lengths = lengths;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.colors = new NamespacedColors();
					this.colors.read(reader);
					break;
				}
				case 2: {
					this.lengths = new NamedLengths();
					this.lengths.read(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.colors !== undefined && !this.colors.isZero(),
			this.lengths !== undefined && !this.lengths.isZero(),
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			this.colors!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.ARRAY, 2);
			this.lengths!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			(this.colors === undefined || this.colors.isZero()) && (this.lengths === undefined || this.lengths.isZero())
		);
	}

	reset(): void {
		this.colors = undefined;
		this.lengths = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 39);
		return;
	}
}

// NamespacedColors represents a map of namespaces with associated color values.
export class NamespacedColors implements Writeable, Readable {
	public value: Map<NamespaceName, NamedColors>;

	constructor(value: Map<NamespaceName, NamedColors> = new Map<NamespaceName, NamedColors>()) {
		this.value = value;
	}

	isZero(): boolean {
		return !this.value || this.value.size === 0;
	}

	reset(): void {
		this.value = new Map<NamespaceName, NamedColors>();
	}

	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value.size); // Write the length of the map
		for (const [key, value] of this.value) {
			// write key
			//key.writeTypeHeader(writer);
			//key.write(writer);

			writeTypeHeaderNamespaceName(writer);
			writeString(writer, key);
			// write value

			value.writeTypeHeader(writer);
			value.write(writer);
		}
	}

	read(reader: BinaryReader): void {
		const count = reader.readUvarint();
		const values = new Map<NamespaceName, NamedColors>();

		for (let i = 0; i < count; i++) {
			const key = unmarshal(reader);
			const val = unmarshal(reader);

			values.set(key as any as NamespaceName, val as any as NamedColors);
		}

		this.value = values;
	}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 40);
		return;
	}
}

// NamedLengths represents a map of names with associated length values.
export class NamedLengths implements Writeable, Readable {
	public value: Map<Str, Length>;

	constructor(value: Map<Str, Length> = new Map<Str, Length>()) {
		this.value = value;
	}

	isZero(): boolean {
		return !this.value || this.value.size === 0;
	}

	reset(): void {
		this.value = new Map<Str, Length>();
	}

	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value.size); // Write the length of the map
		for (const [key, value] of this.value) {
			// write key
			//key.writeTypeHeader(writer);
			//key.write(writer);

			writeTypeHeaderStr(writer);
			writeString(writer, key);
			// write value
			writeTypeHeaderLength(writer);
			writeString(writer, value);
		}
	}

	read(reader: BinaryReader): void {
		const count = reader.readUvarint();
		const values = new Map<Str, Length>();

		for (let i = 0; i < count; i++) {
			const key = unmarshal(reader);
			const val = unmarshal(reader);

			values.set(key as any as Str, val as any as Length);
		}

		this.value = values;
	}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 41);
		return;
	}
}

// Themes represents light or dark mode colors.
export class Themes implements Writeable, Readable {
	public light?: Theme;

	public dark?: Theme;

	constructor(light: Theme | undefined = undefined, dark: Theme | undefined = undefined) {
		this.light = light;
		this.dark = dark;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.light = new Theme();
					this.light.read(reader);
					break;
				}
				case 2: {
					this.dark = new Theme();
					this.dark.read(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.light !== undefined && !this.light.isZero(),
			this.dark !== undefined && !this.dark.isZero(),
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.RECORD, 1);
			this.light!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.RECORD, 2);
			this.dark!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (this.light === undefined || this.light.isZero()) && (this.dark === undefined || this.dark.isZero());
	}

	reset(): void {
		this.light = undefined;
		this.dark = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 42);
		return;
	}
}

export type DatePickerStyle = number;
function writeTypeHeaderDatePickerStyle(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 43);
	return;
}
// companion enum containing all defined constants for DatePickerStyle
export enum DatePickerStyleValues {
	DatePickerSingleDate = 0,
	DatePickerDateRange = 1,
}

// Day represents a day in month in the range 1-31.
export type Day = number;
function writeTypeHeaderDay(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 44);
	return;
}

// Date represents a location-free representation of a day/month/year tuple.
export class DateData implements Writeable, Readable {
	public day?: Day;

	public month?: Month;

	public year?: Year;

	constructor(
		day: Day | undefined = undefined,
		month: Month | undefined = undefined,
		year: Year | undefined = undefined
	) {
		this.day = day;
		this.month = month;
		this.year = year;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.day = readInt(reader);
					break;
				}
				case 2: {
					this.month = readInt(reader);
					break;
				}
				case 3: {
					this.year = readInt(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.day !== undefined, this.month !== undefined, this.year !== undefined];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			writeInt(writer, this.day!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			writeInt(writer, this.month!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			writeInt(writer, this.year!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.day === undefined && this.month === undefined && this.year === undefined;
	}

	reset(): void {
		this.day = undefined;
		this.month = undefined;
		this.year = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 45);
		return;
	}
}

// Month represents a month in the range 1-12.
export type Month = number;
function writeTypeHeaderMonth(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 46);
	return;
}

// Year represents a year in the gregorian calendar.
export type Year = number;
function writeTypeHeaderYear(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 47);
	return;
}

export class DatePicker implements Writeable, Readable, Component {
	public label?: Str;

	public supportingText?: Str;

	// ErrorText is shown instead of SupportingText, even if they are (today) independent
	public errorText?: Str;

	// Style determines if the picker shall use the range or single mode. Default is single selection
	public style?: DatePickerStyle;

	// Value is the initial single value or start value of the picker.
	public value?: DateData;

	// InputValue is the picked single value or end value of the picker.
	public inputValue?: Ptr;

	// EndValue is the initial end value of the picker.
	public endValue?: DateData;

	// EndInputValue is the picked end value of the picker.
	public endInputValue?: Ptr;

	public frame?: Frame;

	public invisible?: Bool;

	public disabled?: Bool;

	constructor(
		label: Str | undefined = undefined,
		supportingText: Str | undefined = undefined,
		errorText: Str | undefined = undefined,
		style: DatePickerStyle | undefined = undefined,
		value: DateData | undefined = undefined,
		inputValue: Ptr | undefined = undefined,
		endValue: DateData | undefined = undefined,
		endInputValue: Ptr | undefined = undefined,
		frame: Frame | undefined = undefined,
		invisible: Bool | undefined = undefined,
		disabled: Bool | undefined = undefined
	) {
		this.label = label;
		this.supportingText = supportingText;
		this.errorText = errorText;
		this.style = style;
		this.value = value;
		this.inputValue = inputValue;
		this.endValue = endValue;
		this.endInputValue = endInputValue;
		this.frame = frame;
		this.invisible = invisible;
		this.disabled = disabled;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.label = readString(reader);
					break;
				}
				case 2: {
					this.supportingText = readString(reader);
					break;
				}
				case 3: {
					this.errorText = readString(reader);
					break;
				}
				case 4: {
					this.style = readInt(reader);
					break;
				}
				case 5: {
					this.value = new DateData();
					this.value.read(reader);
					break;
				}
				case 6: {
					this.inputValue = readInt(reader);
					break;
				}
				case 7: {
					this.endValue = new DateData();
					this.endValue.read(reader);
					break;
				}
				case 8: {
					this.endInputValue = readInt(reader);
					break;
				}
				case 9: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				case 10: {
					this.invisible = readBool(reader);
					break;
				}
				case 11: {
					this.disabled = readBool(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.label !== undefined,
			this.supportingText !== undefined,
			this.errorText !== undefined,
			this.style !== undefined,
			this.value !== undefined && !this.value.isZero(),
			this.inputValue !== undefined,
			this.endValue !== undefined && !this.endValue.isZero(),
			this.endInputValue !== undefined,
			this.frame !== undefined && !this.frame.isZero(),
			this.invisible !== undefined,
			this.disabled !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.label!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.supportingText!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			writeString(writer, this.errorText!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			writeInt(writer, this.style!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.RECORD, 5);
			this.value!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.UVARINT, 6);
			writeInt(writer, this.inputValue!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.RECORD, 7);
			this.endValue!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.UVARINT, 8);
			writeInt(writer, this.endInputValue!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.RECORD, 9);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.UVARINT, 10);
			writeBool(writer, this.invisible!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[11]) {
			writer.writeFieldHeader(Shapes.UVARINT, 11);
			writeBool(writer, this.disabled!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.label === undefined &&
			this.supportingText === undefined &&
			this.errorText === undefined &&
			this.style === undefined &&
			(this.value === undefined || this.value.isZero()) &&
			this.inputValue === undefined &&
			(this.endValue === undefined || this.endValue.isZero()) &&
			this.endInputValue === undefined &&
			(this.frame === undefined || this.frame.isZero()) &&
			this.invisible === undefined &&
			this.disabled === undefined
		);
	}

	reset(): void {
		this.label = undefined;
		this.supportingText = undefined;
		this.errorText = undefined;
		this.style = undefined;
		this.value = undefined;
		this.inputValue = undefined;
		this.endValue = undefined;
		this.endInputValue = undefined;
		this.frame = undefined;
		this.invisible = undefined;
		this.disabled = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 48);
		return;
	}
	isComponent(): void {}
}

export class Divider implements Writeable, Readable, Component {
	public frame?: Frame;

	public border?: Border;

	public padding?: Padding;

	constructor(
		frame: Frame | undefined = undefined,
		border: Border | undefined = undefined,
		padding: Padding | undefined = undefined
	) {
		this.frame = frame;
		this.border = border;
		this.padding = padding;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				case 2: {
					this.border = new Border();
					this.border.read(reader);
					break;
				}
				case 3: {
					this.padding = new Padding();
					this.padding.read(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.frame !== undefined && !this.frame.isZero(),
			this.border !== undefined && !this.border.isZero(),
			this.padding !== undefined && !this.padding.isZero(),
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.RECORD, 1);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.RECORD, 2);
			this.border!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.RECORD, 3);
			this.padding!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			(this.frame === undefined || this.frame.isZero()) &&
			(this.border === undefined || this.border.isZero()) &&
			(this.padding === undefined || this.padding.isZero())
		);
	}

	reset(): void {
		this.frame = undefined;
		this.border = undefined;
		this.padding = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 49);
		return;
	}
	isComponent(): void {}
}

export type RID = number;
function writeTypeHeaderRID(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 50);
	return;
}
// companion enum containing all defined constants for RID
export enum RIDValues {
	NormalFontStyle = 0,
	ItalicFontStyle = 1,
}

export type FontWeight = number;
function writeTypeHeaderFontWeight(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 51);
	return;
}
// companion enum containing all defined constants for FontWeight
export enum FontWeightValues {
	NormalFontWeight = 400,
	BoldFontWeight = 700,
}

export class Font implements Writeable, Readable {
	// Name of the font or family name as fallback. Extra fallback declarations are unspecified and must be comma separated.
	public name?: Str;

	public size?: Length;

	public style?: FontStyle;

	public weight?: FontWeight;

	constructor(
		name: Str | undefined = undefined,
		size: Length | undefined = undefined,
		style: FontStyle | undefined = undefined,
		weight: FontWeight | undefined = undefined
	) {
		this.name = name;
		this.size = size;
		this.style = style;
		this.weight = weight;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.name = readString(reader);
					break;
				}
				case 2: {
					this.size = readString(reader);
					break;
				}
				case 3: {
					this.style = readInt(reader);
					break;
				}
				case 4: {
					this.weight = readInt(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.name !== undefined,
			this.size !== undefined,
			this.style !== undefined,
			this.weight !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.name!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.size!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			writeInt(writer, this.style!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			writeInt(writer, this.weight!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.name === undefined && this.size === undefined && this.style === undefined && this.weight === undefined
		);
	}

	reset(): void {
		this.name = undefined;
		this.size = undefined;
		this.style = undefined;
		this.weight = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 52);
		return;
	}
}

// A Grid must support up to 12 Columns and a reasonable "unlimited" amount of rows.
export class Grid implements Writeable, Readable, Component {
	public cells?: GridCells;

	public rows?: Uint;

	public columns?: Uint;

	public rowGap?: Length;

	public colGap?: Length;

	public frame?: Frame;

	public backgroundColor?: Color;

	public padding?: Padding;

	public border?: Border;

	public accessibilityLabel?: Str;

	public font?: Font;

	public colWidths?: Lengths;

	public invisible?: Bool;

	constructor(
		cells: GridCells | undefined = undefined,
		rows: Uint | undefined = undefined,
		columns: Uint | undefined = undefined,
		rowGap: Length | undefined = undefined,
		colGap: Length | undefined = undefined,
		frame: Frame | undefined = undefined,
		backgroundColor: Color | undefined = undefined,
		padding: Padding | undefined = undefined,
		border: Border | undefined = undefined,
		accessibilityLabel: Str | undefined = undefined,
		font: Font | undefined = undefined,
		colWidths: Lengths | undefined = undefined,
		invisible: Bool | undefined = undefined
	) {
		this.cells = cells;
		this.rows = rows;
		this.columns = columns;
		this.rowGap = rowGap;
		this.colGap = colGap;
		this.frame = frame;
		this.backgroundColor = backgroundColor;
		this.padding = padding;
		this.border = border;
		this.accessibilityLabel = accessibilityLabel;
		this.font = font;
		this.colWidths = colWidths;
		this.invisible = invisible;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.cells = new GridCells();
					this.cells.read(reader);
					break;
				}
				case 2: {
					this.rows = readInt(reader);
					break;
				}
				case 3: {
					this.columns = readInt(reader);
					break;
				}
				case 4: {
					this.rowGap = readString(reader);
					break;
				}
				case 5: {
					this.colGap = readString(reader);
					break;
				}
				case 6: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				case 7: {
					this.backgroundColor = readString(reader);
					break;
				}
				case 8: {
					this.padding = new Padding();
					this.padding.read(reader);
					break;
				}
				case 9: {
					this.border = new Border();
					this.border.read(reader);
					break;
				}
				case 10: {
					this.accessibilityLabel = readString(reader);
					break;
				}
				case 11: {
					this.font = new Font();
					this.font.read(reader);
					break;
				}
				case 12: {
					this.colWidths = new Lengths();
					this.colWidths.read(reader);
					break;
				}
				case 13: {
					this.invisible = readBool(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.cells !== undefined && !this.cells.isZero(),
			this.rows !== undefined,
			this.columns !== undefined,
			this.rowGap !== undefined,
			this.colGap !== undefined,
			this.frame !== undefined && !this.frame.isZero(),
			this.backgroundColor !== undefined,
			this.padding !== undefined && !this.padding.isZero(),
			this.border !== undefined && !this.border.isZero(),
			this.accessibilityLabel !== undefined,
			this.font !== undefined && !this.font.isZero(),
			this.colWidths !== undefined && !this.colWidths.isZero(),
			this.invisible !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			this.cells!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			writeInt(writer, this.rows!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			writeInt(writer, this.columns!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			writeString(writer, this.rowGap!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			writeString(writer, this.colGap!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.RECORD, 6);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 7);
			writeString(writer, this.backgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.RECORD, 8);
			this.padding!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.RECORD, 9);
			this.border!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 10);
			writeString(writer, this.accessibilityLabel!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[11]) {
			writer.writeFieldHeader(Shapes.RECORD, 11);
			this.font!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[12]) {
			writer.writeFieldHeader(Shapes.ARRAY, 12);
			this.colWidths!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[13]) {
			writer.writeFieldHeader(Shapes.UVARINT, 13);
			writeBool(writer, this.invisible!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			(this.cells === undefined || this.cells.isZero()) &&
			this.rows === undefined &&
			this.columns === undefined &&
			this.rowGap === undefined &&
			this.colGap === undefined &&
			(this.frame === undefined || this.frame.isZero()) &&
			this.backgroundColor === undefined &&
			(this.padding === undefined || this.padding.isZero()) &&
			(this.border === undefined || this.border.isZero()) &&
			this.accessibilityLabel === undefined &&
			(this.font === undefined || this.font.isZero()) &&
			(this.colWidths === undefined || this.colWidths.isZero()) &&
			this.invisible === undefined
		);
	}

	reset(): void {
		this.cells = undefined;
		this.rows = undefined;
		this.columns = undefined;
		this.rowGap = undefined;
		this.colGap = undefined;
		this.frame = undefined;
		this.backgroundColor = undefined;
		this.padding = undefined;
		this.border = undefined;
		this.accessibilityLabel = undefined;
		this.font = undefined;
		this.colWidths = undefined;
		this.invisible = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 53);
		return;
	}
	isComponent(): void {}
}

// Uint represents just a user defined unsigned integer value. This is how nprotoc works.
export type Uint = number;
function writeTypeHeaderUint(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 54);
	return;
}

// GridCells is just a bunch of GridCells.
export class GridCells implements Writeable, Readable {
	public value: GridCell[];

	constructor(value: GridCell[] = []) {
		this.value = value;
	}

	isZero(): boolean {
		return !this.value || this.value.length === 0;
	}

	reset(): void {
		this.value = [];
	}

	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value.length); // Write the length of the array
		for (const c of this.value) {
			c.writeTypeHeader(writer); // Write the type header for each component)
			c.write(writer); // Write the component data

			//c.writeTypeHeader(writer); // Write the type header for each component
			//c.write(writer); // Write the component data
		}
	}

	read(reader: BinaryReader): void {
		const count = reader.readUvarint(); // Read the length of the array
		const values: GridCell[] = [];

		for (let i = 0; i < count; i++) {
			const obj = unmarshal(reader); // Read and unmarshal each component
			values.push(obj as any as GridCell); // Cast and add to the array
		}

		this.value = values;
	}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 55);
		return;
	}
}

// Lengths is just a bunch of length values.
export class Lengths implements Writeable, Readable {
	public value: Length[];

	constructor(value: Length[] = []) {
		this.value = value;
	}

	isZero(): boolean {
		return !this.value || this.value.length === 0;
	}

	reset(): void {
		this.value = [];
	}

	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value.length); // Write the length of the array
		for (const c of this.value) {
			writeTypeHeaderLength(writer);
			writeString(writer, c);

			//c.writeTypeHeader(writer); // Write the type header for each component
			//c.write(writer); // Write the component data
		}
	}

	read(reader: BinaryReader): void {
		const count = reader.readUvarint(); // Read the length of the array
		const values: Length[] = [];

		for (let i = 0; i < count; i++) {
			const obj = unmarshal(reader); // Read and unmarshal each component
			values.push(obj as any as Length); // Cast and add to the array
		}

		this.value = values;
	}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 56);
		return;
	}
}

// GridCell is undefined, if explicit row start/col start etc. is set and span values.
export class GridCell implements Writeable, Readable {
	public body?: Component;

	public colStart?: Uint;

	public colEnd?: Uint;

	public rowStart?: Uint;

	public rowEnd?: Uint;

	public colSpan?: Uint;

	public rowSpan?: Uint;

	public padding?: Padding;

	public alignment?: Alignment;

	public backgroundColor?: Color;

	constructor(
		body: Component | undefined = undefined,
		colStart: Uint | undefined = undefined,
		colEnd: Uint | undefined = undefined,
		rowStart: Uint | undefined = undefined,
		rowEnd: Uint | undefined = undefined,
		colSpan: Uint | undefined = undefined,
		rowSpan: Uint | undefined = undefined,
		padding: Padding | undefined = undefined,
		alignment: Alignment | undefined = undefined,
		backgroundColor: Color | undefined = undefined
	) {
		this.body = body;
		this.colStart = colStart;
		this.colEnd = colEnd;
		this.rowStart = rowStart;
		this.rowEnd = rowEnd;
		this.colSpan = colSpan;
		this.rowSpan = rowSpan;
		this.padding = padding;
		this.alignment = alignment;
		this.backgroundColor = backgroundColor;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
						throw new Error(`unexpected length: ` + len);
					}
					this.body = unmarshal(reader) as Component;
					break;
				}
				case 2: {
					this.colStart = readInt(reader);
					break;
				}
				case 3: {
					this.colEnd = readInt(reader);
					break;
				}
				case 4: {
					this.rowStart = readInt(reader);
					break;
				}
				case 5: {
					this.rowEnd = readInt(reader);
					break;
				}
				case 6: {
					this.colSpan = readInt(reader);
					break;
				}
				case 7: {
					this.rowSpan = readInt(reader);
					break;
				}
				case 8: {
					this.padding = new Padding();
					this.padding.read(reader);
					break;
				}
				case 9: {
					this.alignment = readInt(reader);
					break;
				}
				case 10: {
					this.backgroundColor = readString(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.body !== undefined && !this.body.isZero(),
			this.colStart !== undefined,
			this.colEnd !== undefined,
			this.rowStart !== undefined,
			this.rowEnd !== undefined,
			this.colSpan !== undefined,
			this.rowSpan !== undefined,
			this.padding !== undefined && !this.padding.isZero(),
			this.alignment !== undefined,
			this.backgroundColor !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			writer.writeByte(1);
			this.body.writeTypeHeader(writer);
			this.body!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			writeInt(writer, this.colStart!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			writeInt(writer, this.colEnd!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			writeInt(writer, this.rowStart!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.UVARINT, 5);
			writeInt(writer, this.rowEnd!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.UVARINT, 6);
			writeInt(writer, this.colSpan!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.UVARINT, 7);
			writeInt(writer, this.rowSpan!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.RECORD, 8);
			this.padding!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.UVARINT, 9);
			writeInt(writer, this.alignment!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 10);
			writeString(writer, this.backgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			(this.body === undefined || this.body.isZero()) &&
			this.colStart === undefined &&
			this.colEnd === undefined &&
			this.rowStart === undefined &&
			this.rowEnd === undefined &&
			this.colSpan === undefined &&
			this.rowSpan === undefined &&
			(this.padding === undefined || this.padding.isZero()) &&
			this.alignment === undefined &&
			this.backgroundColor === undefined
		);
	}

	reset(): void {
		this.body = undefined;
		this.colStart = undefined;
		this.colEnd = undefined;
		this.rowStart = undefined;
		this.rowEnd = undefined;
		this.colSpan = undefined;
		this.rowSpan = undefined;
		this.padding = undefined;
		this.alignment = undefined;
		this.backgroundColor = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 57);
		return;
	}
}

// An HStack aligns children elements in a horizontal row.
//  - the intrinsic component dimensions are the sum of all sizes of the contained children
//  - the parent can define a custom width and height
//  - if the container is larger than the contained views, it must center vertical or horizontal
//  - the inner gap between components should be around 2dp (this decides the backend)
export class HStack implements Writeable, Readable, Component {
	public children?: Components;

	public gap?: Length;

	public frame?: Frame;

	// Zero value of Alignment is Center (=c) must be applied.
	public alignment?: Alignment;

	public backgroundColor?: Color;

	public padding?: Padding;

	// see also https://www.w3.org/WAI/tutorials/images/decision-tree/
	public accessibilityLabel?: Str;

	public border?: Border;

	public font?: Font;

	public action?: Ptr;

	public hoveredBackgroundColor?: Color;

	public pressedBackgroundColor?: Color;

	public focusedBackgroundColor?: Color;

	public hoveredBorder?: Border;

	public pressedBorder?: Border;

	public focusedBorder?: Border;

	public wrap?: Bool;

	public stylePreset?: StylePreset;

	public position?: Position;

	public disabled?: Bool;

	public invisible?: Bool;

	// Id represents an optional identifier to locate this component within the view tree. It must be either empty or unique within the entire tree instance.
	public id?: Str;

	public noClip?: Bool;

	constructor(
		children: Components | undefined = undefined,
		gap: Length | undefined = undefined,
		frame: Frame | undefined = undefined,
		alignment: Alignment | undefined = undefined,
		backgroundColor: Color | undefined = undefined,
		padding: Padding | undefined = undefined,
		accessibilityLabel: Str | undefined = undefined,
		border: Border | undefined = undefined,
		font: Font | undefined = undefined,
		action: Ptr | undefined = undefined,
		hoveredBackgroundColor: Color | undefined = undefined,
		pressedBackgroundColor: Color | undefined = undefined,
		focusedBackgroundColor: Color | undefined = undefined,
		hoveredBorder: Border | undefined = undefined,
		pressedBorder: Border | undefined = undefined,
		focusedBorder: Border | undefined = undefined,
		wrap: Bool | undefined = undefined,
		stylePreset: StylePreset | undefined = undefined,
		position: Position | undefined = undefined,
		disabled: Bool | undefined = undefined,
		invisible: Bool | undefined = undefined,
		id: Str | undefined = undefined,
		noClip: Bool | undefined = undefined
	) {
		this.children = children;
		this.gap = gap;
		this.frame = frame;
		this.alignment = alignment;
		this.backgroundColor = backgroundColor;
		this.padding = padding;
		this.accessibilityLabel = accessibilityLabel;
		this.border = border;
		this.font = font;
		this.action = action;
		this.hoveredBackgroundColor = hoveredBackgroundColor;
		this.pressedBackgroundColor = pressedBackgroundColor;
		this.focusedBackgroundColor = focusedBackgroundColor;
		this.hoveredBorder = hoveredBorder;
		this.pressedBorder = pressedBorder;
		this.focusedBorder = focusedBorder;
		this.wrap = wrap;
		this.stylePreset = stylePreset;
		this.position = position;
		this.disabled = disabled;
		this.invisible = invisible;
		this.id = id;
		this.noClip = noClip;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.children = new Components();
					this.children.read(reader);
					break;
				}
				case 2: {
					this.gap = readString(reader);
					break;
				}
				case 3: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				case 4: {
					this.alignment = readInt(reader);
					break;
				}
				case 5: {
					this.backgroundColor = readString(reader);
					break;
				}
				case 6: {
					this.padding = new Padding();
					this.padding.read(reader);
					break;
				}
				case 7: {
					this.accessibilityLabel = readString(reader);
					break;
				}
				case 8: {
					this.border = new Border();
					this.border.read(reader);
					break;
				}
				case 9: {
					this.font = new Font();
					this.font.read(reader);
					break;
				}
				case 10: {
					this.action = readInt(reader);
					break;
				}
				case 11: {
					this.hoveredBackgroundColor = readString(reader);
					break;
				}
				case 12: {
					this.pressedBackgroundColor = readString(reader);
					break;
				}
				case 13: {
					this.focusedBackgroundColor = readString(reader);
					break;
				}
				case 14: {
					this.hoveredBorder = new Border();
					this.hoveredBorder.read(reader);
					break;
				}
				case 15: {
					this.pressedBorder = new Border();
					this.pressedBorder.read(reader);
					break;
				}
				case 16: {
					this.focusedBorder = new Border();
					this.focusedBorder.read(reader);
					break;
				}
				case 17: {
					this.wrap = readBool(reader);
					break;
				}
				case 18: {
					this.stylePreset = readInt(reader);
					break;
				}
				case 19: {
					this.position = new Position();
					this.position.read(reader);
					break;
				}
				case 20: {
					this.disabled = readBool(reader);
					break;
				}
				case 21: {
					this.invisible = readBool(reader);
					break;
				}
				case 22: {
					this.id = readString(reader);
					break;
				}
				case 23: {
					this.noClip = readBool(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.children !== undefined && !this.children.isZero(),
			this.gap !== undefined,
			this.frame !== undefined && !this.frame.isZero(),
			this.alignment !== undefined,
			this.backgroundColor !== undefined,
			this.padding !== undefined && !this.padding.isZero(),
			this.accessibilityLabel !== undefined,
			this.border !== undefined && !this.border.isZero(),
			this.font !== undefined && !this.font.isZero(),
			this.action !== undefined,
			this.hoveredBackgroundColor !== undefined,
			this.pressedBackgroundColor !== undefined,
			this.focusedBackgroundColor !== undefined,
			this.hoveredBorder !== undefined && !this.hoveredBorder.isZero(),
			this.pressedBorder !== undefined && !this.pressedBorder.isZero(),
			this.focusedBorder !== undefined && !this.focusedBorder.isZero(),
			this.wrap !== undefined,
			this.stylePreset !== undefined,
			this.position !== undefined && !this.position.isZero(),
			this.disabled !== undefined,
			this.invisible !== undefined,
			this.id !== undefined,
			this.noClip !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			this.children!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.gap!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.RECORD, 3);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			writeInt(writer, this.alignment!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			writeString(writer, this.backgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.RECORD, 6);
			this.padding!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 7);
			writeString(writer, this.accessibilityLabel!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.RECORD, 8);
			this.border!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.RECORD, 9);
			this.font!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.UVARINT, 10);
			writeInt(writer, this.action!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[11]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 11);
			writeString(writer, this.hoveredBackgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[12]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 12);
			writeString(writer, this.pressedBackgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[13]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 13);
			writeString(writer, this.focusedBackgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[14]) {
			writer.writeFieldHeader(Shapes.RECORD, 14);
			this.hoveredBorder!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[15]) {
			writer.writeFieldHeader(Shapes.RECORD, 15);
			this.pressedBorder!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[16]) {
			writer.writeFieldHeader(Shapes.RECORD, 16);
			this.focusedBorder!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[17]) {
			writer.writeFieldHeader(Shapes.UVARINT, 17);
			writeBool(writer, this.wrap!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[18]) {
			writer.writeFieldHeader(Shapes.UVARINT, 18);
			writeInt(writer, this.stylePreset!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[19]) {
			writer.writeFieldHeader(Shapes.RECORD, 19);
			this.position!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[20]) {
			writer.writeFieldHeader(Shapes.UVARINT, 20);
			writeBool(writer, this.disabled!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[21]) {
			writer.writeFieldHeader(Shapes.UVARINT, 21);
			writeBool(writer, this.invisible!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[22]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 22);
			writeString(writer, this.id!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[23]) {
			writer.writeFieldHeader(Shapes.UVARINT, 23);
			writeBool(writer, this.noClip!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			(this.children === undefined || this.children.isZero()) &&
			this.gap === undefined &&
			(this.frame === undefined || this.frame.isZero()) &&
			this.alignment === undefined &&
			this.backgroundColor === undefined &&
			(this.padding === undefined || this.padding.isZero()) &&
			this.accessibilityLabel === undefined &&
			(this.border === undefined || this.border.isZero()) &&
			(this.font === undefined || this.font.isZero()) &&
			this.action === undefined &&
			this.hoveredBackgroundColor === undefined &&
			this.pressedBackgroundColor === undefined &&
			this.focusedBackgroundColor === undefined &&
			(this.hoveredBorder === undefined || this.hoveredBorder.isZero()) &&
			(this.pressedBorder === undefined || this.pressedBorder.isZero()) &&
			(this.focusedBorder === undefined || this.focusedBorder.isZero()) &&
			this.wrap === undefined &&
			this.stylePreset === undefined &&
			(this.position === undefined || this.position.isZero()) &&
			this.disabled === undefined &&
			this.invisible === undefined &&
			this.id === undefined &&
			this.noClip === undefined
		);
	}

	reset(): void {
		this.children = undefined;
		this.gap = undefined;
		this.frame = undefined;
		this.alignment = undefined;
		this.backgroundColor = undefined;
		this.padding = undefined;
		this.accessibilityLabel = undefined;
		this.border = undefined;
		this.font = undefined;
		this.action = undefined;
		this.hoveredBackgroundColor = undefined;
		this.pressedBackgroundColor = undefined;
		this.focusedBackgroundColor = undefined;
		this.hoveredBorder = undefined;
		this.pressedBorder = undefined;
		this.focusedBorder = undefined;
		this.wrap = undefined;
		this.stylePreset = undefined;
		this.position = undefined;
		this.disabled = undefined;
		this.invisible = undefined;
		this.id = undefined;
		this.noClip = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 58);
		return;
	}
	isComponent(): void {}
}

// StylePreset allows to apply a build-in style to this component. This reduces over-the-wire boilerplate and
// also defines a stereotype, so that the applied component behavior may be indeed a bit different, because
// a native component may be used, e.g. for a native button. The order of appliance is first the preset and
// then customized properties on top.
//
export type StylePreset = number;
function writeTypeHeaderStylePreset(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 59);
	return;
}
// companion enum containing all defined constants for StylePreset
export enum StylePresetValues {
	// Default is that no style preset is applied.
	StyleNone = 0,
	StyleButtonPrimary = 1,
	StyleButtonSecondary = 2,
	StyleButtonTertiary = 3,
}

export class Position implements Writeable, Readable {
	public kind?: PositionType;

	public left?: Length;

	public top?: Length;

	public right?: Length;

	public bottom?: Length;

	public zIndex?: Int;

	constructor(
		kind: PositionType | undefined = undefined,
		left: Length | undefined = undefined,
		top: Length | undefined = undefined,
		right: Length | undefined = undefined,
		bottom: Length | undefined = undefined,
		zIndex: Int | undefined = undefined
	) {
		this.kind = kind;
		this.left = left;
		this.top = top;
		this.right = right;
		this.bottom = bottom;
		this.zIndex = zIndex;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.kind = readInt(reader);
					break;
				}
				case 2: {
					this.left = readString(reader);
					break;
				}
				case 3: {
					this.top = readString(reader);
					break;
				}
				case 4: {
					this.right = readString(reader);
					break;
				}
				case 5: {
					this.bottom = readString(reader);
					break;
				}
				case 6: {
					this.zIndex = readSint(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.kind !== undefined,
			this.left !== undefined,
			this.top !== undefined,
			this.right !== undefined,
			this.bottom !== undefined,
			this.zIndex !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			writeInt(writer, this.kind!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.left!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			writeString(writer, this.top!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			writeString(writer, this.right!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			writeString(writer, this.bottom!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.VARINT, 6);
			writeSint(writer, this.zIndex!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.kind === undefined &&
			this.left === undefined &&
			this.top === undefined &&
			this.right === undefined &&
			this.bottom === undefined &&
			this.zIndex === undefined
		);
	}

	reset(): void {
		this.kind = undefined;
		this.left = undefined;
		this.top = undefined;
		this.right = undefined;
		this.bottom = undefined;
		this.zIndex = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 60);
		return;
	}
}

export type PositionType = number;
function writeTypeHeaderPositionType(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 61);
	return;
}
// companion enum containing all defined constants for PositionType
export enum PositionTypeValues {
	// PositionDefault is the default and any explicit position value have no effect.
	//  See also https://developer.mozilla.org/de/docs/Web/CSS/position#static.
	PositionDefault = 0,
	// PositionOffset is like PositionDefault but moves the element by applying the given position values after
	//  layouting. See also https://developer.mozilla.org/de/docs/Web/CSS/position#relative.
	PositionOffset = 1,
	// PositionAbsolute removes the element from the layout and places it using the given values in an absolute way
	//  within any of its parent layouted as PositionOffset. If no parent with PositionOffset is found, the viewport
	//  is used. See also https://developer.mozilla.org/de/docs/Web/CSS/position#absolute.
	PositionAbsolute = 2,
	// PositionFixed removes the element from the layout and places it at a fixed position according to the viewport
	//  independent of the scroll position. See also https://developer.mozilla.org/de/docs/Web/CSS/position#absolute.
	PositionFixed = 3,
	// PositionSticky is here for completion, and it is unclear which rules to follow on mobile clients.
	//  See also https://developer.mozilla.org/de/docs/Web/CSS/position#absolute.
	PositionSticky = 4,
}

export class Img implements Writeable, Readable, Component {
	public uri?: URI;

	public accessibilityLabel?: Str;

	public border?: Border;

	public frame?: Frame;

	public padding?: Padding;

	public sVG?: SVG;

	public fillColor?: Color;

	public strokeColor?: Color;

	public invisible?: Bool;

	// Optional ObjectFit. If 0 or omitted, an automatic behavior is applied. This may treat SVG and raster formats differently.
	public objectFit?: ObjectFit;

	constructor(
		uri: URI | undefined = undefined,
		accessibilityLabel: Str | undefined = undefined,
		border: Border | undefined = undefined,
		frame: Frame | undefined = undefined,
		padding: Padding | undefined = undefined,
		sVG: SVG | undefined = undefined,
		fillColor: Color | undefined = undefined,
		strokeColor: Color | undefined = undefined,
		invisible: Bool | undefined = undefined,
		objectFit: ObjectFit | undefined = undefined
	) {
		this.uri = uri;
		this.accessibilityLabel = accessibilityLabel;
		this.border = border;
		this.frame = frame;
		this.padding = padding;
		this.sVG = sVG;
		this.fillColor = fillColor;
		this.strokeColor = strokeColor;
		this.invisible = invisible;
		this.objectFit = objectFit;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.uri = readString(reader);
					break;
				}
				case 2: {
					this.accessibilityLabel = readString(reader);
					break;
				}
				case 3: {
					this.border = new Border();
					this.border.read(reader);
					break;
				}
				case 4: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				case 5: {
					this.padding = new Padding();
					this.padding.read(reader);
					break;
				}
				case 6: {
					this.sVG = readString(reader);
					break;
				}
				case 7: {
					this.fillColor = readString(reader);
					break;
				}
				case 8: {
					this.strokeColor = readString(reader);
					break;
				}
				case 9: {
					this.invisible = readBool(reader);
					break;
				}
				case 10: {
					this.objectFit = readInt(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.uri !== undefined,
			this.accessibilityLabel !== undefined,
			this.border !== undefined && !this.border.isZero(),
			this.frame !== undefined && !this.frame.isZero(),
			this.padding !== undefined && !this.padding.isZero(),
			this.sVG !== undefined,
			this.fillColor !== undefined,
			this.strokeColor !== undefined,
			this.invisible !== undefined,
			this.objectFit !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.uri!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.accessibilityLabel!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.RECORD, 3);
			this.border!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.RECORD, 4);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.RECORD, 5);
			this.padding!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 6);
			writeString(writer, this.sVG!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 7);
			writeString(writer, this.fillColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 8);
			writeString(writer, this.strokeColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.UVARINT, 9);
			writeBool(writer, this.invisible!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.UVARINT, 10);
			writeInt(writer, this.objectFit!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.uri === undefined &&
			this.accessibilityLabel === undefined &&
			(this.border === undefined || this.border.isZero()) &&
			(this.frame === undefined || this.frame.isZero()) &&
			(this.padding === undefined || this.padding.isZero()) &&
			this.sVG === undefined &&
			this.fillColor === undefined &&
			this.strokeColor === undefined &&
			this.invisible === undefined &&
			this.objectFit === undefined
		);
	}

	reset(): void {
		this.uri = undefined;
		this.accessibilityLabel = undefined;
		this.border = undefined;
		this.frame = undefined;
		this.padding = undefined;
		this.sVG = undefined;
		this.fillColor = undefined;
		this.strokeColor = undefined;
		this.invisible = undefined;
		this.objectFit = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 62);
		return;
	}
	isComponent(): void {}
}

// SVG contains the valid embeddable source of Scalable Vector Graphics.
export type SVG = string;
function writeTypeHeaderSVG(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.BYTESLICE, 63);
	return;
}

// Strings is just a bunch of string values.
export class Strings implements Writeable, Readable {
	public value: Str[];

	constructor(value: Str[] = []) {
		this.value = value;
	}

	isZero(): boolean {
		return !this.value || this.value.length === 0;
	}

	reset(): void {
		this.value = [];
	}

	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value.length); // Write the length of the array
		for (const c of this.value) {
			writeTypeHeaderStr(writer);
			writeString(writer, c);

			//c.writeTypeHeader(writer); // Write the type header for each component
			//c.write(writer); // Write the component data
		}
	}

	read(reader: BinaryReader): void {
		const count = reader.readUvarint(); // Read the length of the array
		const values: Str[] = [];

		for (let i = 0; i < count; i++) {
			const obj = unmarshal(reader); // Read and unmarshal each component
			values.push(obj as any as Str); // Cast and add to the array
		}

		this.value = values;
	}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 64);
		return;
	}
}

// FileImportRequested asks the frontend to let the user pick some files.
// Depending on the actual backend configuration, this may cause
// a regular http multipart upload or some FFI calls providing data streams
// or accessor URIs.
export class FileImportRequested implements Writeable, Readable, NagoEvent {
	public iD?: Str;

	public scopeID?: Str;

	public multiple?: Bool;

	public maxBytes?: Uint;

	public allowedMimeTypes?: Strings;

	constructor(
		iD: Str | undefined = undefined,
		scopeID: Str | undefined = undefined,
		multiple: Bool | undefined = undefined,
		maxBytes: Uint | undefined = undefined,
		allowedMimeTypes: Strings | undefined = undefined
	) {
		this.iD = iD;
		this.scopeID = scopeID;
		this.multiple = multiple;
		this.maxBytes = maxBytes;
		this.allowedMimeTypes = allowedMimeTypes;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.iD = readString(reader);
					break;
				}
				case 2: {
					this.scopeID = readString(reader);
					break;
				}
				case 3: {
					this.multiple = readBool(reader);
					break;
				}
				case 4: {
					this.maxBytes = readInt(reader);
					break;
				}
				case 5: {
					this.allowedMimeTypes = new Strings();
					this.allowedMimeTypes.read(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.iD !== undefined,
			this.scopeID !== undefined,
			this.multiple !== undefined,
			this.maxBytes !== undefined,
			this.allowedMimeTypes !== undefined && !this.allowedMimeTypes.isZero(),
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.iD!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.scopeID!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			writeBool(writer, this.multiple!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			writeInt(writer, this.maxBytes!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.ARRAY, 5);
			this.allowedMimeTypes!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.iD === undefined &&
			this.scopeID === undefined &&
			this.multiple === undefined &&
			this.maxBytes === undefined &&
			(this.allowedMimeTypes === undefined || this.allowedMimeTypes.isZero())
		);
	}

	reset(): void {
		this.iD = undefined;
		this.scopeID = undefined;
		this.multiple = undefined;
		this.maxBytes = undefined;
		this.allowedMimeTypes = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 65);
		return;
	}
	isNagoEvent(): void {}
}

export class KeyboardOptions implements Writeable, Readable {
	public capitalization?: Bool;

	public autoCorrectEnabled?: Bool;

	public keyboardType?: KeyboardType;

	constructor(
		capitalization: Bool | undefined = undefined,
		autoCorrectEnabled: Bool | undefined = undefined,
		keyboardType: KeyboardType | undefined = undefined
	) {
		this.capitalization = capitalization;
		this.autoCorrectEnabled = autoCorrectEnabled;
		this.keyboardType = keyboardType;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.capitalization = readBool(reader);
					break;
				}
				case 2: {
					this.autoCorrectEnabled = readBool(reader);
					break;
				}
				case 3: {
					this.keyboardType = readInt(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.capitalization !== undefined,
			this.autoCorrectEnabled !== undefined,
			this.keyboardType !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			writeBool(writer, this.capitalization!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			writeBool(writer, this.autoCorrectEnabled!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			writeInt(writer, this.keyboardType!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.capitalization === undefined &&
			this.autoCorrectEnabled === undefined &&
			this.keyboardType === undefined
		);
	}

	reset(): void {
		this.capitalization = undefined;
		this.autoCorrectEnabled = undefined;
		this.keyboardType = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 66);
		return;
	}
}

export type KeyboardType = number;
function writeTypeHeaderKeyboardType(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 67);
	return;
}
// companion enum containing all defined constants for KeyboardType
export enum KeyboardTypeValues {
	KeyboardDefault = 0,
	KeyboardAscii = 1,
	KeyboardInteger = 2,
	KeyboardFloat = 3,
	KeyboardEMail = 4,
	KeyboardPhone = 5,
	KeyboardSearch = 6,
	KeyboardURL = 7,
}

export type ModalType = number;
function writeTypeHeaderModalType(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 68);
	return;
}
// companion enum containing all defined constants for ModalType
export enum ModalTypeValues {
	ModalTypeDialog = 0,
	ModalTypeOverlay = 1,
}

// A Modal can be declared at any place in the composed view tree. However, these dialogs are teleported into
// the modal space in tree declaration order. A Modal is layouted above all other regular content and if ModalTypeDialog
// will catch focus and disable controls of the views behind. Its bounds are at most the maximum possible screen size.
export class Modal implements Writeable, Readable, Component {
	public content?: Component;

	// OnDismissRequest is called, if the user wants to dismiss the dialog, e.g. by clicking outside or pressing escape. You can then decide to disable you dialog, or not.
	public onDismissRequest?: Ptr;

	public modalType?: ModalType;

	public top?: Length;

	public left?: Length;

	public right?: Length;

	public bottom?: Length;

	public allowBackgroundScrolling?: Bool;

	constructor(
		content: Component | undefined = undefined,
		onDismissRequest: Ptr | undefined = undefined,
		modalType: ModalType | undefined = undefined,
		top: Length | undefined = undefined,
		left: Length | undefined = undefined,
		right: Length | undefined = undefined,
		bottom: Length | undefined = undefined,
		allowBackgroundScrolling: Bool | undefined = undefined
	) {
		this.content = content;
		this.onDismissRequest = onDismissRequest;
		this.modalType = modalType;
		this.top = top;
		this.left = left;
		this.right = right;
		this.bottom = bottom;
		this.allowBackgroundScrolling = allowBackgroundScrolling;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
						throw new Error(`unexpected length: ` + len);
					}
					this.content = unmarshal(reader) as Component;
					break;
				}
				case 2: {
					this.onDismissRequest = readInt(reader);
					break;
				}
				case 3: {
					this.modalType = readInt(reader);
					break;
				}
				case 4: {
					this.top = readString(reader);
					break;
				}
				case 5: {
					this.left = readString(reader);
					break;
				}
				case 6: {
					this.right = readString(reader);
					break;
				}
				case 7: {
					this.bottom = readString(reader);
					break;
				}
				case 8: {
					this.allowBackgroundScrolling = readBool(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.content !== undefined && !this.content.isZero(),
			this.onDismissRequest !== undefined,
			this.modalType !== undefined,
			this.top !== undefined,
			this.left !== undefined,
			this.right !== undefined,
			this.bottom !== undefined,
			this.allowBackgroundScrolling !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			writer.writeByte(1);
			this.content.writeTypeHeader(writer);
			this.content!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			writeInt(writer, this.onDismissRequest!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			writeInt(writer, this.modalType!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			writeString(writer, this.top!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			writeString(writer, this.left!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 6);
			writeString(writer, this.right!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 7);
			writeString(writer, this.bottom!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.UVARINT, 8);
			writeBool(writer, this.allowBackgroundScrolling!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			(this.content === undefined || this.content.isZero()) &&
			this.onDismissRequest === undefined &&
			this.modalType === undefined &&
			this.top === undefined &&
			this.left === undefined &&
			this.right === undefined &&
			this.bottom === undefined &&
			this.allowBackgroundScrolling === undefined
		);
	}

	reset(): void {
		this.content = undefined;
		this.onDismissRequest = undefined;
		this.modalType = undefined;
		this.top = undefined;
		this.left = undefined;
		this.right = undefined;
		this.bottom = undefined;
		this.allowBackgroundScrolling = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 69);
		return;
	}
	isComponent(): void {}
}

// ThemeRequested is usually emitted by the backend, so that the frontend will switch (and remember) the required theme state.
export class ThemeRequested implements Writeable, Readable, NagoEvent {
	// Theme contains the name of the theme to apply. Usually light or dark, however we may want to provide more or go even arbitrary.
	public theme?: ThemeID;

	constructor(theme: ThemeID | undefined = undefined) {
		this.theme = theme;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.theme = readString(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.theme !== undefined];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.theme!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.theme === undefined;
	}

	reset(): void {
		this.theme = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 70);
		return;
	}
	isNagoEvent(): void {}
}

// NavigationForwardToRequested is an Event triggered by the backend which requests a forward navigation action within the frontend.
// A frontend must put the new component to create by the factory on top of the current component within the scope.
// The frontend is free keep multiple components alive at the same time, however it must ensure that the UX is sane.
export class NavigationForwardToRequested implements Writeable, Readable, NagoEvent {
	public rootView?: RootViewID;

	public values?: RootViewParameters;

	// Target gives a hint for the frontend navigation where the RootView shall appear. This allows internal root views to behave more similar to conventional http refs and _blank shall be supported, if possible.
	public target?: Str;

	constructor(
		rootView: RootViewID | undefined = undefined,
		values: RootViewParameters | undefined = undefined,
		target: Str | undefined = undefined
	) {
		this.rootView = rootView;
		this.values = values;
		this.target = target;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.rootView = readString(reader);
					break;
				}
				case 2: {
					this.values = new RootViewParameters();
					this.values.read(reader);
					break;
				}
				case 3: {
					this.target = readString(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.rootView !== undefined,
			this.values !== undefined && !this.values.isZero(),
			this.target !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.rootView!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.ARRAY, 2);
			this.values!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			writeString(writer, this.target!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.rootView === undefined &&
			(this.values === undefined || this.values.isZero()) &&
			this.target === undefined
		);
	}

	reset(): void {
		this.rootView = undefined;
		this.values = undefined;
		this.target = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 71);
		return;
	}
	isNagoEvent(): void {}
}

// NavigationResetRequested removes the entire history in the scope and pushes the target on top.
export class NavigationResetRequested implements Writeable, Readable, NagoEvent {
	public rootView?: RootViewID;

	public values?: RootViewParameters;

	constructor(rootView: RootViewID | undefined = undefined, values: RootViewParameters | undefined = undefined) {
		this.rootView = rootView;
		this.values = values;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.rootView = readString(reader);
					break;
				}
				case 2: {
					this.values = new RootViewParameters();
					this.values.read(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.rootView !== undefined, this.values !== undefined && !this.values.isZero()];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.rootView!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.ARRAY, 2);
			this.values!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.rootView === undefined && (this.values === undefined || this.values.isZero());
	}

	reset(): void {
		this.rootView = undefined;
		this.values = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 72);
		return;
	}
	isNagoEvent(): void {}
}

// NavigationBackRequested steps back causing a likely destruction of the most top component. The frontend may decide to ignore that, if the stack would be empty/undefined otherwise.
export class NavigationBackRequested implements Writeable, Readable, NagoEvent {
	constructor() {}

	read(r: BinaryReader): void {
		r.readByte();
	}
	write(w: BinaryWriter): void {
		w.writeByte(0);
	}
	isZero(): boolean {
		return true;
	}
	reset(): void {}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 73);
		return;
	}
	isNagoEvent(): void {}
}

export class NavigationReloadRequested implements Writeable, Readable, NagoEvent {
	constructor() {}

	read(r: BinaryReader): void {
		r.readByte();
	}
	write(w: BinaryWriter): void {
		w.writeByte(0);
	}
	isZero(): boolean {
		return true;
	}
	reset(): void {}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 74);
		return;
	}
	isNagoEvent(): void {}
}

// ThemeID refers to a specific theme. E.g. dark or light
export type ThemeID = string;
function writeTypeHeaderThemeID(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.BYTESLICE, 75);
	return;
}

// WindowTitle is an invisible component which teleports its Value into the current active window navigation title. The last evaluated title in the hierarchy wins.
export class WindowTitle implements Writeable, Readable, Component {
	public value?: Str;

	constructor(value: Str | undefined = undefined) {
		this.value = value;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.value = readString(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.value !== undefined];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.value!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.value === undefined;
	}

	reset(): void {
		this.value = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 77);
		return;
	}
	isComponent(): void {}
}

// Duration represents a duration in nanoseconds
export type Duration = number;
function writeTypeHeaderDuration(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 78);
	return;
}

export class PasswordField implements Writeable, Readable, Component {
	public label?: Str;

	public supportingText?: Str;

	// ErrorText is shown instead of SupportingText, even if they are (today) independent
	public errorText?: Str;

	// Value contains the text, which shall be shown.
	public value?: Str;

	public frame?: Frame;

	// InputValue is a binding to a state, into which the frontend will the user entered text. This is the pointer a State.
	public inputValue?: Ptr;

	// Style to apply. Use TextFieldReduced in forms where many textfields cause too much visual noise and you need to reduce it. By default, the TextFieldOutlined is applied.
	public style?: TextFieldStyle;

	// DebounceTime is in nanoseconds. A zero or omitted value means to enable debounce default logic.
	public debounceTime?: Duration;

	// Lines enforces a single line if <= 0, otherwise it shows the amount of text lines within a text area.
	public lines?: Uint;

	public disabled?: Bool;

	public disableAutocomplete?: Bool;

	// DisableDebounce must be set to true, to disable the default debouncer logic. This will cause a render roundtrip for each keystroke, so be careful not to break the server or cause UX issues due to UI latencies.
	public disableDebounce?: Bool;

	public invisible?: Bool;

	// If Revealed the password is shown
	public revealed?: Bool;

	// Id represents an optional identifier to locate this component within the view tree. It must be either empty or unique within the entire tree instance.
	public id?: Str;

	public keydownEnter?: Ptr;

	constructor(
		label: Str | undefined = undefined,
		supportingText: Str | undefined = undefined,
		errorText: Str | undefined = undefined,
		value: Str | undefined = undefined,
		frame: Frame | undefined = undefined,
		inputValue: Ptr | undefined = undefined,
		style: TextFieldStyle | undefined = undefined,
		debounceTime: Duration | undefined = undefined,
		lines: Uint | undefined = undefined,
		disabled: Bool | undefined = undefined,
		disableAutocomplete: Bool | undefined = undefined,
		disableDebounce: Bool | undefined = undefined,
		invisible: Bool | undefined = undefined,
		revealed: Bool | undefined = undefined,
		id: Str | undefined = undefined,
		keydownEnter: Ptr | undefined = undefined
	) {
		this.label = label;
		this.supportingText = supportingText;
		this.errorText = errorText;
		this.value = value;
		this.frame = frame;
		this.inputValue = inputValue;
		this.style = style;
		this.debounceTime = debounceTime;
		this.lines = lines;
		this.disabled = disabled;
		this.disableAutocomplete = disableAutocomplete;
		this.disableDebounce = disableDebounce;
		this.invisible = invisible;
		this.revealed = revealed;
		this.id = id;
		this.keydownEnter = keydownEnter;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.label = readString(reader);
					break;
				}
				case 2: {
					this.supportingText = readString(reader);
					break;
				}
				case 3: {
					this.errorText = readString(reader);
					break;
				}
				case 4: {
					this.value = readString(reader);
					break;
				}
				case 5: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				case 6: {
					this.inputValue = readInt(reader);
					break;
				}
				case 7: {
					this.style = readInt(reader);
					break;
				}
				case 8: {
					this.debounceTime = readInt(reader);
					break;
				}
				case 9: {
					this.lines = readInt(reader);
					break;
				}
				case 10: {
					this.disabled = readBool(reader);
					break;
				}
				case 11: {
					this.disableAutocomplete = readBool(reader);
					break;
				}
				case 12: {
					this.disableDebounce = readBool(reader);
					break;
				}
				case 13: {
					this.invisible = readBool(reader);
					break;
				}
				case 14: {
					this.revealed = readBool(reader);
					break;
				}
				case 15: {
					this.id = readString(reader);
					break;
				}
				case 16: {
					this.keydownEnter = readInt(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.label !== undefined,
			this.supportingText !== undefined,
			this.errorText !== undefined,
			this.value !== undefined,
			this.frame !== undefined && !this.frame.isZero(),
			this.inputValue !== undefined,
			this.style !== undefined,
			this.debounceTime !== undefined,
			this.lines !== undefined,
			this.disabled !== undefined,
			this.disableAutocomplete !== undefined,
			this.disableDebounce !== undefined,
			this.invisible !== undefined,
			this.revealed !== undefined,
			this.id !== undefined,
			this.keydownEnter !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.label!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.supportingText!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			writeString(writer, this.errorText!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			writeString(writer, this.value!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.RECORD, 5);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.UVARINT, 6);
			writeInt(writer, this.inputValue!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.UVARINT, 7);
			writeInt(writer, this.style!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.UVARINT, 8);
			writeInt(writer, this.debounceTime!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.UVARINT, 9);
			writeInt(writer, this.lines!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.UVARINT, 10);
			writeBool(writer, this.disabled!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[11]) {
			writer.writeFieldHeader(Shapes.UVARINT, 11);
			writeBool(writer, this.disableAutocomplete!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[12]) {
			writer.writeFieldHeader(Shapes.UVARINT, 12);
			writeBool(writer, this.disableDebounce!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[13]) {
			writer.writeFieldHeader(Shapes.UVARINT, 13);
			writeBool(writer, this.invisible!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[14]) {
			writer.writeFieldHeader(Shapes.UVARINT, 14);
			writeBool(writer, this.revealed!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[15]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 15);
			writeString(writer, this.id!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[16]) {
			writer.writeFieldHeader(Shapes.UVARINT, 16);
			writeInt(writer, this.keydownEnter!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.label === undefined &&
			this.supportingText === undefined &&
			this.errorText === undefined &&
			this.value === undefined &&
			(this.frame === undefined || this.frame.isZero()) &&
			this.inputValue === undefined &&
			this.style === undefined &&
			this.debounceTime === undefined &&
			this.lines === undefined &&
			this.disabled === undefined &&
			this.disableAutocomplete === undefined &&
			this.disableDebounce === undefined &&
			this.invisible === undefined &&
			this.revealed === undefined &&
			this.id === undefined &&
			this.keydownEnter === undefined
		);
	}

	reset(): void {
		this.label = undefined;
		this.supportingText = undefined;
		this.errorText = undefined;
		this.value = undefined;
		this.frame = undefined;
		this.inputValue = undefined;
		this.style = undefined;
		this.debounceTime = undefined;
		this.lines = undefined;
		this.disabled = undefined;
		this.disableAutocomplete = undefined;
		this.disableDebounce = undefined;
		this.invisible = undefined;
		this.revealed = undefined;
		this.id = undefined;
		this.keydownEnter = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 79);
		return;
	}
	isComponent(): void {}
}

export type TextFieldStyle = number;
function writeTypeHeaderTextFieldStyle(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 80);
	return;
}
// companion enum containing all defined constants for TextFieldStyle
export enum TextFieldStyleValues {
	// TextFieldOutlined is fine for smaller forms and helps to identify where to put text in the form.
	TextFieldOutlined = 0,
	// TextFieldReduced has no outlines and thus less visual disruption in larger forms.
	TextFieldReduced = 1,
	// TextFieldBasic removes as much as decorations as possible. There may be limitations based on the platform. Note, that an implementation is allowed to ignore leading, trailing, supporting and errorText for this mode. It may serve as a building-block for custom fields.
	TextFieldBasic = 2,
}

// Ping is usually send by the frontend to the backend to keep the websocket alive for all intermediate proxies or other underlying channel implementations.
export class Ping implements Writeable, Readable, NagoEvent {
	constructor() {}

	read(r: BinaryReader): void {
		r.readByte();
	}
	write(w: BinaryWriter): void {
		w.writeByte(0);
	}
	isZero(): boolean {
		return true;
	}
	reset(): void {}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 81);
		return;
	}
	isNagoEvent(): void {}
}

// Radiobutton represents a user interface element which spans a visible area to click or tap from the user. Usually a radiobutton belongs to a group, where only a single element can be picked. Thus, it is quite similar to a Spinner/Select/Combobox.
export class Radiobutton implements Writeable, Readable, Component {
	// InputValue is where updated value of the checked states are written.
	public inputValue?: Ptr;

	// Value is the initial checked value.
	public value?: Bool;

	public disabled?: Bool;

	public invisible?: Bool;

	constructor(
		inputValue: Ptr | undefined = undefined,
		value: Bool | undefined = undefined,
		disabled: Bool | undefined = undefined,
		invisible: Bool | undefined = undefined
	) {
		this.inputValue = inputValue;
		this.value = value;
		this.disabled = disabled;
		this.invisible = invisible;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.inputValue = readInt(reader);
					break;
				}
				case 2: {
					this.value = readBool(reader);
					break;
				}
				case 3: {
					this.disabled = readBool(reader);
					break;
				}
				case 4: {
					this.invisible = readBool(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.inputValue !== undefined,
			this.value !== undefined,
			this.disabled !== undefined,
			this.invisible !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			writeInt(writer, this.inputValue!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			writeBool(writer, this.value!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			writeBool(writer, this.disabled!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			writeBool(writer, this.invisible!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.inputValue === undefined &&
			this.value === undefined &&
			this.disabled === undefined &&
			this.invisible === undefined
		);
	}

	reset(): void {
		this.inputValue = undefined;
		this.value = undefined;
		this.disabled = undefined;
		this.invisible = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 82);
		return;
	}
	isComponent(): void {}
}

export type ScaffoldAlignment = number;
function writeTypeHeaderScaffoldAlignment(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 83);
	return;
}
// companion enum containing all defined constants for ScaffoldAlignment
export enum ScaffoldAlignmentValues {
	ScaffoldAlignmentTop = 0,
	ScaffoldAlignmentLeading = 1,
}

export class ScaffoldMenuEntries implements Writeable, Readable {
	public value: ScaffoldMenuEntry[];

	constructor(value: ScaffoldMenuEntry[] = []) {
		this.value = value;
	}

	isZero(): boolean {
		return !this.value || this.value.length === 0;
	}

	reset(): void {
		this.value = [];
	}

	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value.length); // Write the length of the array
		for (const c of this.value) {
			c.writeTypeHeader(writer); // Write the type header for each component)
			c.write(writer); // Write the component data

			//c.writeTypeHeader(writer); // Write the type header for each component
			//c.write(writer); // Write the component data
		}
	}

	read(reader: BinaryReader): void {
		const count = reader.readUvarint(); // Read the length of the array
		const values: ScaffoldMenuEntry[] = [];

		for (let i = 0; i < count; i++) {
			const obj = unmarshal(reader); // Read and unmarshal each component
			values.push(obj as any as ScaffoldMenuEntry); // Cast and add to the array
		}

		this.value = values;
	}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 84);
		return;
	}
}

export class Scaffold implements Writeable, Readable, Component {
	public body?: Component;

	public logo?: Component;

	public menu?: ScaffoldMenuEntries;

	public alignment?: ScaffoldAlignment;

	// Breakpoint at which the navigation bar or side bar should switch to the burger menu. Defaults to 768px.
	public breakpoint?: Uint;

	public footer?: Component;

	constructor(
		body: Component | undefined = undefined,
		logo: Component | undefined = undefined,
		menu: ScaffoldMenuEntries | undefined = undefined,
		alignment: ScaffoldAlignment | undefined = undefined,
		breakpoint: Uint | undefined = undefined,
		footer: Component | undefined = undefined
	) {
		this.body = body;
		this.logo = logo;
		this.menu = menu;
		this.alignment = alignment;
		this.breakpoint = breakpoint;
		this.footer = footer;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
						throw new Error(`unexpected length: ` + len);
					}
					this.body = unmarshal(reader) as Component;
					break;
				}
				case 2: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
						throw new Error(`unexpected length: ` + len);
					}
					this.logo = unmarshal(reader) as Component;
					break;
				}
				case 3: {
					this.menu = new ScaffoldMenuEntries();
					this.menu.read(reader);
					break;
				}
				case 4: {
					this.alignment = readInt(reader);
					break;
				}
				case 5: {
					this.breakpoint = readInt(reader);
					break;
				}
				case 6: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
						throw new Error(`unexpected length: ` + len);
					}
					this.footer = unmarshal(reader) as Component;
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.body !== undefined && !this.body.isZero(),
			this.logo !== undefined && !this.logo.isZero(),
			this.menu !== undefined && !this.menu.isZero(),
			this.alignment !== undefined,
			this.breakpoint !== undefined,
			this.footer !== undefined && !this.footer.isZero(),
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			writer.writeByte(1);
			this.body.writeTypeHeader(writer);
			this.body!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 2);
			writer.writeByte(1);
			this.logo.writeTypeHeader(writer);
			this.logo!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.ARRAY, 3);
			this.menu!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			writeInt(writer, this.alignment!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.UVARINT, 5);
			writeInt(writer, this.breakpoint!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 6);
			writer.writeByte(1);
			this.footer.writeTypeHeader(writer);
			this.footer!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			(this.body === undefined || this.body.isZero()) &&
			(this.logo === undefined || this.logo.isZero()) &&
			(this.menu === undefined || this.menu.isZero()) &&
			this.alignment === undefined &&
			this.breakpoint === undefined &&
			(this.footer === undefined || this.footer.isZero())
		);
	}

	reset(): void {
		this.body = undefined;
		this.logo = undefined;
		this.menu = undefined;
		this.alignment = undefined;
		this.breakpoint = undefined;
		this.footer = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 85);
		return;
	}
	isComponent(): void {}
}

export class ScaffoldMenuEntry implements Writeable, Readable {
	public icon?: Component;

	public iconActive?: Component;

	public title?: Str;

	public action?: Ptr;

	public rootView?: RootViewID;

	public menu?: ScaffoldMenuEntries;

	public badge?: Str;

	public expanded?: Bool;

	constructor(
		icon: Component | undefined = undefined,
		iconActive: Component | undefined = undefined,
		title: Str | undefined = undefined,
		action: Ptr | undefined = undefined,
		rootView: RootViewID | undefined = undefined,
		menu: ScaffoldMenuEntries | undefined = undefined,
		badge: Str | undefined = undefined,
		expanded: Bool | undefined = undefined
	) {
		this.icon = icon;
		this.iconActive = iconActive;
		this.title = title;
		this.action = action;
		this.rootView = rootView;
		this.menu = menu;
		this.badge = badge;
		this.expanded = expanded;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
						throw new Error(`unexpected length: ` + len);
					}
					this.icon = unmarshal(reader) as Component;
					break;
				}
				case 2: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
						throw new Error(`unexpected length: ` + len);
					}
					this.iconActive = unmarshal(reader) as Component;
					break;
				}
				case 3: {
					this.title = readString(reader);
					break;
				}
				case 4: {
					this.action = readInt(reader);
					break;
				}
				case 5: {
					this.rootView = readString(reader);
					break;
				}
				case 6: {
					this.menu = new ScaffoldMenuEntries();
					this.menu.read(reader);
					break;
				}
				case 7: {
					this.badge = readString(reader);
					break;
				}
				case 8: {
					this.expanded = readBool(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.icon !== undefined && !this.icon.isZero(),
			this.iconActive !== undefined && !this.iconActive.isZero(),
			this.title !== undefined,
			this.action !== undefined,
			this.rootView !== undefined,
			this.menu !== undefined && !this.menu.isZero(),
			this.badge !== undefined,
			this.expanded !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			writer.writeByte(1);
			this.icon.writeTypeHeader(writer);
			this.icon!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 2);
			writer.writeByte(1);
			this.iconActive.writeTypeHeader(writer);
			this.iconActive!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			writeString(writer, this.title!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			writeInt(writer, this.action!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			writeString(writer, this.rootView!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.ARRAY, 6);
			this.menu!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 7);
			writeString(writer, this.badge!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.UVARINT, 8);
			writeBool(writer, this.expanded!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			(this.icon === undefined || this.icon.isZero()) &&
			(this.iconActive === undefined || this.iconActive.isZero()) &&
			this.title === undefined &&
			this.action === undefined &&
			this.rootView === undefined &&
			(this.menu === undefined || this.menu.isZero()) &&
			this.badge === undefined &&
			this.expanded === undefined
		);
	}

	reset(): void {
		this.icon = undefined;
		this.iconActive = undefined;
		this.title = undefined;
		this.action = undefined;
		this.rootView = undefined;
		this.menu = undefined;
		this.badge = undefined;
		this.expanded = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 86);
		return;
	}
}

export type ScopeID = string;
function writeTypeHeaderScopeID(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.BYTESLICE, 87);
	return;
}

// ScopeDestructionRequested can be emitted by a frontend to deallocate a scope, its states and root view at the backend side. This is usually only possible, if you have a kind of destruction event in the frontend.
export class ScopeDestructionRequested implements Writeable, Readable, NagoEvent {
	public rID?: RID;

	constructor(rID: RID | undefined = undefined) {
		this.rID = rID;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.rID = readInt(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.rID !== undefined];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			writeInt(writer, this.rID!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.rID === undefined;
	}

	reset(): void {
		this.rID = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 88);
		return;
	}
	isNagoEvent(): void {}
}

export type ScrollViewAxis = number;
function writeTypeHeaderScrollViewAxis(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 89);
	return;
}
// companion enum containing all defined constants for ScrollViewAxis
export enum ScrollViewAxisValues {
	ScrollViewAxisVertical = 0,
	ScrollViewAxisHorizontal = 1,
	ScrollViewAxisBoth = 2,
}

// A ScrollView can either be horizontal or vertical.
export class ScrollView implements Writeable, Readable, Component {
	public content?: Component;

	public border?: Border;

	public frame?: Frame;

	public padding?: Padding;

	public backgroundColor?: Color;

	public axis?: ScrollViewAxis;

	public invisible?: Bool;

	public position?: Position;

	constructor(
		content: Component | undefined = undefined,
		border: Border | undefined = undefined,
		frame: Frame | undefined = undefined,
		padding: Padding | undefined = undefined,
		backgroundColor: Color | undefined = undefined,
		axis: ScrollViewAxis | undefined = undefined,
		invisible: Bool | undefined = undefined,
		position: Position | undefined = undefined
	) {
		this.content = content;
		this.border = border;
		this.frame = frame;
		this.padding = padding;
		this.backgroundColor = backgroundColor;
		this.axis = axis;
		this.invisible = invisible;
		this.position = position;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
						throw new Error(`unexpected length: ` + len);
					}
					this.content = unmarshal(reader) as Component;
					break;
				}
				case 2: {
					this.border = new Border();
					this.border.read(reader);
					break;
				}
				case 3: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				case 4: {
					this.padding = new Padding();
					this.padding.read(reader);
					break;
				}
				case 5: {
					this.backgroundColor = readString(reader);
					break;
				}
				case 6: {
					this.axis = readInt(reader);
					break;
				}
				case 7: {
					this.invisible = readBool(reader);
					break;
				}
				case 8: {
					this.position = new Position();
					this.position.read(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.content !== undefined && !this.content.isZero(),
			this.border !== undefined && !this.border.isZero(),
			this.frame !== undefined && !this.frame.isZero(),
			this.padding !== undefined && !this.padding.isZero(),
			this.backgroundColor !== undefined,
			this.axis !== undefined,
			this.invisible !== undefined,
			this.position !== undefined && !this.position.isZero(),
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			writer.writeByte(1);
			this.content.writeTypeHeader(writer);
			this.content!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.RECORD, 2);
			this.border!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.RECORD, 3);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.RECORD, 4);
			this.padding!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			writeString(writer, this.backgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.UVARINT, 6);
			writeInt(writer, this.axis!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.UVARINT, 7);
			writeBool(writer, this.invisible!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.RECORD, 8);
			this.position!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			(this.content === undefined || this.content.isZero()) &&
			(this.border === undefined || this.border.isZero()) &&
			(this.frame === undefined || this.frame.isZero()) &&
			(this.padding === undefined || this.padding.isZero()) &&
			this.backgroundColor === undefined &&
			this.axis === undefined &&
			this.invisible === undefined &&
			(this.position === undefined || this.position.isZero())
		);
	}

	reset(): void {
		this.content = undefined;
		this.border = undefined;
		this.frame = undefined;
		this.padding = undefined;
		this.backgroundColor = undefined;
		this.axis = undefined;
		this.invisible = undefined;
		this.position = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 90);
		return;
	}
	isComponent(): void {}
}

// A Resource represents a blob with a name and a resource accessor URI.
export class Resource implements Writeable, Readable {
	// Name must not be a path, just the human readable (and not unique) file name.
	public name?: Str;

	// URI is likely an unreadable link to resolve the actual data. It may incorporate additional security tokens and may have a limited lifetime and its scheme is undefined.
	public uRI?: URI;

	// MimeType is optional and is a hint about the anticipated content.
	public mimeType?: Str;

	constructor(
		name: Str | undefined = undefined,
		uRI: URI | undefined = undefined,
		mimeType: Str | undefined = undefined
	) {
		this.name = name;
		this.uRI = uRI;
		this.mimeType = mimeType;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.name = readString(reader);
					break;
				}
				case 2: {
					this.uRI = readString(reader);
					break;
				}
				case 3: {
					this.mimeType = readString(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.name !== undefined, this.uRI !== undefined, this.mimeType !== undefined];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.name!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.uRI!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			writeString(writer, this.mimeType!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.name === undefined && this.uRI === undefined && this.mimeType === undefined;
	}

	reset(): void {
		this.name = undefined;
		this.uRI = undefined;
		this.mimeType = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 91);
		return;
	}
}

export class Resources implements Writeable, Readable {
	public value: Resource[];

	constructor(value: Resource[] = []) {
		this.value = value;
	}

	isZero(): boolean {
		return !this.value || this.value.length === 0;
	}

	reset(): void {
		this.value = [];
	}

	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value.length); // Write the length of the array
		for (const c of this.value) {
			c.writeTypeHeader(writer); // Write the type header for each component)
			c.write(writer); // Write the component data

			//c.writeTypeHeader(writer); // Write the type header for each component
			//c.write(writer); // Write the component data
		}
	}

	read(reader: BinaryReader): void {
		const count = reader.readUvarint(); // Read the length of the array
		const values: Resource[] = [];

		for (let i = 0; i < count; i++) {
			const obj = unmarshal(reader); // Read and unmarshal each component
			values.push(obj as any as Resource); // Cast and add to the array
		}

		this.value = values;
	}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 92);
		return;
	}
}

// SendMultipleRequested is an event for the frontend from the backend
// to send the according resources into the system environment.
// A Webbrowser may issue a regular download. A backend should not issue multiple downloads at once but instead
// pack multiple files into a zip file because the browser support for something like a multipart download
// is just broken today. An Android App may trigger the according Intent and opens a picker
// to select the receiving app.
export class SendMultipleRequested implements Writeable, Readable, NagoEvent {
	public resources?: Resources;

	constructor(resources: Resources | undefined = undefined) {
		this.resources = resources;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.resources = new Resources();
					this.resources.read(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.resources !== undefined && !this.resources.isZero()];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			this.resources!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.resources === undefined || this.resources.isZero();
	}

	reset(): void {
		this.resources = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 93);
		return;
	}
	isNagoEvent(): void {}
}

// SessionAssigned must not be used by browser clients directly. A http channel implementation must issue this by itself due to security concerns like http-only cookies. Native client (mobile or desktop) should use this event instead.
export class SessionAssigned implements Writeable, Readable, NagoEvent {
	public sessionID?: Str;

	constructor(sessionID: Str | undefined = undefined) {
		this.sessionID = sessionID;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.sessionID = readString(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.sessionID !== undefined];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.sessionID!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.sessionID === undefined;
	}

	reset(): void {
		this.sessionID = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 94);
		return;
	}
	isNagoEvent(): void {}
}

// Spacer grows or shrinks within a HStack or VStack. In other layouts, the behavior is unspecified.
export class Spacer implements Writeable, Readable, Component {
	public frame?: Frame;

	public border?: Border;

	public backgroundColor?: Color;

	constructor(
		frame: Frame | undefined = undefined,
		border: Border | undefined = undefined,
		backgroundColor: Color | undefined = undefined
	) {
		this.frame = frame;
		this.border = border;
		this.backgroundColor = backgroundColor;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				case 2: {
					this.border = new Border();
					this.border.read(reader);
					break;
				}
				case 3: {
					this.backgroundColor = readString(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.frame !== undefined && !this.frame.isZero(),
			this.border !== undefined && !this.border.isZero(),
			this.backgroundColor !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.RECORD, 1);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.RECORD, 2);
			this.border!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			writeString(writer, this.backgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			(this.frame === undefined || this.frame.isZero()) &&
			(this.border === undefined || this.border.isZero()) &&
			this.backgroundColor === undefined
		);
	}

	reset(): void {
		this.frame = undefined;
		this.border = undefined;
		this.backgroundColor = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 95);
		return;
	}
	isComponent(): void {}
}

// Table represents a pre-styled table with limited styling capabilities. Use Grid for maximum flexibility.
export class Table implements Writeable, Readable, Component {
	public header?: TableHeader;

	public rows?: TableRows;

	public frame?: Frame;

	public backgroundColor?: Color;

	public border?: Border;

	public defaultCellPadding?: Padding;

	public rowDividerColor?: Color;

	public headerDividerColor?: Color;

	constructor(
		header: TableHeader | undefined = undefined,
		rows: TableRows | undefined = undefined,
		frame: Frame | undefined = undefined,
		backgroundColor: Color | undefined = undefined,
		border: Border | undefined = undefined,
		defaultCellPadding: Padding | undefined = undefined,
		rowDividerColor: Color | undefined = undefined,
		headerDividerColor: Color | undefined = undefined
	) {
		this.header = header;
		this.rows = rows;
		this.frame = frame;
		this.backgroundColor = backgroundColor;
		this.border = border;
		this.defaultCellPadding = defaultCellPadding;
		this.rowDividerColor = rowDividerColor;
		this.headerDividerColor = headerDividerColor;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.header = new TableHeader();
					this.header.read(reader);
					break;
				}
				case 2: {
					this.rows = new TableRows();
					this.rows.read(reader);
					break;
				}
				case 3: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				case 4: {
					this.backgroundColor = readString(reader);
					break;
				}
				case 5: {
					this.border = new Border();
					this.border.read(reader);
					break;
				}
				case 6: {
					this.defaultCellPadding = new Padding();
					this.defaultCellPadding.read(reader);
					break;
				}
				case 7: {
					this.rowDividerColor = readString(reader);
					break;
				}
				case 8: {
					this.headerDividerColor = readString(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.header !== undefined && !this.header.isZero(),
			this.rows !== undefined && !this.rows.isZero(),
			this.frame !== undefined && !this.frame.isZero(),
			this.backgroundColor !== undefined,
			this.border !== undefined && !this.border.isZero(),
			this.defaultCellPadding !== undefined && !this.defaultCellPadding.isZero(),
			this.rowDividerColor !== undefined,
			this.headerDividerColor !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.RECORD, 1);
			this.header!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.ARRAY, 2);
			this.rows!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.RECORD, 3);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			writeString(writer, this.backgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.RECORD, 5);
			this.border!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.RECORD, 6);
			this.defaultCellPadding!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 7);
			writeString(writer, this.rowDividerColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 8);
			writeString(writer, this.headerDividerColor!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			(this.header === undefined || this.header.isZero()) &&
			(this.rows === undefined || this.rows.isZero()) &&
			(this.frame === undefined || this.frame.isZero()) &&
			this.backgroundColor === undefined &&
			(this.border === undefined || this.border.isZero()) &&
			(this.defaultCellPadding === undefined || this.defaultCellPadding.isZero()) &&
			this.rowDividerColor === undefined &&
			this.headerDividerColor === undefined
		);
	}

	reset(): void {
		this.header = undefined;
		this.rows = undefined;
		this.frame = undefined;
		this.backgroundColor = undefined;
		this.border = undefined;
		this.defaultCellPadding = undefined;
		this.rowDividerColor = undefined;
		this.headerDividerColor = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 96);
		return;
	}
	isComponent(): void {}
}

export class TableCell implements Writeable, Readable {
	public content?: Component;

	// Values higher than 65534 are clipped.
	public rowSpan?: Uint;

	// Values higher than 1000 are clipped.
	public colSpan?: Uint;

	public alignment?: Alignment;

	public backgroundColor?: Color;

	public hoveredBackgroundColor?: Color;

	public padding?: Padding;

	public border?: Border;

	public action?: Ptr;

	public hovered?: Bool;

	constructor(
		content: Component | undefined = undefined,
		rowSpan: Uint | undefined = undefined,
		colSpan: Uint | undefined = undefined,
		alignment: Alignment | undefined = undefined,
		backgroundColor: Color | undefined = undefined,
		hoveredBackgroundColor: Color | undefined = undefined,
		padding: Padding | undefined = undefined,
		border: Border | undefined = undefined,
		action: Ptr | undefined = undefined,
		hovered: Bool | undefined = undefined
	) {
		this.content = content;
		this.rowSpan = rowSpan;
		this.colSpan = colSpan;
		this.alignment = alignment;
		this.backgroundColor = backgroundColor;
		this.hoveredBackgroundColor = hoveredBackgroundColor;
		this.padding = padding;
		this.border = border;
		this.action = action;
		this.hovered = hovered;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
						throw new Error(`unexpected length: ` + len);
					}
					this.content = unmarshal(reader) as Component;
					break;
				}
				case 2: {
					this.rowSpan = readInt(reader);
					break;
				}
				case 3: {
					this.colSpan = readInt(reader);
					break;
				}
				case 4: {
					this.alignment = readInt(reader);
					break;
				}
				case 5: {
					this.backgroundColor = readString(reader);
					break;
				}
				case 6: {
					this.hoveredBackgroundColor = readString(reader);
					break;
				}
				case 7: {
					this.padding = new Padding();
					this.padding.read(reader);
					break;
				}
				case 8: {
					this.border = new Border();
					this.border.read(reader);
					break;
				}
				case 9: {
					this.action = readInt(reader);
					break;
				}
				case 10: {
					this.hovered = readBool(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.content !== undefined && !this.content.isZero(),
			this.rowSpan !== undefined,
			this.colSpan !== undefined,
			this.alignment !== undefined,
			this.backgroundColor !== undefined,
			this.hoveredBackgroundColor !== undefined,
			this.padding !== undefined && !this.padding.isZero(),
			this.border !== undefined && !this.border.isZero(),
			this.action !== undefined,
			this.hovered !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			writer.writeByte(1);
			this.content.writeTypeHeader(writer);
			this.content!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			writeInt(writer, this.rowSpan!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			writeInt(writer, this.colSpan!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			writeInt(writer, this.alignment!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			writeString(writer, this.backgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 6);
			writeString(writer, this.hoveredBackgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.RECORD, 7);
			this.padding!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.RECORD, 8);
			this.border!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.UVARINT, 9);
			writeInt(writer, this.action!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.UVARINT, 10);
			writeBool(writer, this.hovered!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			(this.content === undefined || this.content.isZero()) &&
			this.rowSpan === undefined &&
			this.colSpan === undefined &&
			this.alignment === undefined &&
			this.backgroundColor === undefined &&
			this.hoveredBackgroundColor === undefined &&
			(this.padding === undefined || this.padding.isZero()) &&
			(this.border === undefined || this.border.isZero()) &&
			this.action === undefined &&
			this.hovered === undefined
		);
	}

	reset(): void {
		this.content = undefined;
		this.rowSpan = undefined;
		this.colSpan = undefined;
		this.alignment = undefined;
		this.backgroundColor = undefined;
		this.hoveredBackgroundColor = undefined;
		this.padding = undefined;
		this.border = undefined;
		this.action = undefined;
		this.hovered = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 97);
		return;
	}
}

export class TableColumn implements Writeable, Readable {
	public content?: Component;

	// Values higher than 1000 are clipped.
	public colSpan?: Uint;

	public width?: Length;

	public alignment?: Alignment;

	public cellBackgroundColor?: Color;

	public cellAction?: Ptr;

	public cellPadding?: Padding;

	public cellBorder?: Border;

	public cellHoveredBackgroundColor?: Color;

	public cellHovered?: Bool;

	constructor(
		content: Component | undefined = undefined,
		colSpan: Uint | undefined = undefined,
		width: Length | undefined = undefined,
		alignment: Alignment | undefined = undefined,
		cellBackgroundColor: Color | undefined = undefined,
		cellAction: Ptr | undefined = undefined,
		cellPadding: Padding | undefined = undefined,
		cellBorder: Border | undefined = undefined,
		cellHoveredBackgroundColor: Color | undefined = undefined,
		cellHovered: Bool | undefined = undefined
	) {
		this.content = content;
		this.colSpan = colSpan;
		this.width = width;
		this.alignment = alignment;
		this.cellBackgroundColor = cellBackgroundColor;
		this.cellAction = cellAction;
		this.cellPadding = cellPadding;
		this.cellBorder = cellBorder;
		this.cellHoveredBackgroundColor = cellHoveredBackgroundColor;
		this.cellHovered = cellHovered;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
						throw new Error(`unexpected length: ` + len);
					}
					this.content = unmarshal(reader) as Component;
					break;
				}
				case 2: {
					this.colSpan = readInt(reader);
					break;
				}
				case 3: {
					this.width = readString(reader);
					break;
				}
				case 4: {
					this.alignment = readInt(reader);
					break;
				}
				case 5: {
					this.cellBackgroundColor = readString(reader);
					break;
				}
				case 6: {
					this.cellAction = readInt(reader);
					break;
				}
				case 7: {
					this.cellPadding = new Padding();
					this.cellPadding.read(reader);
					break;
				}
				case 8: {
					this.cellBorder = new Border();
					this.cellBorder.read(reader);
					break;
				}
				case 9: {
					this.cellHoveredBackgroundColor = readString(reader);
					break;
				}
				case 10: {
					this.cellHovered = readBool(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.content !== undefined && !this.content.isZero(),
			this.colSpan !== undefined,
			this.width !== undefined,
			this.alignment !== undefined,
			this.cellBackgroundColor !== undefined,
			this.cellAction !== undefined,
			this.cellPadding !== undefined && !this.cellPadding.isZero(),
			this.cellBorder !== undefined && !this.cellBorder.isZero(),
			this.cellHoveredBackgroundColor !== undefined,
			this.cellHovered !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			writer.writeByte(1);
			this.content.writeTypeHeader(writer);
			this.content!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			writeInt(writer, this.colSpan!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			writeString(writer, this.width!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			writeInt(writer, this.alignment!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			writeString(writer, this.cellBackgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.UVARINT, 6);
			writeInt(writer, this.cellAction!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.RECORD, 7);
			this.cellPadding!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.RECORD, 8);
			this.cellBorder!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 9);
			writeString(writer, this.cellHoveredBackgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.UVARINT, 10);
			writeBool(writer, this.cellHovered!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			(this.content === undefined || this.content.isZero()) &&
			this.colSpan === undefined &&
			this.width === undefined &&
			this.alignment === undefined &&
			this.cellBackgroundColor === undefined &&
			this.cellAction === undefined &&
			(this.cellPadding === undefined || this.cellPadding.isZero()) &&
			(this.cellBorder === undefined || this.cellBorder.isZero()) &&
			this.cellHoveredBackgroundColor === undefined &&
			this.cellHovered === undefined
		);
	}

	reset(): void {
		this.content = undefined;
		this.colSpan = undefined;
		this.width = undefined;
		this.alignment = undefined;
		this.cellBackgroundColor = undefined;
		this.cellAction = undefined;
		this.cellPadding = undefined;
		this.cellBorder = undefined;
		this.cellHoveredBackgroundColor = undefined;
		this.cellHovered = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 98);
		return;
	}
}

export class TableRow implements Writeable, Readable {
	public cells?: TableCells;

	public height?: Length;

	public backgroundColor?: Color;

	public hoveredBackgroundColor?: Color;

	public action?: Ptr;

	public hovered?: Bool;

	constructor(
		cells: TableCells | undefined = undefined,
		height: Length | undefined = undefined,
		backgroundColor: Color | undefined = undefined,
		hoveredBackgroundColor: Color | undefined = undefined,
		action: Ptr | undefined = undefined,
		hovered: Bool | undefined = undefined
	) {
		this.cells = cells;
		this.height = height;
		this.backgroundColor = backgroundColor;
		this.hoveredBackgroundColor = hoveredBackgroundColor;
		this.action = action;
		this.hovered = hovered;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.cells = new TableCells();
					this.cells.read(reader);
					break;
				}
				case 2: {
					this.height = readString(reader);
					break;
				}
				case 3: {
					this.backgroundColor = readString(reader);
					break;
				}
				case 4: {
					this.hoveredBackgroundColor = readString(reader);
					break;
				}
				case 5: {
					this.action = readInt(reader);
					break;
				}
				case 6: {
					this.hovered = readBool(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.cells !== undefined && !this.cells.isZero(),
			this.height !== undefined,
			this.backgroundColor !== undefined,
			this.hoveredBackgroundColor !== undefined,
			this.action !== undefined,
			this.hovered !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			this.cells!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.height!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			writeString(writer, this.backgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			writeString(writer, this.hoveredBackgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.UVARINT, 5);
			writeInt(writer, this.action!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.UVARINT, 6);
			writeBool(writer, this.hovered!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			(this.cells === undefined || this.cells.isZero()) &&
			this.height === undefined &&
			this.backgroundColor === undefined &&
			this.hoveredBackgroundColor === undefined &&
			this.action === undefined &&
			this.hovered === undefined
		);
	}

	reset(): void {
		this.cells = undefined;
		this.height = undefined;
		this.backgroundColor = undefined;
		this.hoveredBackgroundColor = undefined;
		this.action = undefined;
		this.hovered = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 99);
		return;
	}
}

// TableHeader aggregates the optional header properties and defines columns from left to right. We are not assigning cells to columns by id, to lower the protocol overhead.
export class TableHeader implements Writeable, Readable {
	public columns?: TableColumns;

	constructor(columns: TableColumns | undefined = undefined) {
		this.columns = columns;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.columns = new TableColumns();
					this.columns.read(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.columns !== undefined && !this.columns.isZero()];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			this.columns!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.columns === undefined || this.columns.isZero();
	}

	reset(): void {
		this.columns = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 100);
		return;
	}
}

export class TableRows implements Writeable, Readable {
	public value: TableRow[];

	constructor(value: TableRow[] = []) {
		this.value = value;
	}

	isZero(): boolean {
		return !this.value || this.value.length === 0;
	}

	reset(): void {
		this.value = [];
	}

	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value.length); // Write the length of the array
		for (const c of this.value) {
			c.writeTypeHeader(writer); // Write the type header for each component)
			c.write(writer); // Write the component data

			//c.writeTypeHeader(writer); // Write the type header for each component
			//c.write(writer); // Write the component data
		}
	}

	read(reader: BinaryReader): void {
		const count = reader.readUvarint(); // Read the length of the array
		const values: TableRow[] = [];

		for (let i = 0; i < count; i++) {
			const obj = unmarshal(reader); // Read and unmarshal each component
			values.push(obj as any as TableRow); // Cast and add to the array
		}

		this.value = values;
	}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 101);
		return;
	}
}

export class TableCells implements Writeable, Readable {
	public value: TableCell[];

	constructor(value: TableCell[] = []) {
		this.value = value;
	}

	isZero(): boolean {
		return !this.value || this.value.length === 0;
	}

	reset(): void {
		this.value = [];
	}

	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value.length); // Write the length of the array
		for (const c of this.value) {
			c.writeTypeHeader(writer); // Write the type header for each component)
			c.write(writer); // Write the component data

			//c.writeTypeHeader(writer); // Write the type header for each component
			//c.write(writer); // Write the component data
		}
	}

	read(reader: BinaryReader): void {
		const count = reader.readUvarint(); // Read the length of the array
		const values: TableCell[] = [];

		for (let i = 0; i < count; i++) {
			const obj = unmarshal(reader); // Read and unmarshal each component
			values.push(obj as any as TableCell); // Cast and add to the array
		}

		this.value = values;
	}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 102);
		return;
	}
}

export class TableColumns implements Writeable, Readable {
	public value: TableColumn[];

	constructor(value: TableColumn[] = []) {
		this.value = value;
	}

	isZero(): boolean {
		return !this.value || this.value.length === 0;
	}

	reset(): void {
		this.value = [];
	}

	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value.length); // Write the length of the array
		for (const c of this.value) {
			c.writeTypeHeader(writer); // Write the type header for each component)
			c.write(writer); // Write the component data

			//c.writeTypeHeader(writer); // Write the type header for each component
			//c.write(writer); // Write the component data
		}
	}

	read(reader: BinaryReader): void {
		const count = reader.readUvarint(); // Read the length of the array
		const values: TableColumn[] = [];

		for (let i = 0; i < count; i++) {
			const obj = unmarshal(reader); // Read and unmarshal each component
			values.push(obj as any as TableColumn); // Cast and add to the array
		}

		this.value = values;
	}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 103);
		return;
	}
}

export class TextView implements Writeable, Readable, Component {
	public value?: Str;

	// Color denotes the text color. Leave empty, for the context sensitiv default theme color.
	public color?: Color;

	// BackgroundColor denotes the color of the text background. Leave empty, for the context sensitiv default theme color.
	public backgroundColor?: Color;

	public onClick?: Ptr;

	public onHoverStart?: Ptr;

	public onHoverEnd?: Ptr;

	public border?: Border;

	public padding?: Padding;

	public frame?: Frame;

	public accessibilityLabel?: Str;

	public font?: Font;

	public action?: Ptr;

	public textAlignment?: TextAlignment;

	public hoveredBackgroundColor?: Color;

	public pressedBackgroundColor?: Color;

	public focusedBackgroundColor?: Color;

	public hoveredBorder?: Border;

	public pressedBorder?: Border;

	public focusedBorder?: Border;

	public lineBreak?: Bool;

	public invisible?: Bool;

	public underline?: Bool;

	constructor(
		value: Str | undefined = undefined,
		color: Color | undefined = undefined,
		backgroundColor: Color | undefined = undefined,
		onClick: Ptr | undefined = undefined,
		onHoverStart: Ptr | undefined = undefined,
		onHoverEnd: Ptr | undefined = undefined,
		border: Border | undefined = undefined,
		padding: Padding | undefined = undefined,
		frame: Frame | undefined = undefined,
		accessibilityLabel: Str | undefined = undefined,
		font: Font | undefined = undefined,
		action: Ptr | undefined = undefined,
		textAlignment: TextAlignment | undefined = undefined,
		hoveredBackgroundColor: Color | undefined = undefined,
		pressedBackgroundColor: Color | undefined = undefined,
		focusedBackgroundColor: Color | undefined = undefined,
		hoveredBorder: Border | undefined = undefined,
		pressedBorder: Border | undefined = undefined,
		focusedBorder: Border | undefined = undefined,
		lineBreak: Bool | undefined = undefined,
		invisible: Bool | undefined = undefined,
		underline: Bool | undefined = undefined
	) {
		this.value = value;
		this.color = color;
		this.backgroundColor = backgroundColor;
		this.onClick = onClick;
		this.onHoverStart = onHoverStart;
		this.onHoverEnd = onHoverEnd;
		this.border = border;
		this.padding = padding;
		this.frame = frame;
		this.accessibilityLabel = accessibilityLabel;
		this.font = font;
		this.action = action;
		this.textAlignment = textAlignment;
		this.hoveredBackgroundColor = hoveredBackgroundColor;
		this.pressedBackgroundColor = pressedBackgroundColor;
		this.focusedBackgroundColor = focusedBackgroundColor;
		this.hoveredBorder = hoveredBorder;
		this.pressedBorder = pressedBorder;
		this.focusedBorder = focusedBorder;
		this.lineBreak = lineBreak;
		this.invisible = invisible;
		this.underline = underline;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.value = readString(reader);
					break;
				}
				case 2: {
					this.color = readString(reader);
					break;
				}
				case 3: {
					this.backgroundColor = readString(reader);
					break;
				}
				case 4: {
					this.onClick = readInt(reader);
					break;
				}
				case 5: {
					this.onHoverStart = readInt(reader);
					break;
				}
				case 6: {
					this.onHoverEnd = readInt(reader);
					break;
				}
				case 7: {
					this.border = new Border();
					this.border.read(reader);
					break;
				}
				case 8: {
					this.padding = new Padding();
					this.padding.read(reader);
					break;
				}
				case 9: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				case 10: {
					this.accessibilityLabel = readString(reader);
					break;
				}
				case 11: {
					this.font = new Font();
					this.font.read(reader);
					break;
				}
				case 12: {
					this.action = readInt(reader);
					break;
				}
				case 13: {
					this.textAlignment = readInt(reader);
					break;
				}
				case 14: {
					this.hoveredBackgroundColor = readString(reader);
					break;
				}
				case 15: {
					this.pressedBackgroundColor = readString(reader);
					break;
				}
				case 16: {
					this.focusedBackgroundColor = readString(reader);
					break;
				}
				case 17: {
					this.hoveredBorder = new Border();
					this.hoveredBorder.read(reader);
					break;
				}
				case 18: {
					this.pressedBorder = new Border();
					this.pressedBorder.read(reader);
					break;
				}
				case 19: {
					this.focusedBorder = new Border();
					this.focusedBorder.read(reader);
					break;
				}
				case 20: {
					this.lineBreak = readBool(reader);
					break;
				}
				case 21: {
					this.invisible = readBool(reader);
					break;
				}
				case 22: {
					this.underline = readBool(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.value !== undefined,
			this.color !== undefined,
			this.backgroundColor !== undefined,
			this.onClick !== undefined,
			this.onHoverStart !== undefined,
			this.onHoverEnd !== undefined,
			this.border !== undefined && !this.border.isZero(),
			this.padding !== undefined && !this.padding.isZero(),
			this.frame !== undefined && !this.frame.isZero(),
			this.accessibilityLabel !== undefined,
			this.font !== undefined && !this.font.isZero(),
			this.action !== undefined,
			this.textAlignment !== undefined,
			this.hoveredBackgroundColor !== undefined,
			this.pressedBackgroundColor !== undefined,
			this.focusedBackgroundColor !== undefined,
			this.hoveredBorder !== undefined && !this.hoveredBorder.isZero(),
			this.pressedBorder !== undefined && !this.pressedBorder.isZero(),
			this.focusedBorder !== undefined && !this.focusedBorder.isZero(),
			this.lineBreak !== undefined,
			this.invisible !== undefined,
			this.underline !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.value!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.color!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			writeString(writer, this.backgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			writeInt(writer, this.onClick!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.UVARINT, 5);
			writeInt(writer, this.onHoverStart!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.UVARINT, 6);
			writeInt(writer, this.onHoverEnd!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.RECORD, 7);
			this.border!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.RECORD, 8);
			this.padding!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.RECORD, 9);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 10);
			writeString(writer, this.accessibilityLabel!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[11]) {
			writer.writeFieldHeader(Shapes.RECORD, 11);
			this.font!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[12]) {
			writer.writeFieldHeader(Shapes.UVARINT, 12);
			writeInt(writer, this.action!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[13]) {
			writer.writeFieldHeader(Shapes.UVARINT, 13);
			writeInt(writer, this.textAlignment!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[14]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 14);
			writeString(writer, this.hoveredBackgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[15]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 15);
			writeString(writer, this.pressedBackgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[16]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 16);
			writeString(writer, this.focusedBackgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[17]) {
			writer.writeFieldHeader(Shapes.RECORD, 17);
			this.hoveredBorder!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[18]) {
			writer.writeFieldHeader(Shapes.RECORD, 18);
			this.pressedBorder!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[19]) {
			writer.writeFieldHeader(Shapes.RECORD, 19);
			this.focusedBorder!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[20]) {
			writer.writeFieldHeader(Shapes.UVARINT, 20);
			writeBool(writer, this.lineBreak!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[21]) {
			writer.writeFieldHeader(Shapes.UVARINT, 21);
			writeBool(writer, this.invisible!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[22]) {
			writer.writeFieldHeader(Shapes.UVARINT, 22);
			writeBool(writer, this.underline!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.value === undefined &&
			this.color === undefined &&
			this.backgroundColor === undefined &&
			this.onClick === undefined &&
			this.onHoverStart === undefined &&
			this.onHoverEnd === undefined &&
			(this.border === undefined || this.border.isZero()) &&
			(this.padding === undefined || this.padding.isZero()) &&
			(this.frame === undefined || this.frame.isZero()) &&
			this.accessibilityLabel === undefined &&
			(this.font === undefined || this.font.isZero()) &&
			this.action === undefined &&
			this.textAlignment === undefined &&
			this.hoveredBackgroundColor === undefined &&
			this.pressedBackgroundColor === undefined &&
			this.focusedBackgroundColor === undefined &&
			(this.hoveredBorder === undefined || this.hoveredBorder.isZero()) &&
			(this.pressedBorder === undefined || this.pressedBorder.isZero()) &&
			(this.focusedBorder === undefined || this.focusedBorder.isZero()) &&
			this.lineBreak === undefined &&
			this.invisible === undefined &&
			this.underline === undefined
		);
	}

	reset(): void {
		this.value = undefined;
		this.color = undefined;
		this.backgroundColor = undefined;
		this.onClick = undefined;
		this.onHoverStart = undefined;
		this.onHoverEnd = undefined;
		this.border = undefined;
		this.padding = undefined;
		this.frame = undefined;
		this.accessibilityLabel = undefined;
		this.font = undefined;
		this.action = undefined;
		this.textAlignment = undefined;
		this.hoveredBackgroundColor = undefined;
		this.pressedBackgroundColor = undefined;
		this.focusedBackgroundColor = undefined;
		this.hoveredBorder = undefined;
		this.pressedBorder = undefined;
		this.focusedBorder = undefined;
		this.lineBreak = undefined;
		this.invisible = undefined;
		this.underline = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 104);
		return;
	}
	isComponent(): void {}
}

export type TextAlignment = number;
function writeTypeHeaderTextAlignment(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 105);
	return;
}
// companion enum containing all defined constants for TextAlignment
export enum TextAlignmentValues {
	TextAlignInherit = 0,
	TextAlignStart = 1,
	TextAlignEnd = 2,
	TextAlignCenter = 3,
	TextAlignJustify = 4,
}

export class TextField implements Writeable, Readable, Component {
	public label?: Str;

	public supportingText?: Str;

	// ErrorText is shown instead of SupportingText, even if they are (today) independent
	public errorText?: Str;

	// Value contains the text, which shall be shown.
	public value?: Str;

	public frame?: Frame;

	// InputValue is a binding to a state, into which the frontend will the user entered text. This is the pointer a State.
	public inputValue?: Ptr;

	// Style to apply. Use TextFieldReduced in forms where many textfields cause too much visual noise and you need to reduce it. By default, the TextFieldOutlined is applied.
	public style?: TextFieldStyle;

	// Leading shows the given component usually at the left (or right if RTL). This can be used for additional symbols like a magnifying glass for searching.
	public leading?: Component;

	// Trailing show the given component usually at the right (or left if RTL mode). If set, the clear (or x button) must not be shown, to reduce distraction. This can be used for an Info button or a text showing a value unit.
	public trailing?: Component;

	// DebounceTime is in nanoseconds. A zero or omitted value means to enable debounce default logic.
	public debounceTime?: Duration;

	// Lines enforces a single line if <= 0, otherwise it shows the amount of text lines within a text area.
	public lines?: Uint;

	public keyboardOptions?: KeyboardOptions;

	public disabled?: Bool;

	public disableAutocomplete?: Bool;

	// DisableDebounce must be set to true, to disable the default debouncer logic. This will cause a render roundtrip for each keystroke, so be careful not to break the server or cause UX issues due to UI latencies.
	public disableDebounce?: Bool;

	public invisible?: Bool;

	// If Revealed the password is shown
	public revealed?: Bool;

	// Id represents an optional identifier to locate this component within the view tree. It must be either empty or unique within the entire tree instance.
	public id?: Str;

	public keydownEnter?: Ptr;

	constructor(
		label: Str | undefined = undefined,
		supportingText: Str | undefined = undefined,
		errorText: Str | undefined = undefined,
		value: Str | undefined = undefined,
		frame: Frame | undefined = undefined,
		inputValue: Ptr | undefined = undefined,
		style: TextFieldStyle | undefined = undefined,
		leading: Component | undefined = undefined,
		trailing: Component | undefined = undefined,
		debounceTime: Duration | undefined = undefined,
		lines: Uint | undefined = undefined,
		keyboardOptions: KeyboardOptions | undefined = undefined,
		disabled: Bool | undefined = undefined,
		disableAutocomplete: Bool | undefined = undefined,
		disableDebounce: Bool | undefined = undefined,
		invisible: Bool | undefined = undefined,
		revealed: Bool | undefined = undefined,
		id: Str | undefined = undefined,
		keydownEnter: Ptr | undefined = undefined
	) {
		this.label = label;
		this.supportingText = supportingText;
		this.errorText = errorText;
		this.value = value;
		this.frame = frame;
		this.inputValue = inputValue;
		this.style = style;
		this.leading = leading;
		this.trailing = trailing;
		this.debounceTime = debounceTime;
		this.lines = lines;
		this.keyboardOptions = keyboardOptions;
		this.disabled = disabled;
		this.disableAutocomplete = disableAutocomplete;
		this.disableDebounce = disableDebounce;
		this.invisible = invisible;
		this.revealed = revealed;
		this.id = id;
		this.keydownEnter = keydownEnter;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.label = readString(reader);
					break;
				}
				case 2: {
					this.supportingText = readString(reader);
					break;
				}
				case 3: {
					this.errorText = readString(reader);
					break;
				}
				case 4: {
					this.value = readString(reader);
					break;
				}
				case 5: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				case 6: {
					this.inputValue = readInt(reader);
					break;
				}
				case 7: {
					this.style = readInt(reader);
					break;
				}
				case 8: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
						throw new Error(`unexpected length: ` + len);
					}
					this.leading = unmarshal(reader) as Component;
					break;
				}
				case 9: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
						throw new Error(`unexpected length: ` + len);
					}
					this.trailing = unmarshal(reader) as Component;
					break;
				}
				case 10: {
					this.debounceTime = readInt(reader);
					break;
				}
				case 11: {
					this.lines = readInt(reader);
					break;
				}
				case 12: {
					this.keyboardOptions = new KeyboardOptions();
					this.keyboardOptions.read(reader);
					break;
				}
				case 13: {
					this.disabled = readBool(reader);
					break;
				}
				case 14: {
					this.disableAutocomplete = readBool(reader);
					break;
				}
				case 15: {
					this.disableDebounce = readBool(reader);
					break;
				}
				case 16: {
					this.invisible = readBool(reader);
					break;
				}
				case 17: {
					this.revealed = readBool(reader);
					break;
				}
				case 18: {
					this.id = readString(reader);
					break;
				}
				case 19: {
					this.keydownEnter = readInt(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.label !== undefined,
			this.supportingText !== undefined,
			this.errorText !== undefined,
			this.value !== undefined,
			this.frame !== undefined && !this.frame.isZero(),
			this.inputValue !== undefined,
			this.style !== undefined,
			this.leading !== undefined && !this.leading.isZero(),
			this.trailing !== undefined && !this.trailing.isZero(),
			this.debounceTime !== undefined,
			this.lines !== undefined,
			this.keyboardOptions !== undefined && !this.keyboardOptions.isZero(),
			this.disabled !== undefined,
			this.disableAutocomplete !== undefined,
			this.disableDebounce !== undefined,
			this.invisible !== undefined,
			this.revealed !== undefined,
			this.id !== undefined,
			this.keydownEnter !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.label!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.supportingText!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			writeString(writer, this.errorText!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			writeString(writer, this.value!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.RECORD, 5);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.UVARINT, 6);
			writeInt(writer, this.inputValue!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.UVARINT, 7);
			writeInt(writer, this.style!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[8]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 8);
			writer.writeByte(1);
			this.leading.writeTypeHeader(writer);
			this.leading!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[9]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 9);
			writer.writeByte(1);
			this.trailing.writeTypeHeader(writer);
			this.trailing!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.UVARINT, 10);
			writeInt(writer, this.debounceTime!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[11]) {
			writer.writeFieldHeader(Shapes.UVARINT, 11);
			writeInt(writer, this.lines!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[12]) {
			writer.writeFieldHeader(Shapes.RECORD, 12);
			this.keyboardOptions!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[13]) {
			writer.writeFieldHeader(Shapes.UVARINT, 13);
			writeBool(writer, this.disabled!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[14]) {
			writer.writeFieldHeader(Shapes.UVARINT, 14);
			writeBool(writer, this.disableAutocomplete!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[15]) {
			writer.writeFieldHeader(Shapes.UVARINT, 15);
			writeBool(writer, this.disableDebounce!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[16]) {
			writer.writeFieldHeader(Shapes.UVARINT, 16);
			writeBool(writer, this.invisible!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[17]) {
			writer.writeFieldHeader(Shapes.UVARINT, 17);
			writeBool(writer, this.revealed!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[18]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 18);
			writeString(writer, this.id!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[19]) {
			writer.writeFieldHeader(Shapes.UVARINT, 19);
			writeInt(writer, this.keydownEnter!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.label === undefined &&
			this.supportingText === undefined &&
			this.errorText === undefined &&
			this.value === undefined &&
			(this.frame === undefined || this.frame.isZero()) &&
			this.inputValue === undefined &&
			this.style === undefined &&
			(this.leading === undefined || this.leading.isZero()) &&
			(this.trailing === undefined || this.trailing.isZero()) &&
			this.debounceTime === undefined &&
			this.lines === undefined &&
			(this.keyboardOptions === undefined || this.keyboardOptions.isZero()) &&
			this.disabled === undefined &&
			this.disableAutocomplete === undefined &&
			this.disableDebounce === undefined &&
			this.invisible === undefined &&
			this.revealed === undefined &&
			this.id === undefined &&
			this.keydownEnter === undefined
		);
	}

	reset(): void {
		this.label = undefined;
		this.supportingText = undefined;
		this.errorText = undefined;
		this.value = undefined;
		this.frame = undefined;
		this.inputValue = undefined;
		this.style = undefined;
		this.leading = undefined;
		this.trailing = undefined;
		this.debounceTime = undefined;
		this.lines = undefined;
		this.keyboardOptions = undefined;
		this.disabled = undefined;
		this.disableAutocomplete = undefined;
		this.disableDebounce = undefined;
		this.invisible = undefined;
		this.revealed = undefined;
		this.id = undefined;
		this.keydownEnter = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 106);
		return;
	}
	isComponent(): void {}
}

// Toggle is just a kind of checkbox without a label. However, a toggle shall be used for immediate activation functions. In contrast to that, use a checkbox for form things without an immediate effect.
export class Toggle implements Writeable, Readable, Component {
	// InputValue is where updated value of the checked states are written.
	public inputValue?: Ptr;

	public value?: Bool;

	public disabled?: Bool;

	public invisible?: Bool;

	constructor(
		inputValue: Ptr | undefined = undefined,
		value: Bool | undefined = undefined,
		disabled: Bool | undefined = undefined,
		invisible: Bool | undefined = undefined
	) {
		this.inputValue = inputValue;
		this.value = value;
		this.disabled = disabled;
		this.invisible = invisible;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.inputValue = readInt(reader);
					break;
				}
				case 2: {
					this.value = readBool(reader);
					break;
				}
				case 3: {
					this.disabled = readBool(reader);
					break;
				}
				case 4: {
					this.invisible = readBool(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.inputValue !== undefined,
			this.value !== undefined,
			this.disabled !== undefined,
			this.invisible !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			writeInt(writer, this.inputValue!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			writeBool(writer, this.value!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			writeBool(writer, this.disabled!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			writeBool(writer, this.invisible!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.inputValue === undefined &&
			this.value === undefined &&
			this.disabled === undefined &&
			this.invisible === undefined
		);
	}

	reset(): void {
		this.inputValue = undefined;
		this.value = undefined;
		this.disabled = undefined;
		this.invisible = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 107);
		return;
	}
	isComponent(): void {}
}

// A TextLayout places its content like a native Text would layout its words, using the same rules for word wrap
// and alignments. This allows to style inline-components individually. SwiftUI can do this using + on
// Text and Images. Jetpack has the concept of annotated strings.
export class TextLayout implements Writeable, Readable, Component {
	public children?: Components;

	public border?: Border;

	public frame?: Frame;

	public backgroundColor?: Color;

	public padding?: Padding;

	public accessibilityLabel?: Str;

	public font?: Font;

	public action?: Ptr;

	public textAlignment?: TextAlignment;

	public invisible?: Bool;

	constructor(
		children: Components | undefined = undefined,
		border: Border | undefined = undefined,
		frame: Frame | undefined = undefined,
		backgroundColor: Color | undefined = undefined,
		padding: Padding | undefined = undefined,
		accessibilityLabel: Str | undefined = undefined,
		font: Font | undefined = undefined,
		action: Ptr | undefined = undefined,
		textAlignment: TextAlignment | undefined = undefined,
		invisible: Bool | undefined = undefined
	) {
		this.children = children;
		this.border = border;
		this.frame = frame;
		this.backgroundColor = backgroundColor;
		this.padding = padding;
		this.accessibilityLabel = accessibilityLabel;
		this.font = font;
		this.action = action;
		this.textAlignment = textAlignment;
		this.invisible = invisible;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.children = new Components();
					this.children.read(reader);
					break;
				}
				case 2: {
					this.border = new Border();
					this.border.read(reader);
					break;
				}
				case 3: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				case 4: {
					this.backgroundColor = readString(reader);
					break;
				}
				case 5: {
					this.padding = new Padding();
					this.padding.read(reader);
					break;
				}
				case 6: {
					this.accessibilityLabel = readString(reader);
					break;
				}
				case 7: {
					this.font = new Font();
					this.font.read(reader);
					break;
				}
				case 8: {
					this.action = readInt(reader);
					break;
				}
				case 9: {
					this.textAlignment = readInt(reader);
					break;
				}
				case 10: {
					this.invisible = readBool(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.children !== undefined && !this.children.isZero(),
			this.border !== undefined && !this.border.isZero(),
			this.frame !== undefined && !this.frame.isZero(),
			this.backgroundColor !== undefined,
			this.padding !== undefined && !this.padding.isZero(),
			this.accessibilityLabel !== undefined,
			this.font !== undefined && !this.font.isZero(),
			this.action !== undefined,
			this.textAlignment !== undefined,
			this.invisible !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			this.children!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.RECORD, 2);
			this.border!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.RECORD, 3);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			writeString(writer, this.backgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.RECORD, 5);
			this.padding!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 6);
			writeString(writer, this.accessibilityLabel!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.RECORD, 7);
			this.font!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.UVARINT, 8);
			writeInt(writer, this.action!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.UVARINT, 9);
			writeInt(writer, this.textAlignment!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.UVARINT, 10);
			writeBool(writer, this.invisible!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			(this.children === undefined || this.children.isZero()) &&
			(this.border === undefined || this.border.isZero()) &&
			(this.frame === undefined || this.frame.isZero()) &&
			this.backgroundColor === undefined &&
			(this.padding === undefined || this.padding.isZero()) &&
			this.accessibilityLabel === undefined &&
			(this.font === undefined || this.font.isZero()) &&
			this.action === undefined &&
			this.textAlignment === undefined &&
			this.invisible === undefined
		);
	}

	reset(): void {
		this.children = undefined;
		this.border = undefined;
		this.frame = undefined;
		this.backgroundColor = undefined;
		this.padding = undefined;
		this.accessibilityLabel = undefined;
		this.font = undefined;
		this.action = undefined;
		this.textAlignment = undefined;
		this.invisible = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 108);
		return;
	}
	isComponent(): void {}
}

// An VStack aligns children elements in a vertical column.
//  - the intrinsic component dimensions are the sum of all sizes of the contained children
//  - the parent can define a custom width and height
//  - if the container is larger than the contained views, it must center vertical or horizontal
//  - the inner gap between components should be around 2dp
export class VStack implements Writeable, Readable, Component {
	public children?: Components;

	public gap?: Length;

	public frame?: Frame;

	// Zero value of Alignment is Center (=c) must be applied.
	public alignment?: Alignment;

	public backgroundColor?: Color;

	public padding?: Padding;

	// see also https://www.w3.org/WAI/tutorials/images/decision-tree/
	public accessibilityLabel?: Str;

	public border?: Border;

	public font?: Font;

	public action?: Ptr;

	public hoveredBackgroundColor?: Color;

	public pressedBackgroundColor?: Color;

	public focusedBackgroundColor?: Color;

	public hoveredBorder?: Border;

	public pressedBorder?: Border;

	public focusedBorder?: Border;

	public stylePreset?: StylePreset;

	public position?: Position;

	public disabled?: Bool;

	public invisible?: Bool;

	// Id represents an optional identifier to locate this component within the view tree. It must be either empty or unique within the entire tree instance.
	public id?: Str;

	public textColor?: Color;

	public noClip?: Bool;

	constructor(
		children: Components | undefined = undefined,
		gap: Length | undefined = undefined,
		frame: Frame | undefined = undefined,
		alignment: Alignment | undefined = undefined,
		backgroundColor: Color | undefined = undefined,
		padding: Padding | undefined = undefined,
		accessibilityLabel: Str | undefined = undefined,
		border: Border | undefined = undefined,
		font: Font | undefined = undefined,
		action: Ptr | undefined = undefined,
		hoveredBackgroundColor: Color | undefined = undefined,
		pressedBackgroundColor: Color | undefined = undefined,
		focusedBackgroundColor: Color | undefined = undefined,
		hoveredBorder: Border | undefined = undefined,
		pressedBorder: Border | undefined = undefined,
		focusedBorder: Border | undefined = undefined,
		stylePreset: StylePreset | undefined = undefined,
		position: Position | undefined = undefined,
		disabled: Bool | undefined = undefined,
		invisible: Bool | undefined = undefined,
		id: Str | undefined = undefined,
		textColor: Color | undefined = undefined,
		noClip: Bool | undefined = undefined
	) {
		this.children = children;
		this.gap = gap;
		this.frame = frame;
		this.alignment = alignment;
		this.backgroundColor = backgroundColor;
		this.padding = padding;
		this.accessibilityLabel = accessibilityLabel;
		this.border = border;
		this.font = font;
		this.action = action;
		this.hoveredBackgroundColor = hoveredBackgroundColor;
		this.pressedBackgroundColor = pressedBackgroundColor;
		this.focusedBackgroundColor = focusedBackgroundColor;
		this.hoveredBorder = hoveredBorder;
		this.pressedBorder = pressedBorder;
		this.focusedBorder = focusedBorder;
		this.stylePreset = stylePreset;
		this.position = position;
		this.disabled = disabled;
		this.invisible = invisible;
		this.id = id;
		this.textColor = textColor;
		this.noClip = noClip;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.children = new Components();
					this.children.read(reader);
					break;
				}
				case 2: {
					this.gap = readString(reader);
					break;
				}
				case 3: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				case 4: {
					this.alignment = readInt(reader);
					break;
				}
				case 5: {
					this.backgroundColor = readString(reader);
					break;
				}
				case 6: {
					this.padding = new Padding();
					this.padding.read(reader);
					break;
				}
				case 7: {
					this.accessibilityLabel = readString(reader);
					break;
				}
				case 8: {
					this.border = new Border();
					this.border.read(reader);
					break;
				}
				case 9: {
					this.font = new Font();
					this.font.read(reader);
					break;
				}
				case 10: {
					this.action = readInt(reader);
					break;
				}
				case 11: {
					this.hoveredBackgroundColor = readString(reader);
					break;
				}
				case 12: {
					this.pressedBackgroundColor = readString(reader);
					break;
				}
				case 13: {
					this.focusedBackgroundColor = readString(reader);
					break;
				}
				case 14: {
					this.hoveredBorder = new Border();
					this.hoveredBorder.read(reader);
					break;
				}
				case 15: {
					this.pressedBorder = new Border();
					this.pressedBorder.read(reader);
					break;
				}
				case 16: {
					this.focusedBorder = new Border();
					this.focusedBorder.read(reader);
					break;
				}
				case 17: {
					this.stylePreset = readInt(reader);
					break;
				}
				case 18: {
					this.position = new Position();
					this.position.read(reader);
					break;
				}
				case 19: {
					this.disabled = readBool(reader);
					break;
				}
				case 20: {
					this.invisible = readBool(reader);
					break;
				}
				case 21: {
					this.id = readString(reader);
					break;
				}
				case 22: {
					this.textColor = readString(reader);
					break;
				}
				case 23: {
					this.noClip = readBool(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.children !== undefined && !this.children.isZero(),
			this.gap !== undefined,
			this.frame !== undefined && !this.frame.isZero(),
			this.alignment !== undefined,
			this.backgroundColor !== undefined,
			this.padding !== undefined && !this.padding.isZero(),
			this.accessibilityLabel !== undefined,
			this.border !== undefined && !this.border.isZero(),
			this.font !== undefined && !this.font.isZero(),
			this.action !== undefined,
			this.hoveredBackgroundColor !== undefined,
			this.pressedBackgroundColor !== undefined,
			this.focusedBackgroundColor !== undefined,
			this.hoveredBorder !== undefined && !this.hoveredBorder.isZero(),
			this.pressedBorder !== undefined && !this.pressedBorder.isZero(),
			this.focusedBorder !== undefined && !this.focusedBorder.isZero(),
			this.stylePreset !== undefined,
			this.position !== undefined && !this.position.isZero(),
			this.disabled !== undefined,
			this.invisible !== undefined,
			this.id !== undefined,
			this.textColor !== undefined,
			this.noClip !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			this.children!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.gap!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.RECORD, 3);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			writeInt(writer, this.alignment!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			writeString(writer, this.backgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.RECORD, 6);
			this.padding!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 7);
			writeString(writer, this.accessibilityLabel!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.RECORD, 8);
			this.border!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.RECORD, 9);
			this.font!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.UVARINT, 10);
			writeInt(writer, this.action!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[11]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 11);
			writeString(writer, this.hoveredBackgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[12]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 12);
			writeString(writer, this.pressedBackgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[13]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 13);
			writeString(writer, this.focusedBackgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[14]) {
			writer.writeFieldHeader(Shapes.RECORD, 14);
			this.hoveredBorder!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[15]) {
			writer.writeFieldHeader(Shapes.RECORD, 15);
			this.pressedBorder!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[16]) {
			writer.writeFieldHeader(Shapes.RECORD, 16);
			this.focusedBorder!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[17]) {
			writer.writeFieldHeader(Shapes.UVARINT, 17);
			writeInt(writer, this.stylePreset!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[18]) {
			writer.writeFieldHeader(Shapes.RECORD, 18);
			this.position!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[19]) {
			writer.writeFieldHeader(Shapes.UVARINT, 19);
			writeBool(writer, this.disabled!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[20]) {
			writer.writeFieldHeader(Shapes.UVARINT, 20);
			writeBool(writer, this.invisible!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[21]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 21);
			writeString(writer, this.id!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[22]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 22);
			writeString(writer, this.textColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[23]) {
			writer.writeFieldHeader(Shapes.UVARINT, 23);
			writeBool(writer, this.noClip!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			(this.children === undefined || this.children.isZero()) &&
			this.gap === undefined &&
			(this.frame === undefined || this.frame.isZero()) &&
			this.alignment === undefined &&
			this.backgroundColor === undefined &&
			(this.padding === undefined || this.padding.isZero()) &&
			this.accessibilityLabel === undefined &&
			(this.border === undefined || this.border.isZero()) &&
			(this.font === undefined || this.font.isZero()) &&
			this.action === undefined &&
			this.hoveredBackgroundColor === undefined &&
			this.pressedBackgroundColor === undefined &&
			this.focusedBackgroundColor === undefined &&
			(this.hoveredBorder === undefined || this.hoveredBorder.isZero()) &&
			(this.pressedBorder === undefined || this.pressedBorder.isZero()) &&
			(this.focusedBorder === undefined || this.focusedBorder.isZero()) &&
			this.stylePreset === undefined &&
			(this.position === undefined || this.position.isZero()) &&
			this.disabled === undefined &&
			this.invisible === undefined &&
			this.id === undefined &&
			this.textColor === undefined &&
			this.noClip === undefined
		);
	}

	reset(): void {
		this.children = undefined;
		this.gap = undefined;
		this.frame = undefined;
		this.alignment = undefined;
		this.backgroundColor = undefined;
		this.padding = undefined;
		this.accessibilityLabel = undefined;
		this.border = undefined;
		this.font = undefined;
		this.action = undefined;
		this.hoveredBackgroundColor = undefined;
		this.pressedBackgroundColor = undefined;
		this.focusedBackgroundColor = undefined;
		this.hoveredBorder = undefined;
		this.pressedBorder = undefined;
		this.focusedBorder = undefined;
		this.stylePreset = undefined;
		this.position = undefined;
		this.disabled = undefined;
		this.invisible = undefined;
		this.id = undefined;
		this.textColor = undefined;
		this.noClip = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 109);
		return;
	}
	isComponent(): void {}
}

export class WebView implements Writeable, Readable, Component {
	public uRI?: URI;

	public frame?: Frame;

	constructor(uRI: URI | undefined = undefined, frame: Frame | undefined = undefined) {
		this.uRI = uRI;
		this.frame = frame;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.uRI = readString(reader);
					break;
				}
				case 2: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.uRI !== undefined, this.frame !== undefined && !this.frame.isZero()];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.uRI!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.RECORD, 2);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.uRI === undefined && (this.frame === undefined || this.frame.isZero());
	}

	reset(): void {
		this.uRI = undefined;
		this.frame = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 110);
		return;
	}
	isComponent(): void {}
}

// WindowInfoChanged is raised by the frontend whenever the window metrics changed in a significant way. It is not guaranteed that every pixel change will trigger such an event. However, a frontend must guarantee to send such an event if the WindowSizeClass is changed.
export class WindowInfoChanged implements Writeable, Readable, NagoEvent {
	public windowInfo?: WindowInfo;

	public rID?: RID;

	constructor(windowInfo: WindowInfo | undefined = undefined, rID: RID | undefined = undefined) {
		this.windowInfo = windowInfo;
		this.rID = rID;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.windowInfo = new WindowInfo();
					this.windowInfo.read(reader);
					break;
				}
				case 2: {
					this.rID = readInt(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.windowInfo !== undefined && !this.windowInfo.isZero(), this.rID !== undefined];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.RECORD, 1);
			this.windowInfo!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			writeInt(writer, this.rID!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (this.windowInfo === undefined || this.windowInfo.isZero()) && this.rID === undefined;
	}

	reset(): void {
		this.windowInfo = undefined;
		this.rID = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 111);
		return;
	}
	isNagoEvent(): void {}
}

// UpdateStateValue2Requested is raised from the frontend to update at most 2 state values hold by the backend. It can also immediately invoke a function callback in the same cycle.
export class UpdateStateValues2Requested implements Writeable, Readable, NagoEvent {
	public statePtr0?: Ptr;

	public value0?: Str;

	public statePtr1?: Ptr;

	public value1?: Str;

	// A FunctionPointer is invoked, if not zero.
	public functionPointer?: Ptr;

	public rID?: RID;

	constructor(
		statePtr0: Ptr | undefined = undefined,
		value0: Str | undefined = undefined,
		statePtr1: Ptr | undefined = undefined,
		value1: Str | undefined = undefined,
		functionPointer: Ptr | undefined = undefined,
		rID: RID | undefined = undefined
	) {
		this.statePtr0 = statePtr0;
		this.value0 = value0;
		this.statePtr1 = statePtr1;
		this.value1 = value1;
		this.functionPointer = functionPointer;
		this.rID = rID;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.statePtr0 = readInt(reader);
					break;
				}
				case 2: {
					this.value0 = readString(reader);
					break;
				}
				case 3: {
					this.statePtr1 = readInt(reader);
					break;
				}
				case 4: {
					this.value1 = readString(reader);
					break;
				}
				case 5: {
					this.functionPointer = readInt(reader);
					break;
				}
				case 6: {
					this.rID = readInt(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.statePtr0 !== undefined,
			this.value0 !== undefined,
			this.statePtr1 !== undefined,
			this.value1 !== undefined,
			this.functionPointer !== undefined,
			this.rID !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			writeInt(writer, this.statePtr0!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.value0!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			writeInt(writer, this.statePtr1!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			writeString(writer, this.value1!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.UVARINT, 5);
			writeInt(writer, this.functionPointer!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.UVARINT, 6);
			writeInt(writer, this.rID!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.statePtr0 === undefined &&
			this.value0 === undefined &&
			this.statePtr1 === undefined &&
			this.value1 === undefined &&
			this.functionPointer === undefined &&
			this.rID === undefined
		);
	}

	reset(): void {
		this.statePtr0 = undefined;
		this.value0 = undefined;
		this.statePtr1 = undefined;
		this.value1 = undefined;
		this.functionPointer = undefined;
		this.rID = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 112);
		return;
	}
	isNagoEvent(): void {}
}

// OpenHttpLink triggers the system open link call.
export class OpenHttpLink implements Writeable, Readable, NagoEvent {
	public url?: URI;

	public target?: Str;

	constructor(url: URI | undefined = undefined, target: Str | undefined = undefined) {
		this.url = url;
		this.target = target;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.url = readString(reader);
					break;
				}
				case 2: {
					this.target = readString(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.url !== undefined, this.target !== undefined];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.url!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.target!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.url === undefined && this.target === undefined;
	}

	reset(): void {
		this.url = undefined;
		this.target = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 113);
		return;
	}
	isNagoEvent(): void {}
}

// OpenHttpFlow starts a http redirect flow process using the specified fields.
export class OpenHttpFlow implements Writeable, Readable, NagoEvent {
	public url?: URI;

	public redirectTarget?: Str;

	public redirectNavigation?: Str;

	public session?: Str;

	constructor(
		url: URI | undefined = undefined,
		redirectTarget: Str | undefined = undefined,
		redirectNavigation: Str | undefined = undefined,
		session: Str | undefined = undefined
	) {
		this.url = url;
		this.redirectTarget = redirectTarget;
		this.redirectNavigation = redirectNavigation;
		this.session = session;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.url = readString(reader);
					break;
				}
				case 2: {
					this.redirectTarget = readString(reader);
					break;
				}
				case 3: {
					this.redirectNavigation = readString(reader);
					break;
				}
				case 4: {
					this.session = readString(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.url !== undefined,
			this.redirectTarget !== undefined,
			this.redirectNavigation !== undefined,
			this.session !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.url!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.redirectTarget!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			writeString(writer, this.redirectNavigation!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			writeString(writer, this.session!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.url === undefined &&
			this.redirectTarget === undefined &&
			this.redirectNavigation === undefined &&
			this.session === undefined
		);
	}

	reset(): void {
		this.url = undefined;
		this.redirectTarget = undefined;
		this.redirectNavigation = undefined;
		this.session = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 114);
		return;
	}
	isNagoEvent(): void {}
}

export class ClipboardWriteTextRequested implements Writeable, Readable, NagoEvent {
	public text?: Str;

	constructor(text: Str | undefined = undefined) {
		this.text = text;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.text = readString(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.text !== undefined];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.text!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.text === undefined;
	}

	reset(): void {
		this.text = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 115);
		return;
	}
	isNagoEvent(): void {}
}

export class Menu implements Writeable, Readable, Component {
	public anchor?: Component;

	public groups?: MenuGroups;

	public frame?: Frame;

	constructor(
		anchor: Component | undefined = undefined,
		groups: MenuGroups | undefined = undefined,
		frame: Frame | undefined = undefined
	) {
		this.anchor = anchor;
		this.groups = groups;
		this.frame = frame;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
						throw new Error(`unexpected length: ` + len);
					}
					this.anchor = unmarshal(reader) as Component;
					break;
				}
				case 2: {
					this.groups = new MenuGroups();
					this.groups.read(reader);
					break;
				}
				case 3: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.anchor !== undefined && !this.anchor.isZero(),
			this.groups !== undefined && !this.groups.isZero(),
			this.frame !== undefined && !this.frame.isZero(),
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			writer.writeByte(1);
			this.anchor.writeTypeHeader(writer);
			this.anchor!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.ARRAY, 2);
			this.groups!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.RECORD, 3);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			(this.anchor === undefined || this.anchor.isZero()) &&
			(this.groups === undefined || this.groups.isZero()) &&
			(this.frame === undefined || this.frame.isZero())
		);
	}

	reset(): void {
		this.anchor = undefined;
		this.groups = undefined;
		this.frame = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 116);
		return;
	}
	isComponent(): void {}
}

export class MenuGroup implements Writeable, Readable {
	public items?: MenuItems;

	constructor(items: MenuItems | undefined = undefined) {
		this.items = items;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.items = new MenuItems();
					this.items.read(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.items !== undefined && !this.items.isZero()];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			this.items!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.items === undefined || this.items.isZero();
	}

	reset(): void {
		this.items = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 117);
		return;
	}
}

export class MenuItem implements Writeable, Readable {
	public action?: Ptr;

	public content?: Component;

	constructor(action: Ptr | undefined = undefined, content: Component | undefined = undefined) {
		this.action = action;
		this.content = content;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.action = readInt(reader);
					break;
				}
				case 2: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
						throw new Error(`unexpected length: ` + len);
					}
					this.content = unmarshal(reader) as Component;
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.action !== undefined, this.content !== undefined && !this.content.isZero()];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			writeInt(writer, this.action!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 2);
			writer.writeByte(1);
			this.content.writeTypeHeader(writer);
			this.content!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.action === undefined && (this.content === undefined || this.content.isZero());
	}

	reset(): void {
		this.action = undefined;
		this.content = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 118);
		return;
	}
}

// MenuItems is just a bunch of menu items which belong together.
export class MenuItems implements Writeable, Readable {
	public value: MenuItem[];

	constructor(value: MenuItem[] = []) {
		this.value = value;
	}

	isZero(): boolean {
		return !this.value || this.value.length === 0;
	}

	reset(): void {
		this.value = [];
	}

	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value.length); // Write the length of the array
		for (const c of this.value) {
			c.writeTypeHeader(writer); // Write the type header for each component)
			c.write(writer); // Write the component data

			//c.writeTypeHeader(writer); // Write the type header for each component
			//c.write(writer); // Write the component data
		}
	}

	read(reader: BinaryReader): void {
		const count = reader.readUvarint(); // Read the length of the array
		const values: MenuItem[] = [];

		for (let i = 0; i < count; i++) {
			const obj = unmarshal(reader); // Read and unmarshal each component
			values.push(obj as any as MenuItem); // Cast and add to the array
		}

		this.value = values;
	}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 119);
		return;
	}
}

// MenuGroups is just a bunch of groups.
export class MenuGroups implements Writeable, Readable {
	public value: MenuGroup[];

	constructor(value: MenuGroup[] = []) {
		this.value = value;
	}

	isZero(): boolean {
		return !this.value || this.value.length === 0;
	}

	reset(): void {
		this.value = [];
	}

	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value.length); // Write the length of the array
		for (const c of this.value) {
			c.writeTypeHeader(writer); // Write the type header for each component)
			c.write(writer); // Write the component data

			//c.writeTypeHeader(writer); // Write the type header for each component
			//c.write(writer); // Write the component data
		}
	}

	read(reader: BinaryReader): void {
		const count = reader.readUvarint(); // Read the length of the array
		const values: MenuGroup[] = [];

		for (let i = 0; i < count; i++) {
			const obj = unmarshal(reader); // Read and unmarshal each component
			values.push(obj as any as MenuGroup); // Cast and add to the array
		}

		this.value = values;
	}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 120);
		return;
	}
}

// A Form is not rendered visually but is a help for accessibility.
export class Form implements Writeable, Readable, Component {
	public children?: Components;

	public action?: Ptr;

	// Id represents an optional identifier to locate this component within the view tree. It must be either empty or unique within the entire tree instance.
	public id?: Str;

	public autocomplete?: Bool;

	public frame?: Frame;

	constructor(
		children: Components | undefined = undefined,
		action: Ptr | undefined = undefined,
		id: Str | undefined = undefined,
		autocomplete: Bool | undefined = undefined,
		frame: Frame | undefined = undefined
	) {
		this.children = children;
		this.action = action;
		this.id = id;
		this.autocomplete = autocomplete;
		this.frame = frame;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.children = new Components();
					this.children.read(reader);
					break;
				}
				case 2: {
					this.action = readInt(reader);
					break;
				}
				case 3: {
					this.id = readString(reader);
					break;
				}
				case 4: {
					this.autocomplete = readBool(reader);
					break;
				}
				case 5: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.children !== undefined && !this.children.isZero(),
			this.action !== undefined,
			this.id !== undefined,
			this.autocomplete !== undefined,
			this.frame !== undefined && !this.frame.isZero(),
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			this.children!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			writeInt(writer, this.action!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			writeString(writer, this.id!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			writeBool(writer, this.autocomplete!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.RECORD, 5);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			(this.children === undefined || this.children.isZero()) &&
			this.action === undefined &&
			this.id === undefined &&
			this.autocomplete === undefined &&
			(this.frame === undefined || this.frame.isZero())
		);
	}

	reset(): void {
		this.children = undefined;
		this.action = undefined;
		this.id = undefined;
		this.autocomplete = undefined;
		this.frame = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 121);
		return;
	}
	isComponent(): void {}
}

export class CountDown implements Writeable, Readable, Component {
	public action?: Ptr;

	// Duration is in seconds. After the Duration is over, the Action is invoked. If Duration is 0, Action will not get executed.
	public duration?: DurationSec;

	public showDays?: Bool;

	public showHours?: Bool;

	public showMinutes?: Bool;

	public showSeconds?: Bool;

	public frame?: Frame;

	public textColor?: Color;

	public separatorColor?: Color;

	public style?: CountDownStyle;

	public done?: Bool;

	public progressBackground?: Color;

	public progressColor?: Color;

	constructor(
		action: Ptr | undefined = undefined,
		duration: DurationSec | undefined = undefined,
		showDays: Bool | undefined = undefined,
		showHours: Bool | undefined = undefined,
		showMinutes: Bool | undefined = undefined,
		showSeconds: Bool | undefined = undefined,
		frame: Frame | undefined = undefined,
		textColor: Color | undefined = undefined,
		separatorColor: Color | undefined = undefined,
		style: CountDownStyle | undefined = undefined,
		done: Bool | undefined = undefined,
		progressBackground: Color | undefined = undefined,
		progressColor: Color | undefined = undefined
	) {
		this.action = action;
		this.duration = duration;
		this.showDays = showDays;
		this.showHours = showHours;
		this.showMinutes = showMinutes;
		this.showSeconds = showSeconds;
		this.frame = frame;
		this.textColor = textColor;
		this.separatorColor = separatorColor;
		this.style = style;
		this.done = done;
		this.progressBackground = progressBackground;
		this.progressColor = progressColor;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.action = readInt(reader);
					break;
				}
				case 2: {
					this.duration = readInt(reader);
					break;
				}
				case 3: {
					this.showDays = readBool(reader);
					break;
				}
				case 4: {
					this.showHours = readBool(reader);
					break;
				}
				case 5: {
					this.showMinutes = readBool(reader);
					break;
				}
				case 6: {
					this.showSeconds = readBool(reader);
					break;
				}
				case 7: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				case 8: {
					this.textColor = readString(reader);
					break;
				}
				case 9: {
					this.separatorColor = readString(reader);
					break;
				}
				case 10: {
					this.style = readInt(reader);
					break;
				}
				case 11: {
					this.done = readBool(reader);
					break;
				}
				case 12: {
					this.progressBackground = readString(reader);
					break;
				}
				case 13: {
					this.progressColor = readString(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.action !== undefined,
			this.duration !== undefined,
			this.showDays !== undefined,
			this.showHours !== undefined,
			this.showMinutes !== undefined,
			this.showSeconds !== undefined,
			this.frame !== undefined && !this.frame.isZero(),
			this.textColor !== undefined,
			this.separatorColor !== undefined,
			this.style !== undefined,
			this.done !== undefined,
			this.progressBackground !== undefined,
			this.progressColor !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			writeInt(writer, this.action!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			writeInt(writer, this.duration!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			writeBool(writer, this.showDays!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			writeBool(writer, this.showHours!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.UVARINT, 5);
			writeBool(writer, this.showMinutes!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.UVARINT, 6);
			writeBool(writer, this.showSeconds!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.RECORD, 7);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 8);
			writeString(writer, this.textColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[9]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 9);
			writeString(writer, this.separatorColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[10]) {
			writer.writeFieldHeader(Shapes.UVARINT, 10);
			writeInt(writer, this.style!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[11]) {
			writer.writeFieldHeader(Shapes.UVARINT, 11);
			writeBool(writer, this.done!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[12]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 12);
			writeString(writer, this.progressBackground!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[13]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 13);
			writeString(writer, this.progressColor!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.action === undefined &&
			this.duration === undefined &&
			this.showDays === undefined &&
			this.showHours === undefined &&
			this.showMinutes === undefined &&
			this.showSeconds === undefined &&
			(this.frame === undefined || this.frame.isZero()) &&
			this.textColor === undefined &&
			this.separatorColor === undefined &&
			this.style === undefined &&
			this.done === undefined &&
			this.progressBackground === undefined &&
			this.progressColor === undefined
		);
	}

	reset(): void {
		this.action = undefined;
		this.duration = undefined;
		this.showDays = undefined;
		this.showHours = undefined;
		this.showMinutes = undefined;
		this.showSeconds = undefined;
		this.frame = undefined;
		this.textColor = undefined;
		this.separatorColor = undefined;
		this.style = undefined;
		this.done = undefined;
		this.progressBackground = undefined;
		this.progressColor = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 122);
		return;
	}
	isComponent(): void {}
}

// DurationSec represents a duration in seconds
export type DurationSec = number;
function writeTypeHeaderDurationSec(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 123);
	return;
}

// CodeEditor provides a simple area for viewing or editing source code snippets.
export class CodeEditor implements Writeable, Readable, Component {
	// Value contains the text, which shall be shown or edited.
	public value?: Str;

	public frame?: Frame;

	public readOnly?: Bool;

	public disabled?: Bool;

	public tabSize?: Uint;

	// InputValue is a binding to a state, into which the frontend will the user entered text. This is the pointer a State.
	public inputValue?: Ptr;

	// Language indicates the anticipated syntax highlighter, which shall be enabled. Defined are go, html, css, json, xml, markdown but there may be arbitrary support.
	public language?: Str;

	constructor(
		value: Str | undefined = undefined,
		frame: Frame | undefined = undefined,
		readOnly: Bool | undefined = undefined,
		disabled: Bool | undefined = undefined,
		tabSize: Uint | undefined = undefined,
		inputValue: Ptr | undefined = undefined,
		language: Str | undefined = undefined
	) {
		this.value = value;
		this.frame = frame;
		this.readOnly = readOnly;
		this.disabled = disabled;
		this.tabSize = tabSize;
		this.inputValue = inputValue;
		this.language = language;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.value = readString(reader);
					break;
				}
				case 2: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				case 3: {
					this.readOnly = readBool(reader);
					break;
				}
				case 4: {
					this.disabled = readBool(reader);
					break;
				}
				case 5: {
					this.tabSize = readInt(reader);
					break;
				}
				case 6: {
					this.inputValue = readInt(reader);
					break;
				}
				case 7: {
					this.language = readString(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.value !== undefined,
			this.frame !== undefined && !this.frame.isZero(),
			this.readOnly !== undefined,
			this.disabled !== undefined,
			this.tabSize !== undefined,
			this.inputValue !== undefined,
			this.language !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.value!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.RECORD, 2);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			writeBool(writer, this.readOnly!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			writeBool(writer, this.disabled!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.UVARINT, 5);
			writeInt(writer, this.tabSize!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.UVARINT, 6);
			writeInt(writer, this.inputValue!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 7);
			writeString(writer, this.language!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.value === undefined &&
			(this.frame === undefined || this.frame.isZero()) &&
			this.readOnly === undefined &&
			this.disabled === undefined &&
			this.tabSize === undefined &&
			this.inputValue === undefined &&
			this.language === undefined
		);
	}

	reset(): void {
		this.value = undefined;
		this.frame = undefined;
		this.readOnly = undefined;
		this.disabled = undefined;
		this.tabSize = undefined;
		this.inputValue = undefined;
		this.language = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 124);
		return;
	}
	isComponent(): void {}
}

// RichTextEditor provides a simple area for viewing and editing simple html styled text fragments.
export class RichTextEditor implements Writeable, Readable, Component {
	// Value contains the text, which shall be shown or edited.
	public value?: Str;

	public frame?: Frame;

	public readOnly?: Bool;

	public disabled?: Bool;

	// InputValue is a binding to a state, into which the frontend will submit its state. This is the pointer to a State.
	public inputValue?: Ptr;

	constructor(
		value: Str | undefined = undefined,
		frame: Frame | undefined = undefined,
		readOnly: Bool | undefined = undefined,
		disabled: Bool | undefined = undefined,
		inputValue: Ptr | undefined = undefined
	) {
		this.value = value;
		this.frame = frame;
		this.readOnly = readOnly;
		this.disabled = disabled;
		this.inputValue = inputValue;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.value = readString(reader);
					break;
				}
				case 2: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				case 3: {
					this.readOnly = readBool(reader);
					break;
				}
				case 4: {
					this.disabled = readBool(reader);
					break;
				}
				case 5: {
					this.inputValue = readInt(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.value !== undefined,
			this.frame !== undefined && !this.frame.isZero(),
			this.readOnly !== undefined,
			this.disabled !== undefined,
			this.inputValue !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.value!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.RECORD, 2);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			writeBool(writer, this.readOnly!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			writeBool(writer, this.disabled!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.UVARINT, 5);
			writeInt(writer, this.inputValue!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.value === undefined &&
			(this.frame === undefined || this.frame.isZero()) &&
			this.readOnly === undefined &&
			this.disabled === undefined &&
			this.inputValue === undefined
		);
	}

	reset(): void {
		this.value = undefined;
		this.frame = undefined;
		this.readOnly = undefined;
		this.disabled = undefined;
		this.inputValue = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 125);
		return;
	}
	isComponent(): void {}
}

// RichText renders a small subset of HTML which shall look mostly native in the current view context.
export class RichText implements Writeable, Readable, Component {
	// Value contains the text, which shall be shown or edited.
	public value?: Str;

	public frame?: Frame;

	constructor(value: Str | undefined = undefined, frame: Frame | undefined = undefined) {
		this.value = value;
		this.frame = frame;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.value = readString(reader);
					break;
				}
				case 2: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.value !== undefined, this.frame !== undefined && !this.frame.isZero()];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.value!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.RECORD, 2);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.value === undefined && (this.frame === undefined || this.frame.isZero());
	}

	reset(): void {
		this.value = undefined;
		this.frame = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 126);
		return;
	}
	isComponent(): void {}
}

// A ScrollView can either be horizontal or vertical.
export class HoverGroup implements Writeable, Readable, Component {
	public content?: Component;

	public border?: Border;

	public frame?: Frame;

	public padding?: Padding;

	public backgroundColor?: Color;

	public invisible?: Bool;

	public position?: Position;

	public contentHover?: Component;

	constructor(
		content: Component | undefined = undefined,
		border: Border | undefined = undefined,
		frame: Frame | undefined = undefined,
		padding: Padding | undefined = undefined,
		backgroundColor: Color | undefined = undefined,
		invisible: Bool | undefined = undefined,
		position: Position | undefined = undefined,
		contentHover: Component | undefined = undefined
	) {
		this.content = content;
		this.border = border;
		this.frame = frame;
		this.padding = padding;
		this.backgroundColor = backgroundColor;
		this.invisible = invisible;
		this.position = position;
		this.contentHover = contentHover;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
						throw new Error(`unexpected length: ` + len);
					}
					this.content = unmarshal(reader) as Component;
					break;
				}
				case 2: {
					this.border = new Border();
					this.border.read(reader);
					break;
				}
				case 3: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				case 4: {
					this.padding = new Padding();
					this.padding.read(reader);
					break;
				}
				case 5: {
					this.backgroundColor = readString(reader);
					break;
				}
				case 6: {
					this.invisible = readBool(reader);
					break;
				}
				case 7: {
					this.position = new Position();
					this.position.read(reader);
					break;
				}
				case 8: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
						throw new Error(`unexpected length: ` + len);
					}
					this.contentHover = unmarshal(reader) as Component;
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.content !== undefined && !this.content.isZero(),
			this.border !== undefined && !this.border.isZero(),
			this.frame !== undefined && !this.frame.isZero(),
			this.padding !== undefined && !this.padding.isZero(),
			this.backgroundColor !== undefined,
			this.invisible !== undefined,
			this.position !== undefined && !this.position.isZero(),
			this.contentHover !== undefined && !this.contentHover.isZero(),
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			writer.writeByte(1);
			this.content.writeTypeHeader(writer);
			this.content!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.RECORD, 2);
			this.border!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.RECORD, 3);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.RECORD, 4);
			this.padding!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 5);
			writeString(writer, this.backgroundColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.UVARINT, 6);
			writeBool(writer, this.invisible!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.RECORD, 7);
			this.position!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[8]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 8);
			writer.writeByte(1);
			this.contentHover.writeTypeHeader(writer);
			this.contentHover!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			(this.content === undefined || this.content.isZero()) &&
			(this.border === undefined || this.border.isZero()) &&
			(this.frame === undefined || this.frame.isZero()) &&
			(this.padding === undefined || this.padding.isZero()) &&
			this.backgroundColor === undefined &&
			this.invisible === undefined &&
			(this.position === undefined || this.position.isZero()) &&
			(this.contentHover === undefined || this.contentHover.isZero())
		);
	}

	reset(): void {
		this.content = undefined;
		this.border = undefined;
		this.frame = undefined;
		this.padding = undefined;
		this.backgroundColor = undefined;
		this.invisible = undefined;
		this.position = undefined;
		this.contentHover = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 127);
		return;
	}
	isComponent(): void {}
}

export class FontFaces implements Writeable, Readable {
	public value: FontFace[];

	constructor(value: FontFace[] = []) {
		this.value = value;
	}

	isZero(): boolean {
		return !this.value || this.value.length === 0;
	}

	reset(): void {
		this.value = [];
	}

	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value.length); // Write the length of the array
		for (const c of this.value) {
			c.writeTypeHeader(writer); // Write the type header for each component)
			c.write(writer); // Write the component data

			//c.writeTypeHeader(writer); // Write the type header for each component
			//c.write(writer); // Write the component data
		}
	}

	read(reader: BinaryReader): void {
		const count = reader.readUvarint(); // Read the length of the array
		const values: FontFace[] = [];

		for (let i = 0; i < count; i++) {
			const obj = unmarshal(reader); // Read and unmarshal each component
			values.push(obj as any as FontFace); // Cast and add to the array
		}

		this.value = values;
	}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 128);
		return;
	}
}

// A FontFace describes a specific font file with different type settings attributes.
export class FontFace implements Writeable, Readable {
	public family?: Str;

	public style?: Str;

	public weight?: Str;

	public source?: URI;

	constructor(
		family: Str | undefined = undefined,
		style: Str | undefined = undefined,
		weight: Str | undefined = undefined,
		source: URI | undefined = undefined
	) {
		this.family = family;
		this.style = style;
		this.weight = weight;
		this.source = source;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.family = readString(reader);
					break;
				}
				case 2: {
					this.style = readString(reader);
					break;
				}
				case 3: {
					this.weight = readString(reader);
					break;
				}
				case 4: {
					this.source = readString(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.family !== undefined,
			this.style !== undefined,
			this.weight !== undefined,
			this.source !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.family!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.style!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			writeString(writer, this.weight!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			writeString(writer, this.source!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.family === undefined &&
			this.style === undefined &&
			this.weight === undefined &&
			this.source === undefined
		);
	}

	reset(): void {
		this.family = undefined;
		this.style = undefined;
		this.weight = undefined;
		this.source = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 129);
		return;
	}
}

// A Fonts type describes the default font and various defined font faces.
export class Fonts implements Writeable, Readable {
	public defaultFontFace?: Str;

	public faces?: FontFaces;

	constructor(defaultFontFace: Str | undefined = undefined, faces: FontFaces | undefined = undefined) {
		this.defaultFontFace = defaultFontFace;
		this.faces = faces;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.defaultFontFace = readString(reader);
					break;
				}
				case 2: {
					this.faces = new FontFaces();
					this.faces.read(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.defaultFontFace !== undefined, this.faces !== undefined && !this.faces.isZero()];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.defaultFontFace!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.ARRAY, 2);
			this.faces!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.defaultFontFace === undefined && (this.faces === undefined || this.faces.isZero());
	}

	reset(): void {
		this.defaultFontFace = undefined;
		this.faces = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 130);
		return;
	}
}

export type ObjectFit = number;
function writeTypeHeaderObjectFit(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 131);
	return;
}
// companion enum containing all defined constants for ObjectFit
export enum ObjectFitValues {
	Auto = 0,
	Fill = 1,
	Cover = 2,
	Contain = 3,
	None = 4,
}

export type CountDownStyle = number;
function writeTypeHeaderCountDownStyle(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 132);
	return;
}
// companion enum containing all defined constants for CountDownStyle
export enum CountDownStyleValues {
	CountDownClock = 0,
	CountDownProgress = 1,
}

// This component takes a value and renders it as a QR code.
export class QrCode implements Writeable, Readable, Component {
	// The value to be generated into a QR code.
	public value?: Str;

	// see also https://www.w3.org/WAI/tutorials/images/decision-tree/
	public accessibilityLabel?: Str;

	public frame?: Frame;

	constructor(
		value: Str | undefined = undefined,
		accessibilityLabel: Str | undefined = undefined,
		frame: Frame | undefined = undefined
	) {
		this.value = value;
		this.accessibilityLabel = accessibilityLabel;
		this.frame = frame;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.value = readString(reader);
					break;
				}
				case 2: {
					this.accessibilityLabel = readString(reader);
					break;
				}
				case 3: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.value !== undefined,
			this.accessibilityLabel !== undefined,
			this.frame !== undefined && !this.frame.isZero(),
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.value!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.accessibilityLabel!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.RECORD, 3);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.value === undefined &&
			this.accessibilityLabel === undefined &&
			(this.frame === undefined || this.frame.isZero())
		);
	}

	reset(): void {
		this.value = undefined;
		this.accessibilityLabel = undefined;
		this.frame = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 133);
		return;
	}
	isComponent(): void {}
}

// This component uses the camera to process and return a QR code value.
export class QrCodeReader implements Writeable, Readable, Component {
	// InputValue stores the pointer to the updated state of the scanned QR code value.
	public inputValue?: Ptr;

	// The device that shall be used for the scanning process.
	public mediaDevice?: MediaDevice;

	// ShowTracker indicates whether the tracking lines should be displayed when scanning QR codes.
	public showTracker?: Bool;

	// The color of the tracker. Defaults to M0.
	public trackerColor?: Color;

	// The line width in pixels of the tracker. Defaults to 2 pixels.
	public trackerLineWidth?: Uint;

	// Flag that activates the torch for scanning qr codes.
	public activatedTorch?: Bool;

	// Callback function to execute after the camera is ready.
	public onCameraReady?: Ptr;

	public frame?: Frame;

	constructor(
		inputValue: Ptr | undefined = undefined,
		mediaDevice: MediaDevice | undefined = undefined,
		showTracker: Bool | undefined = undefined,
		trackerColor: Color | undefined = undefined,
		trackerLineWidth: Uint | undefined = undefined,
		activatedTorch: Bool | undefined = undefined,
		onCameraReady: Ptr | undefined = undefined,
		frame: Frame | undefined = undefined
	) {
		this.inputValue = inputValue;
		this.mediaDevice = mediaDevice;
		this.showTracker = showTracker;
		this.trackerColor = trackerColor;
		this.trackerLineWidth = trackerLineWidth;
		this.activatedTorch = activatedTorch;
		this.onCameraReady = onCameraReady;
		this.frame = frame;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.inputValue = readInt(reader);
					break;
				}
				case 2: {
					this.mediaDevice = new MediaDevice();
					this.mediaDevice.read(reader);
					break;
				}
				case 3: {
					this.showTracker = readBool(reader);
					break;
				}
				case 4: {
					this.trackerColor = readString(reader);
					break;
				}
				case 5: {
					this.trackerLineWidth = readInt(reader);
					break;
				}
				case 6: {
					this.activatedTorch = readBool(reader);
					break;
				}
				case 7: {
					this.onCameraReady = readInt(reader);
					break;
				}
				case 8: {
					this.frame = new Frame();
					this.frame.read(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.inputValue !== undefined,
			this.mediaDevice !== undefined && !this.mediaDevice.isZero(),
			this.showTracker !== undefined,
			this.trackerColor !== undefined,
			this.trackerLineWidth !== undefined,
			this.activatedTorch !== undefined,
			this.onCameraReady !== undefined,
			this.frame !== undefined && !this.frame.isZero(),
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			writeInt(writer, this.inputValue!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.RECORD, 2);
			this.mediaDevice!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			writeBool(writer, this.showTracker!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 4);
			writeString(writer, this.trackerColor!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[5]) {
			writer.writeFieldHeader(Shapes.UVARINT, 5);
			writeInt(writer, this.trackerLineWidth!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[6]) {
			writer.writeFieldHeader(Shapes.UVARINT, 6);
			writeBool(writer, this.activatedTorch!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[7]) {
			writer.writeFieldHeader(Shapes.UVARINT, 7);
			writeInt(writer, this.onCameraReady!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[8]) {
			writer.writeFieldHeader(Shapes.RECORD, 8);
			this.frame!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.inputValue === undefined &&
			(this.mediaDevice === undefined || this.mediaDevice.isZero()) &&
			this.showTracker === undefined &&
			this.trackerColor === undefined &&
			this.trackerLineWidth === undefined &&
			this.activatedTorch === undefined &&
			this.onCameraReady === undefined &&
			(this.frame === undefined || this.frame.isZero())
		);
	}

	reset(): void {
		this.inputValue = undefined;
		this.mediaDevice = undefined;
		this.showTracker = undefined;
		this.trackerColor = undefined;
		this.trackerLineWidth = undefined;
		this.activatedTorch = undefined;
		this.onCameraReady = undefined;
		this.frame = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 134);
		return;
	}
	isComponent(): void {}
}

export type MediaDeviceKind = number;
function writeTypeHeaderMediaDeviceKind(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.UVARINT, 135);
	return;
}
// companion enum containing all defined constants for MediaDeviceKind
export enum MediaDeviceKindValues {
	AudioInput = 0,
	AudioOutput = 1,
	VideoInput = 2,
}

// MediaDevice describes a frontend user media device.
export class MediaDevice implements Writeable, Readable {
	public deviceID?: Str;

	public groupID?: Str;

	public label?: Str;

	public kind?: MediaDeviceKind;

	constructor(
		deviceID: Str | undefined = undefined,
		groupID: Str | undefined = undefined,
		label: Str | undefined = undefined,
		kind: MediaDeviceKind | undefined = undefined
	) {
		this.deviceID = deviceID;
		this.groupID = groupID;
		this.label = label;
		this.kind = kind;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.deviceID = readString(reader);
					break;
				}
				case 2: {
					this.groupID = readString(reader);
					break;
				}
				case 3: {
					this.label = readString(reader);
					break;
				}
				case 4: {
					this.kind = readInt(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.deviceID !== undefined,
			this.groupID !== undefined,
			this.label !== undefined,
			this.kind !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.deviceID!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 2);
			writeString(writer, this.groupID!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 3);
			writeString(writer, this.label!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			writeInt(writer, this.kind!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.deviceID === undefined &&
			this.groupID === undefined &&
			this.label === undefined &&
			this.kind === undefined
		);
	}

	reset(): void {
		this.deviceID = undefined;
		this.groupID = undefined;
		this.label = undefined;
		this.kind = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 136);
		return;
	}
}

// This component returns all media devices that the user allowed us access to.
export class MediaDevices implements Writeable, Readable, Component {
	// InputValue stores the pointer to the updated state of the current media devices.
	public inputValue?: Ptr;

	// Flag to load audio devices.
	public withAudio?: Bool;

	// Flag to load video devices.
	public withVideo?: Bool;

	// Whether the user has granted the requested audio or video permissions.
	public hasGrantedPermissions?: Ptr;

	constructor(
		inputValue: Ptr | undefined = undefined,
		withAudio: Bool | undefined = undefined,
		withVideo: Bool | undefined = undefined,
		hasGrantedPermissions: Ptr | undefined = undefined
	) {
		this.inputValue = inputValue;
		this.withAudio = withAudio;
		this.withVideo = withVideo;
		this.hasGrantedPermissions = hasGrantedPermissions;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.inputValue = readInt(reader);
					break;
				}
				case 2: {
					this.withAudio = readBool(reader);
					break;
				}
				case 3: {
					this.withVideo = readBool(reader);
					break;
				}
				case 4: {
					this.hasGrantedPermissions = readInt(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.inputValue !== undefined,
			this.withAudio !== undefined,
			this.withVideo !== undefined,
			this.hasGrantedPermissions !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			writeInt(writer, this.inputValue!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			writeBool(writer, this.withAudio!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			writeBool(writer, this.withVideo!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[4]) {
			writer.writeFieldHeader(Shapes.UVARINT, 4);
			writeInt(writer, this.hasGrantedPermissions!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return (
			this.inputValue === undefined &&
			this.withAudio === undefined &&
			this.withVideo === undefined &&
			this.hasGrantedPermissions === undefined
		);
	}

	reset(): void {
		this.inputValue = undefined;
		this.withAudio = undefined;
		this.withVideo = undefined;
		this.hasGrantedPermissions = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 137);
		return;
	}
	isComponent(): void {}
}

// Int represents just a user defined signed integer value. This is how nprotoc works.
export type Int = number;
function writeTypeHeaderInt(dst: BinaryWriter): void {
	dst.writeTypeHeader(Shapes.VARINT, 138);
	return;
}

// CallMediaDevicesEnumerate tries to enumerate all available media devices. It has no further arguments.
export class CallMediaDevicesEnumerate implements Writeable, Readable, CallArgs {
	// Keep is kept to avoid falling back to the zero value which breaks polymorphism at protocol level.
	public keep?: Bool;

	public withAudio?: Bool;

	public withVideo?: Bool;

	constructor(
		keep: Bool | undefined = undefined,
		withAudio: Bool | undefined = undefined,
		withVideo: Bool | undefined = undefined
	) {
		this.keep = keep;
		this.withAudio = withAudio;
		this.withVideo = withVideo;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.keep = readBool(reader);
					break;
				}
				case 2: {
					this.withAudio = readBool(reader);
					break;
				}
				case 3: {
					this.withVideo = readBool(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.keep !== undefined, this.withAudio !== undefined, this.withVideo !== undefined];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			writeBool(writer, this.keep!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.UVARINT, 2);
			writeBool(writer, this.withAudio!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			writeBool(writer, this.withVideo!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.keep === undefined && this.withAudio === undefined && this.withVideo === undefined;
	}

	reset(): void {
		this.keep = undefined;
		this.withAudio = undefined;
		this.withVideo = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 139);
		return;
	}
	isCallArgs(): void {}
}

// MediaDevices2 is a bunch of MediaDevice entries and should be renamed to just MediaDevices if the headless MediaDevices component is removed.
export class MediaDevices2 implements Writeable, Readable {
	public value: MediaDevice[];

	constructor(value: MediaDevice[] = []) {
		this.value = value;
	}

	isZero(): boolean {
		return !this.value || this.value.length === 0;
	}

	reset(): void {
		this.value = [];
	}

	write(writer: BinaryWriter): void {
		writer.writeUvarint(this.value.length); // Write the length of the array
		for (const c of this.value) {
			c.writeTypeHeader(writer); // Write the type header for each component)
			c.write(writer); // Write the component data

			//c.writeTypeHeader(writer); // Write the type header for each component
			//c.write(writer); // Write the component data
		}
	}

	read(reader: BinaryReader): void {
		const count = reader.readUvarint(); // Read the length of the array
		const values: MediaDevice[] = [];

		for (let i = 0; i < count; i++) {
			const obj = unmarshal(reader); // Read and unmarshal each component
			values.push(obj as any as MediaDevice); // Cast and add to the array
		}

		this.value = values;
	}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.ARRAY, 140);
		return;
	}
}

// CallResolved is issued by the frontend to the backend to submit the result asynchronously.
export class CallResolved implements Writeable, Readable, NagoEvent {
	// CallPtr denotes the backend pointer which is resolved through this ret call.
	public callPtr?: Ptr;

	// CallRetArgs describes through the type how the result looks.
	public ret?: CallRet;

	public rID?: RID;

	constructor(
		callPtr: Ptr | undefined = undefined,
		ret: CallRet | undefined = undefined,
		rID: RID | undefined = undefined
	) {
		this.callPtr = callPtr;
		this.ret = ret;
		this.rID = rID;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.callPtr = readInt(reader);
					break;
				}
				case 2: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
						throw new Error(`unexpected length: ` + len);
					}
					this.ret = unmarshal(reader) as CallRet;
					break;
				}
				case 3: {
					this.rID = readInt(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [
			false,
			this.callPtr !== undefined,
			this.ret !== undefined && !this.ret.isZero(),
			this.rID !== undefined,
		];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			writeInt(writer, this.callPtr!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 2);
			writer.writeByte(1);
			this.ret.writeTypeHeader(writer);
			this.ret!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[3]) {
			writer.writeFieldHeader(Shapes.UVARINT, 3);
			writeInt(writer, this.rID!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.callPtr === undefined && (this.ret === undefined || this.ret.isZero()) && this.rID === undefined;
	}

	reset(): void {
		this.callPtr = undefined;
		this.ret = undefined;
		this.rID = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 141);
		return;
	}
	isNagoEvent(): void {}
}

// CallRequested is issued by the backend to the frontend to execute something asynchronously.
export class CallRequested implements Writeable, Readable, NagoEvent {
	// CallPtr denotes the backend pointer to resolve the call in the future.
	public callPtr?: Ptr;

	// CallArgs describes through the type which function is called and declares the actual arguments for it.
	public call?: CallArgs;

	constructor(callPtr: Ptr | undefined = undefined, call: CallArgs | undefined = undefined) {
		this.callPtr = callPtr;
		this.call = call;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.callPtr = readInt(reader);
					break;
				}
				case 2: {
					// decode polymorphic field as 1 element array
					const len = reader.readUvarint();
					if (len != 1) {
						throw new Error(`unexpected length: ` + len);
					}
					this.call = unmarshal(reader) as CallArgs;
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.callPtr !== undefined, this.call !== undefined && !this.call.isZero()];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.UVARINT, 1);
			writeInt(writer, this.callPtr!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			// encode polymorphic enum as 1 element slice
			writer.writeFieldHeader(Shapes.ARRAY, 2);
			writer.writeByte(1);
			this.call.writeTypeHeader(writer);
			this.call!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.callPtr === undefined && (this.call === undefined || this.call.isZero());
	}

	reset(): void {
		this.callPtr = undefined;
		this.call = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 142);
		return;
	}
	isNagoEvent(): void {}
}

// RetError indicates that an unexpected error occurred during the invocation call or during the async resolving. Known error types should be usually modelled explicitly.
export class RetError implements Writeable, Readable, CallRet {
	public message?: Str;

	public code?: Int;

	constructor(message: Str | undefined = undefined, code: Int | undefined = undefined) {
		this.message = message;
		this.code = code;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.message = readString(reader);
					break;
				}
				case 2: {
					this.code = readSint(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.message !== undefined, this.code !== undefined];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.BYTESLICE, 1);
			writeString(writer, this.message!); // typescript linters cannot see, that we already checked this properly above
		}
		if (fields[2]) {
			writer.writeFieldHeader(Shapes.VARINT, 2);
			writeSint(writer, this.code!); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.message === undefined && this.code === undefined;
	}

	reset(): void {
		this.message = undefined;
		this.code = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 143);
		return;
	}
	isCallRet(): void {}
}

// RetMediaDevicesEnumerate tries to enumerate all available media devices. It has no further arguments.
export class RetMediaDevicesEnumerate implements Writeable, Readable, CallRet {
	public devices?: MediaDevices2;

	constructor(devices: MediaDevices2 | undefined = undefined) {
		this.devices = devices;
	}

	read(reader: BinaryReader): void {
		this.reset();
		const fieldCount = reader.readByte();
		for (let i = 0; i < fieldCount; i++) {
			const fieldHeader = reader.readFieldHeader();
			switch (fieldHeader.fieldId) {
				case 1: {
					this.devices = new MediaDevices2();
					this.devices.read(reader);
					break;
				}
				default:
					throw new Error(`Unknown field ID: ${fieldHeader.fieldId}`);
			}
		}
	}

	write(writer: BinaryWriter): void {
		const fields = [false, this.devices !== undefined && !this.devices.isZero()];
		let fieldCount = fields.reduce((count, present) => count + (present ? 1 : 0), 0);
		writer.writeByte(fieldCount);
		if (fields[1]) {
			writer.writeFieldHeader(Shapes.ARRAY, 1);
			this.devices!.write(writer); // typescript linters cannot see, that we already checked this properly above
		}
	}

	isZero(): boolean {
		return this.devices === undefined || this.devices.isZero();
	}

	reset(): void {
		this.devices = undefined;
	}

	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 144);
		return;
	}
	isCallRet(): void {}
}

// RetVoid has no further fields and indicates that no more return arguments as a response are provided.
export class RetVoid implements Writeable, Readable, CallRet {
	constructor() {}

	read(r: BinaryReader): void {
		r.readByte();
	}
	write(w: BinaryWriter): void {
		w.writeByte(0);
	}
	isZero(): boolean {
		return true;
	}
	reset(): void {}
	writeTypeHeader(dst: BinaryWriter): void {
		dst.writeTypeHeader(Shapes.RECORD, 145);
		return;
	}
	isCallRet(): void {}
}

// Function to marshal a Writeable object into a BinaryWriter
export function marshal(dst: BinaryWriter, src: Writeable): void {
	src.writeTypeHeader(dst);
	src.write(dst);
}

// Function to unmarshal data from a BinaryReader into a Readable object
export function unmarshal(src: BinaryReader): any {
	const { typeId } = src.readTypeHeader();
	switch (typeId) {
		case 1: {
			const v = new Box();
			v.read(src);
			return v;
		}
		case 2: {
			const v = readInt(src) as Ptr;
			return v;
		}
		case 3: {
			const v = new UpdateStateValueRequested();
			v.read(src);
			return v;
		}
		case 4: {
			const v = new FunctionCallRequested();
			v.read(src);
			return v;
		}
		case 5: {
			const v = readInt(src) as Alignment;
			return v;
		}
		case 6: {
			const v = readString(src) as Color;
			return v;
		}
		case 7: {
			const v = new Shadow();
			v.read(src);
			return v;
		}
		case 8: {
			const v = readString(src) as Length;
			return v;
		}
		case 9: {
			const v = new Border();
			v.read(src);
			return v;
		}
		case 10: {
			const v = new Frame();
			v.read(src);
			return v;
		}
		case 11: {
			const v = new Padding();
			v.read(src);
			return v;
		}
		case 12: {
			const v = new AlignedComponent();
			v.read(src);
			return v;
		}
		case 13: {
			const v = new Components();
			v.read(src);
			return v;
		}
		case 14: {
			const v = new AlignedComponents();
			v.read(src);
			return v;
		}
		case 15: {
			const v = new Checkbox();
			v.read(src);
			return v;
		}
		case 16: {
			const v = readBool(src) as Bool;
			return v;
		}
		case 17: {
			const v = new ErrorOccurred();
			v.read(src);
			return v;
		}
		case 18: {
			const v = readString(src) as Locale;
			return v;
		}
		case 19: {
			const v = readInt(src) as FontStyle;
			return v;
		}
		case 20: {
			const v = readString(src) as RootViewID;
			return v;
		}
		case 21: {
			const v = new RootViewParameters();
			v.read(src);
			return v;
		}
		case 22: {
			const v = readString(src) as Str;
			return v;
		}
		case 23: {
			const v = new RootViewRenderingRequested();
			v.read(src);
			return v;
		}
		case 24: {
			const v = new RootViewDestructionRequested();
			v.read(src);
			return v;
		}
		case 25: {
			const v = new RootViewInvalidated();
			v.read(src);
			return v;
		}
		case 26: {
			const v = new ErrorRootViewAllocationRequired();
			v.read(src);
			return v;
		}
		case 27: {
			const v = new RootViewAllocationRequested();
			v.read(src);
			return v;
		}
		case 28: {
			const v = readInt(src) as WindowSizeClass;
			return v;
		}
		case 29: {
			const v = new ScopeConfigurationChangeRequested();
			v.read(src);
			return v;
		}
		case 30: {
			const v = readInt(src) as ColorScheme;
			return v;
		}
		case 31: {
			const v = new WindowInfo();
			v.read(src);
			return v;
		}
		case 32: {
			const v = readFloat(src) as DP;
			return v;
		}
		case 33: {
			const v = readFloat(src) as Density;
			return v;
		}
		case 34: {
			const v = new ScopeConfigurationChanged();
			v.read(src);
			return v;
		}
		case 35: {
			const v = new Locales();
			v.read(src);
			return v;
		}
		case 36: {
			const v = readString(src) as URI;
			return v;
		}
		case 37: {
			const v = readString(src) as NamespaceName;
			return v;
		}
		case 38: {
			const v = new NamedColors();
			v.read(src);
			return v;
		}
		case 39: {
			const v = new Theme();
			v.read(src);
			return v;
		}
		case 40: {
			const v = new NamespacedColors();
			v.read(src);
			return v;
		}
		case 41: {
			const v = new NamedLengths();
			v.read(src);
			return v;
		}
		case 42: {
			const v = new Themes();
			v.read(src);
			return v;
		}
		case 43: {
			const v = readInt(src) as DatePickerStyle;
			return v;
		}
		case 44: {
			const v = readInt(src) as Day;
			return v;
		}
		case 45: {
			const v = new DateData();
			v.read(src);
			return v;
		}
		case 46: {
			const v = readInt(src) as Month;
			return v;
		}
		case 47: {
			const v = readInt(src) as Year;
			return v;
		}
		case 48: {
			const v = new DatePicker();
			v.read(src);
			return v;
		}
		case 49: {
			const v = new Divider();
			v.read(src);
			return v;
		}
		case 50: {
			const v = readInt(src) as RID;
			return v;
		}
		case 51: {
			const v = readInt(src) as FontWeight;
			return v;
		}
		case 52: {
			const v = new Font();
			v.read(src);
			return v;
		}
		case 53: {
			const v = new Grid();
			v.read(src);
			return v;
		}
		case 54: {
			const v = readInt(src) as Uint;
			return v;
		}
		case 55: {
			const v = new GridCells();
			v.read(src);
			return v;
		}
		case 56: {
			const v = new Lengths();
			v.read(src);
			return v;
		}
		case 57: {
			const v = new GridCell();
			v.read(src);
			return v;
		}
		case 58: {
			const v = new HStack();
			v.read(src);
			return v;
		}
		case 59: {
			const v = readInt(src) as StylePreset;
			return v;
		}
		case 60: {
			const v = new Position();
			v.read(src);
			return v;
		}
		case 61: {
			const v = readInt(src) as PositionType;
			return v;
		}
		case 62: {
			const v = new Img();
			v.read(src);
			return v;
		}
		case 63: {
			const v = readString(src) as SVG;
			return v;
		}
		case 64: {
			const v = new Strings();
			v.read(src);
			return v;
		}
		case 65: {
			const v = new FileImportRequested();
			v.read(src);
			return v;
		}
		case 66: {
			const v = new KeyboardOptions();
			v.read(src);
			return v;
		}
		case 67: {
			const v = readInt(src) as KeyboardType;
			return v;
		}
		case 68: {
			const v = readInt(src) as ModalType;
			return v;
		}
		case 69: {
			const v = new Modal();
			v.read(src);
			return v;
		}
		case 70: {
			const v = new ThemeRequested();
			v.read(src);
			return v;
		}
		case 71: {
			const v = new NavigationForwardToRequested();
			v.read(src);
			return v;
		}
		case 72: {
			const v = new NavigationResetRequested();
			v.read(src);
			return v;
		}
		case 73: {
			const v = new NavigationBackRequested();
			v.read(src);
			return v;
		}
		case 74: {
			const v = new NavigationReloadRequested();
			v.read(src);
			return v;
		}
		case 75: {
			const v = readString(src) as ThemeID;
			return v;
		}
		case 77: {
			const v = new WindowTitle();
			v.read(src);
			return v;
		}
		case 78: {
			const v = readInt(src) as Duration;
			return v;
		}
		case 79: {
			const v = new PasswordField();
			v.read(src);
			return v;
		}
		case 80: {
			const v = readInt(src) as TextFieldStyle;
			return v;
		}
		case 81: {
			const v = new Ping();
			v.read(src);
			return v;
		}
		case 82: {
			const v = new Radiobutton();
			v.read(src);
			return v;
		}
		case 83: {
			const v = readInt(src) as ScaffoldAlignment;
			return v;
		}
		case 84: {
			const v = new ScaffoldMenuEntries();
			v.read(src);
			return v;
		}
		case 85: {
			const v = new Scaffold();
			v.read(src);
			return v;
		}
		case 86: {
			const v = new ScaffoldMenuEntry();
			v.read(src);
			return v;
		}
		case 87: {
			const v = readString(src) as ScopeID;
			return v;
		}
		case 88: {
			const v = new ScopeDestructionRequested();
			v.read(src);
			return v;
		}
		case 89: {
			const v = readInt(src) as ScrollViewAxis;
			return v;
		}
		case 90: {
			const v = new ScrollView();
			v.read(src);
			return v;
		}
		case 91: {
			const v = new Resource();
			v.read(src);
			return v;
		}
		case 92: {
			const v = new Resources();
			v.read(src);
			return v;
		}
		case 93: {
			const v = new SendMultipleRequested();
			v.read(src);
			return v;
		}
		case 94: {
			const v = new SessionAssigned();
			v.read(src);
			return v;
		}
		case 95: {
			const v = new Spacer();
			v.read(src);
			return v;
		}
		case 96: {
			const v = new Table();
			v.read(src);
			return v;
		}
		case 97: {
			const v = new TableCell();
			v.read(src);
			return v;
		}
		case 98: {
			const v = new TableColumn();
			v.read(src);
			return v;
		}
		case 99: {
			const v = new TableRow();
			v.read(src);
			return v;
		}
		case 100: {
			const v = new TableHeader();
			v.read(src);
			return v;
		}
		case 101: {
			const v = new TableRows();
			v.read(src);
			return v;
		}
		case 102: {
			const v = new TableCells();
			v.read(src);
			return v;
		}
		case 103: {
			const v = new TableColumns();
			v.read(src);
			return v;
		}
		case 104: {
			const v = new TextView();
			v.read(src);
			return v;
		}
		case 105: {
			const v = readInt(src) as TextAlignment;
			return v;
		}
		case 106: {
			const v = new TextField();
			v.read(src);
			return v;
		}
		case 107: {
			const v = new Toggle();
			v.read(src);
			return v;
		}
		case 108: {
			const v = new TextLayout();
			v.read(src);
			return v;
		}
		case 109: {
			const v = new VStack();
			v.read(src);
			return v;
		}
		case 110: {
			const v = new WebView();
			v.read(src);
			return v;
		}
		case 111: {
			const v = new WindowInfoChanged();
			v.read(src);
			return v;
		}
		case 112: {
			const v = new UpdateStateValues2Requested();
			v.read(src);
			return v;
		}
		case 113: {
			const v = new OpenHttpLink();
			v.read(src);
			return v;
		}
		case 114: {
			const v = new OpenHttpFlow();
			v.read(src);
			return v;
		}
		case 115: {
			const v = new ClipboardWriteTextRequested();
			v.read(src);
			return v;
		}
		case 116: {
			const v = new Menu();
			v.read(src);
			return v;
		}
		case 117: {
			const v = new MenuGroup();
			v.read(src);
			return v;
		}
		case 118: {
			const v = new MenuItem();
			v.read(src);
			return v;
		}
		case 119: {
			const v = new MenuItems();
			v.read(src);
			return v;
		}
		case 120: {
			const v = new MenuGroups();
			v.read(src);
			return v;
		}
		case 121: {
			const v = new Form();
			v.read(src);
			return v;
		}
		case 122: {
			const v = new CountDown();
			v.read(src);
			return v;
		}
		case 123: {
			const v = readInt(src) as DurationSec;
			return v;
		}
		case 124: {
			const v = new CodeEditor();
			v.read(src);
			return v;
		}
		case 125: {
			const v = new RichTextEditor();
			v.read(src);
			return v;
		}
		case 126: {
			const v = new RichText();
			v.read(src);
			return v;
		}
		case 127: {
			const v = new HoverGroup();
			v.read(src);
			return v;
		}
		case 128: {
			const v = new FontFaces();
			v.read(src);
			return v;
		}
		case 129: {
			const v = new FontFace();
			v.read(src);
			return v;
		}
		case 130: {
			const v = new Fonts();
			v.read(src);
			return v;
		}
		case 131: {
			const v = readInt(src) as ObjectFit;
			return v;
		}
		case 132: {
			const v = readInt(src) as CountDownStyle;
			return v;
		}
		case 133: {
			const v = new QrCode();
			v.read(src);
			return v;
		}
		case 134: {
			const v = new QrCodeReader();
			v.read(src);
			return v;
		}
		case 135: {
			const v = readInt(src) as MediaDeviceKind;
			return v;
		}
		case 136: {
			const v = new MediaDevice();
			v.read(src);
			return v;
		}
		case 137: {
			const v = new MediaDevices();
			v.read(src);
			return v;
		}
		case 138: {
			const v = readSint(src) as Int;
			return v;
		}
		case 139: {
			const v = new CallMediaDevicesEnumerate();
			v.read(src);
			return v;
		}
		case 140: {
			const v = new MediaDevices2();
			v.read(src);
			return v;
		}
		case 141: {
			const v = new CallResolved();
			v.read(src);
			return v;
		}
		case 142: {
			const v = new CallRequested();
			v.read(src);
			return v;
		}
		case 143: {
			const v = new RetError();
			v.read(src);
			return v;
		}
		case 144: {
			const v = new RetMediaDevicesEnumerate();
			v.read(src);
			return v;
		}
		case 145: {
			const v = new RetVoid();
			v.read(src);
			return v;
		}
	}
	throw new Error(`Unknown type ID: ${typeId}`);
}
