// Code generated by github.com/worldiety/macro. DO NOT EDIT.

package iam

import (
	json "encoding/json"
	fmt "fmt"
)

// This variable is declared to let linters know, that [_AccountStatus] is used at compile time to generate [AccountStatus].
type _ _AccountStatus
type AccountStatus struct {
	ordinal int
	value   any
}

func (e AccountStatus) Unwrap() any {
	return e.value
}

func (e AccountStatus) Ordinal() int {
	return e.ordinal
}

func (e AccountStatus) Valid() bool {
	return e.ordinal > 0
}

// Switch provides an exhaustive and type safe closure callback mechanic. Nil callbacks are allowed. Unmatched branches are delegated into a default case.
func (e AccountStatus) Switch(onEnabled func(Enabled), onDisabled func(Disabled), onEnabledUntil func(EnabledUntil), _onDefault func(any)) {
	switch e.ordinal {
	case 1:
		if onEnabled != nil {
			onEnabled(e.value.(Enabled))
			return
		}
	case 2:
		if onDisabled != nil {
			onDisabled(e.value.(Disabled))
			return
		}
	case 3:
		if onEnabledUntil != nil {
			onEnabledUntil(e.value.(EnabledUntil))
			return
		}
	}

	if _onDefault != nil {
		_onDefault(e.value)
	}
}

func (e AccountStatus) AsEnabled() (Enabled, bool) {
	var zero Enabled
	if e.ordinal == 1 {
		return e.value.(Enabled), true
	}

	return zero, false
}

func (e AccountStatus) WithEnabled(v Enabled) AccountStatus {
	e.ordinal = 1
	e.value = v
	return e
}

func (e AccountStatus) AsDisabled() (Disabled, bool) {
	var zero Disabled
	if e.ordinal == 2 {
		return e.value.(Disabled), true
	}

	return zero, false
}

func (e AccountStatus) WithDisabled(v Disabled) AccountStatus {
	e.ordinal = 2
	e.value = v
	return e
}

func (e AccountStatus) AsEnabledUntil() (EnabledUntil, bool) {
	var zero EnabledUntil
	if e.ordinal == 3 {
		return e.value.(EnabledUntil), true
	}

	return zero, false
}

func (e AccountStatus) WithEnabledUntil(v EnabledUntil) AccountStatus {
	e.ordinal = 3
	e.value = v
	return e
}

func (e AccountStatus) MarshalJSON() ([]byte, error) {
	if e.ordinal == 0 {
		return nil, fmt.Errorf("marshalling a zero value is not allowed")
	}

	// note, that by definition, this kind of encoding does not work with union types which evaluates to null, arrays or primitives.
	// Chose adjacent encoding instead.
	type adjacentlyTagged[T any] struct {
		Type  string `json:"type"`
		Value T      `json:"content"`
	}

	switch e.ordinal {
	case 1:
		return json.Marshal(adjacentlyTagged[Enabled]{
			Type:  "Enabled",
			Value: e.value.(Enabled),
		})
	case 2:
		return json.Marshal(adjacentlyTagged[Disabled]{
			Type:  "Disabled",
			Value: e.value.(Disabled),
		})
	case 3:
		return json.Marshal(adjacentlyTagged[EnabledUntil]{
			Type:  "EnabledUntil",
			Value: e.value.(EnabledUntil),
		})
	default:
		return nil, fmt.Errorf("unknown type ordinal variant '%d'", e.ordinal)
	}
}

func (e *AccountStatus) UnmarshalJSON(bytes []byte) error {
	typeOnly := struct {
		Type string `json:"type"`
	}{}
	if err := json.Unmarshal(bytes, &typeOnly); err != nil {
		return err
	}
	type adjacentlyTagged[T any] struct {
		Type  string `json:"type"`
		Value T      `json:"content"`
	}
	switch typeOnly.Type {
	case "Enabled":
		var value adjacentlyTagged[Enabled]
		if err := json.Unmarshal(bytes, &value); err != nil {
			return fmt.Errorf("cannot unmarshal variant 'Enabled'")
		}
		e.ordinal = 1
		e.value = value.Value
	case "Disabled":
		var value adjacentlyTagged[Disabled]
		if err := json.Unmarshal(bytes, &value); err != nil {
			return fmt.Errorf("cannot unmarshal variant 'Disabled'")
		}
		e.ordinal = 2
		e.value = value.Value
	case "EnabledUntil":
		var value adjacentlyTagged[EnabledUntil]
		if err := json.Unmarshal(bytes, &value); err != nil {
			return fmt.Errorf("cannot unmarshal variant 'EnabledUntil'")
		}
		e.ordinal = 3
		e.value = value.Value
	default:
		return fmt.Errorf("unknown type variant name '%s'", typeOnly.Type)
	}

	return nil
}

func MatchAccountStatus[R any](e AccountStatus, onEnabled func(Enabled) R, onDisabled func(Disabled) R, onEnabledUntil func(EnabledUntil) R, _onDefault func(any) R) R {
	if _onDefault == nil {
		panic(`missing default match: cannot guarantee exhaustive matching`)
	}

	switch e.ordinal {
	case 1:
		if onEnabled != nil {
			return onEnabled(e.value.(Enabled))
		}
	case 2:
		if onDisabled != nil {
			return onDisabled(e.value.(Disabled))
		}
	case 3:
		if onEnabledUntil != nil {
			return onEnabledUntil(e.value.(EnabledUntil))
		}
	}

	return _onDefault(e.value)
}
