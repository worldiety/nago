package template

import (
	"context"
	"go.wdy.de/nago/application/group"
	"go.wdy.de/nago/auth"
	"go.wdy.de/nago/pkg/blob"
	"go.wdy.de/nago/pkg/data"
	"go.wdy.de/nago/pkg/std"
	"go.wdy.de/nago/presentation/core"
	"golang.org/x/text/language"
	"io"
	"io/fs"
	"iter"
	"log/slog"
	"maps"
	"slices"
	"strings"
	"sync"
	"time"
)

type ExecType int

const (
	TagPDF  Tag = "pdf"
	TagHTML Tag = "html"
	TagMail Tag = "mail"
)

const (
	Unprocessed  ExecType = iota // return type is always application/zip
	TreeTemplate                 // return type is either text/plain or text/html
	TypstPDF                     // return type is always application/pdf
	LatexPDF                     // return type is always application/pdf
	AsciidocPDF                  // return type is always application/pdf
)

type ExecOptions struct {
	// Context is used to cancel an execution, e.g. because it takes to long to complete.
	Context context.Context

	// Language represents an already parsed tag, like in [auth.Subject.Language].
	// It may be [language.Und] which is the zero value, to disable any localization effects.
	// To localize a template, you have to put the required files into the magic folder locales/<BCP47-Tag>/...
	Language language.Tag // if zero (language.Und), does not have any effect.

	// TemplateName behaviour is quite complex:
	//  - if template is a [TreeTemplate], parse all tpl files into a single template tree and execute only the named
	//    template. If name is empty, continue without a name.
	//    The result is always a single file. This is useful, if you have different variants and template
	//    subsets, e.g. when rendering static text files. If at least a single *.gohtml file is found,
	//    the html template engine is used to automatically apply escaping and protect against injection attacks.
	//  - All *PDF templates must be executed with an empty template name.
	//    These are large document structures with its own include mechanic, like latex or typst templates, eventually
	//    with templated graphic files (like SVG). These files are also renamed by removing the .tpl suffix.
	TemplateName DefinedTemplateName

	// Model may be nil or whatever fits the template. To know more, inspect the [Project.Examples] of what may
	// be allowed.
	Model any
}

// Execute takes the project and performs the following steps:
//   - load all files from FileSet into memory
//   - copy all localized files on top of it, if tag is not empty (file extensions are .nago.en-US.tpl
//   - if template name is empty, execute each file marked as [File.IsTemplate] through the Go template engine and replace the original file in-memory
//   - if template name is not empty, load all files marked as [File.IsTemplate] at once and execute the defined template by name. Add the result as a new file.
//     The name is either the templateName or taken from [Project.OutputMapping].
//   - if ExecType is Unprocessed|TextTemplateToText|HtmlTemplateToHtml and there is only a single file result, just return those bytes. Otherwise, return a zip file.
//   - if ExecType is xToPDF try first to render locally and otherwise create a zip file, lookup a secret and try to render using a REST Service.
type Execute func(subject auth.Subject, id ID, options ExecOptions) (io.ReadCloser, error)

// FindAll returns those Project entries, which are allowed by [Project.ReadableBy] (empty means, read by all). Also, the subject must
// have the permission per se. If tags are empty, the filter is ignored. Otherwise, all tags are evaluated using AND
// semantics.
type FindAll func(subject auth.Subject, tags []Tag) iter.Seq2[Project, error]

// Commit overwrites the given project entry with a new version, if allowed. See [Project.WriteableBy] and [PermCommit].
// Note, that Commit will fail, if there are any groups listed, to which the user does not belong, to mitigate
// potential security issues, like inserting malicious templates into otherwise unreachable circles.
type Commit func(subject auth.Subject, project Project) error

// Create inserts the given project and returns the ID which is autogenerated, if empty. Requires [PermCreate].
type Create func(subject auth.Subject, project Project) (ID, error)

type Versions func(subject auth.Subject, id ID) iter.Seq2[VersionID, error]
type FindVersion func(subject auth.Subject, id VersionID) (std.Option[Project], error)

type NewProjectData struct {
	ID          ID
	Name        string
	Description string
	ExecType    ExecType
	Tags        []Tag
	Files       fs.FS
}

// EnsureBuildIn writes the given project data if no such project already exist. Otherwise, it does nothing.
// If force is true, the project will be overwritten, just like as it has been created.
type EnsureBuildIn func(subject auth.Subject, project NewProjectData, force bool) error

type VersionID string
type ID string

type LanguageTag string

type JSONString = string

type DefinedTemplateName = string

type Tag string
type Project struct {
	ID            ID
	Name          string
	Description   string
	Logo          core.URI
	Type          ExecType // type of evaluation/engine
	Files         []File
	Examples      map[DefinedTemplateName]JSONString
	OutputMapping map[DefinedTemplateName]Filename // optionally map specific template names to create new file names as a result
	Protected     bool                             // just an extra layer of security, for very important templates, like system mail templates
	RemovableBy   []group.ID                       // if not empty, only members of the given groups can delete this project.
	WriteableBy   []group.ID                       // if not empty, only members of the given groups are allowed to update this project.
	ReadableBy    []group.ID                       // if not empty, only members of the given groups can see or execute this project.
	Tags          []Tag                            // some arbitrary tags for filtering and inspection
}

func (p Project) Identity() ID {
	return p.ID
}

// Localize applies the localization logic. If a locales folder exists, match against those files and blend them
// onto the default file set and return that. An undefined tag or non locales at all will just return [Project.Default].
func (p Project) Localize(tag language.Tag) []File {
	files := p.Default()
	if tag == language.Und {
		return files
	}

	available := p.Locales()
	if len(available) == 0 {
		return files
	}

	tags := make([]language.Tag, 0, len(available))
	for _, loc := range available {
		tags = append(tags, loc.Tag)
	}
	matcher := language.NewMatcher(tags)
	_, idx, _ := matcher.Match(tag) // at worst, just the first entry is returned
	tags[idx] = tag

	loc := available[idx]

	for _, file := range p.Files {
		if !strings.HasPrefix(file.Filename, loc.Prefix) {
			continue
		}

		targetPath := strings.TrimPrefix(file.Filename, loc.Prefix)
		files = slices.DeleteFunc(files, func(file File) bool {
			return file.Filename == targetPath
		})

		files = append(files, File{
			Filename: targetPath,
			Blob:     file.Blob,
			LastMod:  file.LastMod,
		})
	}

	return files
}

func (p Project) HasHTML() bool {
	for _, file := range p.Files {
		if strings.HasSuffix(file.Filename, ".gohtml") {
			return true
		}
	}

	return false
}

type LocalizedPrefix struct {
	Prefix Filename
	Tag    language.Tag
}

// Locales returns all available language tags in sorted order.
func (p Project) Locales() []LocalizedPrefix {
	tmp := map[string]bool{}
	for _, file := range p.Files {
		if !strings.HasPrefix(file.Filename, "locales") {
			continue
		}

		segments := strings.Split(file.Filename, "/")
		if len(segments) <= 2 {
			// this must be something broken, like a file in locales
			slog.Error("template project contains stale file in locales", "file", file.Filename, "id", p.ID, "name", p.Name)
			continue
		}

		tmp[segments[1]] = true
	}

	res := make([]LocalizedPrefix, 0, len(tmp))
	// todo this sorting is stable but non-sense: start with en, de, fr, es languages first and then append sorted rest
	for _, tagName := range slices.Sorted(maps.Keys(tmp)) {
		tag, err := language.Parse(tagName)
		if err != nil {
			slog.Error("template project contains invalid BCP47 tag in locales", "tag", tagName, "id", p.ID, "name", p.Name)
			continue
		}

		res = append(res, LocalizedPrefix{
			Prefix: "locales/" + tagName,
			Tag:    tag,
		})
	}

	return res
}

// Default returns the default file set.
func (p Project) Default() []File {
	files := make([]File, 0, len(p.Files))
	for _, file := range p.Files {
		if strings.HasPrefix(file.Filename, "locales") {
			continue
		}

		files = append(files, file)
	}

	return files
}

type Filename = string
type BlobID = string

type FileSet map[Filename]File

type File struct {
	// including the path, e.g. index.gohtml or locales/en/index.gohtml. The path rules follow the official fs
	// guidelines, thus starting with / or containing . or .. is invalid.
	Filename Filename

	Blob    BlobID
	LastMod time.Time
}

// IsTemplate inspects the file name
func (f File) IsTemplate() bool {
	return strings.HasSuffix(f.Filename, ".gohtml") || strings.HasSuffix(f.Filename, ".tpl")
}

// Name returns the target (stripped) filename. E.g. index.gohtml becomes index.html or index.html.tpl
// becomes index.html.
func cleanName(name string) string {
	if strings.HasSuffix(name, ".gohtml") {
		return name[:len(name)-7] + ".html"
	}

	if strings.HasSuffix(name, ".tpl") {
		return name[:len(name)-4]
	}

	return name
}

type Repository data.Repository[Project, ID]

type UseCases struct {
	FindAll       FindAll
	Execute       Execute
	Create        Create
	EnsureBuildIn EnsureBuildIn
}

func NewUseCases(files blob.Store, repository Repository) UseCases {
	var mutex sync.Mutex

	executeFn := NewExecute(files, repository)
	findAllFn := NewFindAll(repository)
	createFn := NewCreate(&mutex, repository)
	ensureBuildInFn := NewEnsureBuildIn(&mutex, repository, files)

	return UseCases{
		FindAll:       findAllFn,
		Execute:       executeFn,
		Create:        createFn,
		EnsureBuildIn: ensureBuildInFn,
	}
}
